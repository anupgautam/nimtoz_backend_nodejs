
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model District
 * 
 */
export type District = $Result.DefaultSelection<Prisma.$DistrictPayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventType
 * 
 */
export type EventType = $Result.DefaultSelection<Prisma.$EventTypePayload>
/**
 * Model EventEventType
 * 
 */
export type EventEventType = $Result.DefaultSelection<Prisma.$EventEventTypePayload>
/**
 * Model Multimedia
 * 
 */
export type Multimedia = $Result.DefaultSelection<Prisma.$MultimediaPayload>
/**
 * Model Musical
 * 
 */
export type Musical = $Result.DefaultSelection<Prisma.$MusicalPayload>
/**
 * Model Luxury
 * 
 */
export type Luxury = $Result.DefaultSelection<Prisma.$LuxuryPayload>
/**
 * Model Entertainment
 * 
 */
export type Entertainment = $Result.DefaultSelection<Prisma.$EntertainmentPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model BeautyDecor
 * 
 */
export type BeautyDecor = $Result.DefaultSelection<Prisma.$BeautyDecorPayload>
/**
 * Model Adventure
 * 
 */
export type Adventure = $Result.DefaultSelection<Prisma.$AdventurePayload>
/**
 * Model PartyPalace
 * 
 */
export type PartyPalace = $Result.DefaultSelection<Prisma.$PartyPalacePayload>
/**
 * Model CateringTent
 * 
 */
export type CateringTent = $Result.DefaultSelection<Prisma.$CateringTentPayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>
/**
 * Model ContactUs
 * 
 */
export type ContactUs = $Result.DefaultSelection<Prisma.$ContactUsPayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model ProductRating
 * 
 */
export type ProductRating = $Result.DefaultSelection<Prisma.$ProductRatingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.district`: Exposes CRUD operations for the **District** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Districts
    * const districts = await prisma.district.findMany()
    * ```
    */
  get district(): Prisma.DistrictDelegate<ExtArgs>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.eventType`: Exposes CRUD operations for the **EventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTypes
    * const eventTypes = await prisma.eventType.findMany()
    * ```
    */
  get eventType(): Prisma.EventTypeDelegate<ExtArgs>;

  /**
   * `prisma.eventEventType`: Exposes CRUD operations for the **EventEventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventEventTypes
    * const eventEventTypes = await prisma.eventEventType.findMany()
    * ```
    */
  get eventEventType(): Prisma.EventEventTypeDelegate<ExtArgs>;

  /**
   * `prisma.multimedia`: Exposes CRUD operations for the **Multimedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Multimedias
    * const multimedias = await prisma.multimedia.findMany()
    * ```
    */
  get multimedia(): Prisma.MultimediaDelegate<ExtArgs>;

  /**
   * `prisma.musical`: Exposes CRUD operations for the **Musical** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Musicals
    * const musicals = await prisma.musical.findMany()
    * ```
    */
  get musical(): Prisma.MusicalDelegate<ExtArgs>;

  /**
   * `prisma.luxury`: Exposes CRUD operations for the **Luxury** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Luxuries
    * const luxuries = await prisma.luxury.findMany()
    * ```
    */
  get luxury(): Prisma.LuxuryDelegate<ExtArgs>;

  /**
   * `prisma.entertainment`: Exposes CRUD operations for the **Entertainment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entertainments
    * const entertainments = await prisma.entertainment.findMany()
    * ```
    */
  get entertainment(): Prisma.EntertainmentDelegate<ExtArgs>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs>;

  /**
   * `prisma.beautyDecor`: Exposes CRUD operations for the **BeautyDecor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BeautyDecors
    * const beautyDecors = await prisma.beautyDecor.findMany()
    * ```
    */
  get beautyDecor(): Prisma.BeautyDecorDelegate<ExtArgs>;

  /**
   * `prisma.adventure`: Exposes CRUD operations for the **Adventure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adventures
    * const adventures = await prisma.adventure.findMany()
    * ```
    */
  get adventure(): Prisma.AdventureDelegate<ExtArgs>;

  /**
   * `prisma.partyPalace`: Exposes CRUD operations for the **PartyPalace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartyPalaces
    * const partyPalaces = await prisma.partyPalace.findMany()
    * ```
    */
  get partyPalace(): Prisma.PartyPalaceDelegate<ExtArgs>;

  /**
   * `prisma.cateringTent`: Exposes CRUD operations for the **CateringTent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CateringTents
    * const cateringTents = await prisma.cateringTent.findMany()
    * ```
    */
  get cateringTent(): Prisma.CateringTentDelegate<ExtArgs>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<ExtArgs>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs>;

  /**
   * `prisma.productRating`: Exposes CRUD operations for the **ProductRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductRatings
    * const productRatings = await prisma.productRating.findMany()
    * ```
    */
  get productRating(): Prisma.ProductRatingDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Category: 'Category',
    District: 'District',
    Venue: 'Venue',
    Product: 'Product',
    Event: 'Event',
    EventType: 'EventType',
    EventEventType: 'EventEventType',
    Multimedia: 'Multimedia',
    Musical: 'Musical',
    Luxury: 'Luxury',
    Entertainment: 'Entertainment',
    Meeting: 'Meeting',
    BeautyDecor: 'BeautyDecor',
    Adventure: 'Adventure',
    PartyPalace: 'PartyPalace',
    CateringTent: 'CateringTent',
    ProductImage: 'ProductImage',
    ContactUs: 'ContactUs',
    Blog: 'Blog',
    ProductRating: 'ProductRating'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "category" | "district" | "venue" | "product" | "event" | "eventType" | "eventEventType" | "multimedia" | "musical" | "luxury" | "entertainment" | "meeting" | "beautyDecor" | "adventure" | "partyPalace" | "cateringTent" | "productImage" | "contactUs" | "blog" | "productRating"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      District: {
        payload: Prisma.$DistrictPayload<ExtArgs>
        fields: Prisma.DistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findFirst: {
            args: Prisma.DistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          findMany: {
            args: Prisma.DistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>[]
          }
          create: {
            args: Prisma.DistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          createMany: {
            args: Prisma.DistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          update: {
            args: Prisma.DistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          deleteMany: {
            args: Prisma.DistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DistrictPayload>
          }
          aggregate: {
            args: Prisma.DistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDistrict>
          }
          groupBy: {
            args: Prisma.DistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<DistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.DistrictCountArgs<ExtArgs>
            result: $Utils.Optional<DistrictCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventType: {
        payload: Prisma.$EventTypePayload<ExtArgs>
        fields: Prisma.EventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findFirst: {
            args: Prisma.EventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findMany: {
            args: Prisma.EventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          create: {
            args: Prisma.EventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          createMany: {
            args: Prisma.EventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          update: {
            args: Prisma.EventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          deleteMany: {
            args: Prisma.EventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          aggregate: {
            args: Prisma.EventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventType>
          }
          groupBy: {
            args: Prisma.EventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EventTypeCountAggregateOutputType> | number
          }
        }
      }
      EventEventType: {
        payload: Prisma.$EventEventTypePayload<ExtArgs>
        fields: Prisma.EventEventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventEventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventEventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>
          }
          findFirst: {
            args: Prisma.EventEventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventEventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>
          }
          findMany: {
            args: Prisma.EventEventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>[]
          }
          create: {
            args: Prisma.EventEventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>
          }
          createMany: {
            args: Prisma.EventEventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventEventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>
          }
          update: {
            args: Prisma.EventEventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>
          }
          deleteMany: {
            args: Prisma.EventEventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventEventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventEventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventEventTypePayload>
          }
          aggregate: {
            args: Prisma.EventEventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventEventType>
          }
          groupBy: {
            args: Prisma.EventEventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventEventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventEventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EventEventTypeCountAggregateOutputType> | number
          }
        }
      }
      Multimedia: {
        payload: Prisma.$MultimediaPayload<ExtArgs>
        fields: Prisma.MultimediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultimediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultimediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>
          }
          findFirst: {
            args: Prisma.MultimediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultimediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>
          }
          findMany: {
            args: Prisma.MultimediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>[]
          }
          create: {
            args: Prisma.MultimediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>
          }
          createMany: {
            args: Prisma.MultimediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MultimediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>
          }
          update: {
            args: Prisma.MultimediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>
          }
          deleteMany: {
            args: Prisma.MultimediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultimediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MultimediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultimediaPayload>
          }
          aggregate: {
            args: Prisma.MultimediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultimedia>
          }
          groupBy: {
            args: Prisma.MultimediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultimediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultimediaCountArgs<ExtArgs>
            result: $Utils.Optional<MultimediaCountAggregateOutputType> | number
          }
        }
      }
      Musical: {
        payload: Prisma.$MusicalPayload<ExtArgs>
        fields: Prisma.MusicalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MusicalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MusicalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          findFirst: {
            args: Prisma.MusicalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MusicalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          findMany: {
            args: Prisma.MusicalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>[]
          }
          create: {
            args: Prisma.MusicalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          createMany: {
            args: Prisma.MusicalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MusicalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          update: {
            args: Prisma.MusicalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          deleteMany: {
            args: Prisma.MusicalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MusicalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MusicalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MusicalPayload>
          }
          aggregate: {
            args: Prisma.MusicalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMusical>
          }
          groupBy: {
            args: Prisma.MusicalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MusicalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MusicalCountArgs<ExtArgs>
            result: $Utils.Optional<MusicalCountAggregateOutputType> | number
          }
        }
      }
      Luxury: {
        payload: Prisma.$LuxuryPayload<ExtArgs>
        fields: Prisma.LuxuryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LuxuryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LuxuryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>
          }
          findFirst: {
            args: Prisma.LuxuryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LuxuryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>
          }
          findMany: {
            args: Prisma.LuxuryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>[]
          }
          create: {
            args: Prisma.LuxuryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>
          }
          createMany: {
            args: Prisma.LuxuryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LuxuryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>
          }
          update: {
            args: Prisma.LuxuryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>
          }
          deleteMany: {
            args: Prisma.LuxuryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LuxuryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LuxuryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LuxuryPayload>
          }
          aggregate: {
            args: Prisma.LuxuryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLuxury>
          }
          groupBy: {
            args: Prisma.LuxuryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LuxuryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LuxuryCountArgs<ExtArgs>
            result: $Utils.Optional<LuxuryCountAggregateOutputType> | number
          }
        }
      }
      Entertainment: {
        payload: Prisma.$EntertainmentPayload<ExtArgs>
        fields: Prisma.EntertainmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntertainmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntertainmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>
          }
          findFirst: {
            args: Prisma.EntertainmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntertainmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>
          }
          findMany: {
            args: Prisma.EntertainmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>[]
          }
          create: {
            args: Prisma.EntertainmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>
          }
          createMany: {
            args: Prisma.EntertainmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntertainmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>
          }
          update: {
            args: Prisma.EntertainmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>
          }
          deleteMany: {
            args: Prisma.EntertainmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntertainmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntertainmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntertainmentPayload>
          }
          aggregate: {
            args: Prisma.EntertainmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntertainment>
          }
          groupBy: {
            args: Prisma.EntertainmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntertainmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntertainmentCountArgs<ExtArgs>
            result: $Utils.Optional<EntertainmentCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      BeautyDecor: {
        payload: Prisma.$BeautyDecorPayload<ExtArgs>
        fields: Prisma.BeautyDecorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BeautyDecorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BeautyDecorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>
          }
          findFirst: {
            args: Prisma.BeautyDecorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BeautyDecorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>
          }
          findMany: {
            args: Prisma.BeautyDecorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>[]
          }
          create: {
            args: Prisma.BeautyDecorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>
          }
          createMany: {
            args: Prisma.BeautyDecorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BeautyDecorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>
          }
          update: {
            args: Prisma.BeautyDecorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>
          }
          deleteMany: {
            args: Prisma.BeautyDecorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BeautyDecorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BeautyDecorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BeautyDecorPayload>
          }
          aggregate: {
            args: Prisma.BeautyDecorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeautyDecor>
          }
          groupBy: {
            args: Prisma.BeautyDecorGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeautyDecorGroupByOutputType>[]
          }
          count: {
            args: Prisma.BeautyDecorCountArgs<ExtArgs>
            result: $Utils.Optional<BeautyDecorCountAggregateOutputType> | number
          }
        }
      }
      Adventure: {
        payload: Prisma.$AdventurePayload<ExtArgs>
        fields: Prisma.AdventureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdventureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdventureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          findFirst: {
            args: Prisma.AdventureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdventureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          findMany: {
            args: Prisma.AdventureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          create: {
            args: Prisma.AdventureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          createMany: {
            args: Prisma.AdventureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdventureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          update: {
            args: Prisma.AdventureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          deleteMany: {
            args: Prisma.AdventureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdventureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdventureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          aggregate: {
            args: Prisma.AdventureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdventure>
          }
          groupBy: {
            args: Prisma.AdventureGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdventureGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdventureCountArgs<ExtArgs>
            result: $Utils.Optional<AdventureCountAggregateOutputType> | number
          }
        }
      }
      PartyPalace: {
        payload: Prisma.$PartyPalacePayload<ExtArgs>
        fields: Prisma.PartyPalaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartyPalaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartyPalaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>
          }
          findFirst: {
            args: Prisma.PartyPalaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartyPalaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>
          }
          findMany: {
            args: Prisma.PartyPalaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>[]
          }
          create: {
            args: Prisma.PartyPalaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>
          }
          createMany: {
            args: Prisma.PartyPalaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PartyPalaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>
          }
          update: {
            args: Prisma.PartyPalaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>
          }
          deleteMany: {
            args: Prisma.PartyPalaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartyPalaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartyPalaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPalacePayload>
          }
          aggregate: {
            args: Prisma.PartyPalaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartyPalace>
          }
          groupBy: {
            args: Prisma.PartyPalaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartyPalaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartyPalaceCountArgs<ExtArgs>
            result: $Utils.Optional<PartyPalaceCountAggregateOutputType> | number
          }
        }
      }
      CateringTent: {
        payload: Prisma.$CateringTentPayload<ExtArgs>
        fields: Prisma.CateringTentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CateringTentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CateringTentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>
          }
          findFirst: {
            args: Prisma.CateringTentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CateringTentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>
          }
          findMany: {
            args: Prisma.CateringTentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>[]
          }
          create: {
            args: Prisma.CateringTentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>
          }
          createMany: {
            args: Prisma.CateringTentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CateringTentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>
          }
          update: {
            args: Prisma.CateringTentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>
          }
          deleteMany: {
            args: Prisma.CateringTentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CateringTentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CateringTentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CateringTentPayload>
          }
          aggregate: {
            args: Prisma.CateringTentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCateringTent>
          }
          groupBy: {
            args: Prisma.CateringTentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CateringTentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CateringTentCountArgs<ExtArgs>
            result: $Utils.Optional<CateringTentCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
      ContactUs: {
        payload: Prisma.$ContactUsPayload<ExtArgs>
        fields: Prisma.ContactUsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactUsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findFirst: {
            args: Prisma.ContactUsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findMany: {
            args: Prisma.ContactUsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          create: {
            args: Prisma.ContactUsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          createMany: {
            args: Prisma.ContactUsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactUsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          update: {
            args: Prisma.ContactUsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          deleteMany: {
            args: Prisma.ContactUsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.ContactUsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactUsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      ProductRating: {
        payload: Prisma.$ProductRatingPayload<ExtArgs>
        fields: Prisma.ProductRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>
          }
          findFirst: {
            args: Prisma.ProductRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>
          }
          findMany: {
            args: Prisma.ProductRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>[]
          }
          create: {
            args: Prisma.ProductRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>
          }
          createMany: {
            args: Prisma.ProductRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>
          }
          update: {
            args: Prisma.ProductRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>
          }
          deleteMany: {
            args: Prisma.ProductRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRatingPayload>
          }
          aggregate: {
            args: Prisma.ProductRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductRating>
          }
          groupBy: {
            args: Prisma.ProductRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ProductRatingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    events_booked: number
    blogs_approved: number
    blogs_author: number
    ratings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events_booked?: boolean | UserCountOutputTypeCountEvents_bookedArgs
    blogs_approved?: boolean | UserCountOutputTypeCountBlogs_approvedArgs
    blogs_author?: boolean | UserCountOutputTypeCountBlogs_authorArgs
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvents_bookedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogs_approvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogs_authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRatingWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type DistrictCountOutputType
   */

  export type DistrictCountOutputType = {
    products: number
  }

  export type DistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | DistrictCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DistrictCountOutputType
     */
    select?: DistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DistrictCountOutputType without action
   */
  export type DistrictCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    products: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | VenueCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    multimedia: number
    entertainment: number
    musical: number
    luxury: number
    meeting: number
    beautydecor: number
    adventure: number
    partypalace: number
    cateringtent: number
    product_image: number
    event: number
    ratings: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    multimedia?: boolean | ProductCountOutputTypeCountMultimediaArgs
    entertainment?: boolean | ProductCountOutputTypeCountEntertainmentArgs
    musical?: boolean | ProductCountOutputTypeCountMusicalArgs
    luxury?: boolean | ProductCountOutputTypeCountLuxuryArgs
    meeting?: boolean | ProductCountOutputTypeCountMeetingArgs
    beautydecor?: boolean | ProductCountOutputTypeCountBeautydecorArgs
    adventure?: boolean | ProductCountOutputTypeCountAdventureArgs
    partypalace?: boolean | ProductCountOutputTypeCountPartypalaceArgs
    cateringtent?: boolean | ProductCountOutputTypeCountCateringtentArgs
    product_image?: boolean | ProductCountOutputTypeCountProduct_imageArgs
    event?: boolean | ProductCountOutputTypeCountEventArgs
    ratings?: boolean | ProductCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMultimediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultimediaWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountEntertainmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntertainmentWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMusicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountLuxuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LuxuryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBeautydecorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeautyDecorWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdventureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPartypalaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartyPalaceWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCateringtentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringTentWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRatingWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    PartyPalace: number
    CateringTent: number
    Adventure: number
    BeautyDecor: number
    Meeting: number
    Entertainment: number
    Luxury: number
    Musical: number
    Multimedia: number
    EventTypes: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PartyPalace?: boolean | EventCountOutputTypeCountPartyPalaceArgs
    CateringTent?: boolean | EventCountOutputTypeCountCateringTentArgs
    Adventure?: boolean | EventCountOutputTypeCountAdventureArgs
    BeautyDecor?: boolean | EventCountOutputTypeCountBeautyDecorArgs
    Meeting?: boolean | EventCountOutputTypeCountMeetingArgs
    Entertainment?: boolean | EventCountOutputTypeCountEntertainmentArgs
    Luxury?: boolean | EventCountOutputTypeCountLuxuryArgs
    Musical?: boolean | EventCountOutputTypeCountMusicalArgs
    Multimedia?: boolean | EventCountOutputTypeCountMultimediaArgs
    EventTypes?: boolean | EventCountOutputTypeCountEventTypesArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountPartyPalaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartyPalaceWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountCateringTentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringTentWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountAdventureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountBeautyDecorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeautyDecorWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountMeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEntertainmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntertainmentWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountLuxuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LuxuryWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountMusicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountMultimediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultimediaWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventEventTypeWhereInput
  }


  /**
   * Count Type EventTypeCountOutputType
   */

  export type EventTypeCountOutputType = {
    Events: number
  }

  export type EventTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | EventTypeCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * EventTypeCountOutputType without action
   */
  export type EventTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTypeCountOutputType
     */
    select?: EventTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventTypeCountOutputType without action
   */
  export type EventTypeCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventEventTypeWhereInput
  }


  /**
   * Count Type MultimediaCountOutputType
   */

  export type MultimediaCountOutputType = {
    events: number
  }

  export type MultimediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | MultimediaCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * MultimediaCountOutputType without action
   */
  export type MultimediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultimediaCountOutputType
     */
    select?: MultimediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultimediaCountOutputType without action
   */
  export type MultimediaCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type MusicalCountOutputType
   */

  export type MusicalCountOutputType = {
    events: number
  }

  export type MusicalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | MusicalCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * MusicalCountOutputType without action
   */
  export type MusicalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicalCountOutputType
     */
    select?: MusicalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MusicalCountOutputType without action
   */
  export type MusicalCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type LuxuryCountOutputType
   */

  export type LuxuryCountOutputType = {
    events: number
  }

  export type LuxuryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | LuxuryCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * LuxuryCountOutputType without action
   */
  export type LuxuryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuxuryCountOutputType
     */
    select?: LuxuryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LuxuryCountOutputType without action
   */
  export type LuxuryCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type EntertainmentCountOutputType
   */

  export type EntertainmentCountOutputType = {
    events: number
  }

  export type EntertainmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | EntertainmentCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * EntertainmentCountOutputType without action
   */
  export type EntertainmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntertainmentCountOutputType
     */
    select?: EntertainmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntertainmentCountOutputType without action
   */
  export type EntertainmentCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type BeautyDecorCountOutputType
   */

  export type BeautyDecorCountOutputType = {
    events: number
  }

  export type BeautyDecorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | BeautyDecorCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * BeautyDecorCountOutputType without action
   */
  export type BeautyDecorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecorCountOutputType
     */
    select?: BeautyDecorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BeautyDecorCountOutputType without action
   */
  export type BeautyDecorCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type AdventureCountOutputType
   */

  export type AdventureCountOutputType = {
    events: number
  }

  export type AdventureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | AdventureCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * AdventureCountOutputType without action
   */
  export type AdventureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureCountOutputType
     */
    select?: AdventureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdventureCountOutputType without action
   */
  export type AdventureCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type PartyPalaceCountOutputType
   */

  export type PartyPalaceCountOutputType = {
    events: number
  }

  export type PartyPalaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | PartyPalaceCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * PartyPalaceCountOutputType without action
   */
  export type PartyPalaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalaceCountOutputType
     */
    select?: PartyPalaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartyPalaceCountOutputType without action
   */
  export type PartyPalaceCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type CateringTentCountOutputType
   */

  export type CateringTentCountOutputType = {
    events: number
  }

  export type CateringTentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | CateringTentCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * CateringTentCountOutputType without action
   */
  export type CateringTentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTentCountOutputType
     */
    select?: CateringTentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CateringTentCountOutputType without action
   */
  export type CateringTentCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    phone_number: string | null
    role: $Enums.Role | null
    avatar: string | null
    resetPasswordToken: string | null
    resetPasswordTokenExpiry: Date | null
    refreshToken: string | null
    otp: string | null
    otpExpiresAt: Date | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstname: string | null
    lastname: string | null
    email: string | null
    password: string | null
    phone_number: string | null
    role: $Enums.Role | null
    avatar: string | null
    resetPasswordToken: string | null
    resetPasswordTokenExpiry: Date | null
    refreshToken: string | null
    otp: string | null
    otpExpiresAt: Date | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    password: number
    phone_number: number
    role: number
    avatar: number
    resetPasswordToken: number
    resetPasswordTokenExpiry: number
    refreshToken: number
    otp: number
    otpExpiresAt: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    phone_number?: true
    role?: true
    avatar?: true
    resetPasswordToken?: true
    resetPasswordTokenExpiry?: true
    refreshToken?: true
    otp?: true
    otpExpiresAt?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    phone_number?: true
    role?: true
    avatar?: true
    resetPasswordToken?: true
    resetPasswordTokenExpiry?: true
    refreshToken?: true
    otp?: true
    otpExpiresAt?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    password?: true
    phone_number?: true
    role?: true
    avatar?: true
    resetPasswordToken?: true
    resetPasswordTokenExpiry?: true
    refreshToken?: true
    otp?: true
    otpExpiresAt?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role: $Enums.Role
    avatar: string | null
    resetPasswordToken: string | null
    resetPasswordTokenExpiry: Date | null
    refreshToken: string | null
    otp: string | null
    otpExpiresAt: Date | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    role?: boolean
    avatar?: boolean
    resetPasswordToken?: boolean
    resetPasswordTokenExpiry?: boolean
    refreshToken?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    events_booked?: boolean | User$events_bookedArgs<ExtArgs>
    blogs_approved?: boolean | User$blogs_approvedArgs<ExtArgs>
    blogs_author?: boolean | User$blogs_authorArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    password?: boolean
    phone_number?: boolean
    role?: boolean
    avatar?: boolean
    resetPasswordToken?: boolean
    resetPasswordTokenExpiry?: boolean
    refreshToken?: boolean
    otp?: boolean
    otpExpiresAt?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events_booked?: boolean | User$events_bookedArgs<ExtArgs>
    blogs_approved?: boolean | User$blogs_approvedArgs<ExtArgs>
    blogs_author?: boolean | User$blogs_authorArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      events_booked: Prisma.$EventPayload<ExtArgs>[]
      blogs_approved: Prisma.$BlogPayload<ExtArgs>[]
      blogs_author: Prisma.$BlogPayload<ExtArgs>[]
      ratings: Prisma.$ProductRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstname: string
      lastname: string
      email: string
      password: string
      phone_number: string
      role: $Enums.Role
      avatar: string | null
      resetPasswordToken: string | null
      resetPasswordTokenExpiry: Date | null
      refreshToken: string | null
      otp: string | null
      otpExpiresAt: Date | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events_booked<T extends User$events_bookedArgs<ExtArgs> = {}>(args?: Subset<T, User$events_bookedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    blogs_approved<T extends User$blogs_approvedArgs<ExtArgs> = {}>(args?: Subset<T, User$blogs_approvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany"> | Null>
    blogs_author<T extends User$blogs_authorArgs<ExtArgs> = {}>(args?: Subset<T, User$blogs_authorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstname: FieldRef<"User", 'String'>
    readonly lastname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly resetPasswordToken: FieldRef<"User", 'String'>
    readonly resetPasswordTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly otp: FieldRef<"User", 'String'>
    readonly otpExpiresAt: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.events_booked
   */
  export type User$events_bookedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.blogs_approved
   */
  export type User$blogs_approvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * User.blogs_author
   */
  export type User$blogs_authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    where?: ProductRatingWhereInput
    orderBy?: ProductRatingOrderByWithRelationInput | ProductRatingOrderByWithRelationInput[]
    cursor?: ProductRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductRatingScalarFieldEnum | ProductRatingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    category_name: string | null
    category_icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    category_name: string | null
    category_icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    category_name: number
    category_icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    category_name?: true
    category_icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    category_name?: true
    category_icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    category_name?: true
    category_icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    category_name: string
    category_icon: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    category_icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>


  export type CategorySelectScalar = {
    id?: boolean
    category_name?: boolean
    category_icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category_name: string
      category_icon: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly category_name: FieldRef<"Category", 'String'>
    readonly category_icon: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model District
   */

  export type AggregateDistrict = {
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  export type DistrictAvgAggregateOutputType = {
    id: number | null
  }

  export type DistrictSumAggregateOutputType = {
    id: number | null
  }

  export type DistrictMinAggregateOutputType = {
    id: number | null
    district_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistrictMaxAggregateOutputType = {
    id: number | null
    district_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DistrictCountAggregateOutputType = {
    id: number
    district_name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DistrictAvgAggregateInputType = {
    id?: true
  }

  export type DistrictSumAggregateInputType = {
    id?: true
  }

  export type DistrictMinAggregateInputType = {
    id?: true
    district_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistrictMaxAggregateInputType = {
    id?: true
    district_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DistrictCountAggregateInputType = {
    id?: true
    district_name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which District to aggregate.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Districts
    **/
    _count?: true | DistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DistrictMaxAggregateInputType
  }

  export type GetDistrictAggregateType<T extends DistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateDistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDistrict[P]>
      : GetScalarType<T[P], AggregateDistrict[P]>
  }




  export type DistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DistrictWhereInput
    orderBy?: DistrictOrderByWithAggregationInput | DistrictOrderByWithAggregationInput[]
    by: DistrictScalarFieldEnum[] | DistrictScalarFieldEnum
    having?: DistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DistrictCountAggregateInputType | true
    _avg?: DistrictAvgAggregateInputType
    _sum?: DistrictSumAggregateInputType
    _min?: DistrictMinAggregateInputType
    _max?: DistrictMaxAggregateInputType
  }

  export type DistrictGroupByOutputType = {
    id: number
    district_name: string
    createdAt: Date
    updatedAt: Date
    _count: DistrictCountAggregateOutputType | null
    _avg: DistrictAvgAggregateOutputType | null
    _sum: DistrictSumAggregateOutputType | null
    _min: DistrictMinAggregateOutputType | null
    _max: DistrictMaxAggregateOutputType | null
  }

  type GetDistrictGroupByPayload<T extends DistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DistrictGroupByOutputType[P]>
            : GetScalarType<T[P], DistrictGroupByOutputType[P]>
        }
      >
    >


  export type DistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    district_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | District$productsArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["district"]>


  export type DistrictSelectScalar = {
    id?: boolean
    district_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | District$productsArgs<ExtArgs>
    _count?: boolean | DistrictCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "District"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      district_name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["district"]>
    composites: {}
  }

  type DistrictGetPayload<S extends boolean | null | undefined | DistrictDefaultArgs> = $Result.GetResult<Prisma.$DistrictPayload, S>

  type DistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DistrictFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DistrictCountAggregateInputType | true
    }

  export interface DistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['District'], meta: { name: 'District' } }
    /**
     * Find zero or one District that matches the filter.
     * @param {DistrictFindUniqueArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DistrictFindUniqueArgs>(args: SelectSubset<T, DistrictFindUniqueArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one District that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DistrictFindUniqueOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, DistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first District that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DistrictFindFirstArgs>(args?: SelectSubset<T, DistrictFindFirstArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first District that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindFirstOrThrowArgs} args - Arguments to find a District
     * @example
     * // Get one District
     * const district = await prisma.district.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, DistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Districts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Districts
     * const districts = await prisma.district.findMany()
     * 
     * // Get first 10 Districts
     * const districts = await prisma.district.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const districtWithIdOnly = await prisma.district.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DistrictFindManyArgs>(args?: SelectSubset<T, DistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a District.
     * @param {DistrictCreateArgs} args - Arguments to create a District.
     * @example
     * // Create one District
     * const District = await prisma.district.create({
     *   data: {
     *     // ... data to create a District
     *   }
     * })
     * 
     */
    create<T extends DistrictCreateArgs>(args: SelectSubset<T, DistrictCreateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Districts.
     * @param {DistrictCreateManyArgs} args - Arguments to create many Districts.
     * @example
     * // Create many Districts
     * const district = await prisma.district.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DistrictCreateManyArgs>(args?: SelectSubset<T, DistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a District.
     * @param {DistrictDeleteArgs} args - Arguments to delete one District.
     * @example
     * // Delete one District
     * const District = await prisma.district.delete({
     *   where: {
     *     // ... filter to delete one District
     *   }
     * })
     * 
     */
    delete<T extends DistrictDeleteArgs>(args: SelectSubset<T, DistrictDeleteArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one District.
     * @param {DistrictUpdateArgs} args - Arguments to update one District.
     * @example
     * // Update one District
     * const district = await prisma.district.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DistrictUpdateArgs>(args: SelectSubset<T, DistrictUpdateArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Districts.
     * @param {DistrictDeleteManyArgs} args - Arguments to filter Districts to delete.
     * @example
     * // Delete a few Districts
     * const { count } = await prisma.district.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DistrictDeleteManyArgs>(args?: SelectSubset<T, DistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Districts
     * const district = await prisma.district.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DistrictUpdateManyArgs>(args: SelectSubset<T, DistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one District.
     * @param {DistrictUpsertArgs} args - Arguments to update or create a District.
     * @example
     * // Update or create a District
     * const district = await prisma.district.upsert({
     *   create: {
     *     // ... data to create a District
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the District we want to update
     *   }
     * })
     */
    upsert<T extends DistrictUpsertArgs>(args: SelectSubset<T, DistrictUpsertArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Districts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictCountArgs} args - Arguments to filter Districts to count.
     * @example
     * // Count the number of Districts
     * const count = await prisma.district.count({
     *   where: {
     *     // ... the filter for the Districts we want to count
     *   }
     * })
    **/
    count<T extends DistrictCountArgs>(
      args?: Subset<T, DistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DistrictAggregateArgs>(args: Subset<T, DistrictAggregateArgs>): Prisma.PrismaPromise<GetDistrictAggregateType<T>>

    /**
     * Group by District.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DistrictGroupByArgs['orderBy'] }
        : { orderBy?: DistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the District model
   */
  readonly fields: DistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for District.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends District$productsArgs<ExtArgs> = {}>(args?: Subset<T, District$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the District model
   */ 
  interface DistrictFieldRefs {
    readonly id: FieldRef<"District", 'Int'>
    readonly district_name: FieldRef<"District", 'String'>
    readonly createdAt: FieldRef<"District", 'DateTime'>
    readonly updatedAt: FieldRef<"District", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * District findUnique
   */
  export type DistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findUniqueOrThrow
   */
  export type DistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District findFirst
   */
  export type DistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findFirstOrThrow
   */
  export type DistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which District to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Districts.
     */
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District findMany
   */
  export type DistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter, which Districts to fetch.
     */
    where?: DistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Districts to fetch.
     */
    orderBy?: DistrictOrderByWithRelationInput | DistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Districts.
     */
    cursor?: DistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Districts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Districts.
     */
    skip?: number
    distinct?: DistrictScalarFieldEnum | DistrictScalarFieldEnum[]
  }

  /**
   * District create
   */
  export type DistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a District.
     */
    data: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
  }

  /**
   * District createMany
   */
  export type DistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Districts.
     */
    data: DistrictCreateManyInput | DistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * District update
   */
  export type DistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a District.
     */
    data: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
    /**
     * Choose, which District to update.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District updateMany
   */
  export type DistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Districts.
     */
    data: XOR<DistrictUpdateManyMutationInput, DistrictUncheckedUpdateManyInput>
    /**
     * Filter which Districts to update
     */
    where?: DistrictWhereInput
  }

  /**
   * District upsert
   */
  export type DistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the District to update in case it exists.
     */
    where: DistrictWhereUniqueInput
    /**
     * In case the District found by the `where` argument doesn't exist, create a new District with this data.
     */
    create: XOR<DistrictCreateInput, DistrictUncheckedCreateInput>
    /**
     * In case the District was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DistrictUpdateInput, DistrictUncheckedUpdateInput>
  }

  /**
   * District delete
   */
  export type DistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
    /**
     * Filter which District to delete.
     */
    where: DistrictWhereUniqueInput
  }

  /**
   * District deleteMany
   */
  export type DistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Districts to delete
     */
    where?: DistrictWhereInput
  }

  /**
   * District.products
   */
  export type District$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * District without action
   */
  export type DistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the District
     */
    select?: DistrictSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DistrictInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    id: number | null
  }

  export type VenueSumAggregateOutputType = {
    id: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: number | null
    venue_name: string | null
    venue_address: string | null
    contact_person: string | null
    phone_number: string | null
    email: string | null
    pan_vat_number: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueMaxAggregateOutputType = {
    id: number | null
    venue_name: string | null
    venue_address: string | null
    contact_person: string | null
    phone_number: string | null
    email: string | null
    pan_vat_number: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    venue_name: number
    venue_address: number
    contact_person: number
    phone_number: number
    email: number
    pan_vat_number: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    id?: true
  }

  export type VenueSumAggregateInputType = {
    id?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    venue_name?: true
    venue_address?: true
    contact_person?: true
    phone_number?: true
    email?: true
    pan_vat_number?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    venue_name?: true
    venue_address?: true
    contact_person?: true
    phone_number?: true
    email?: true
    pan_vat_number?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    venue_name?: true
    venue_address?: true
    contact_person?: true
    phone_number?: true
    email?: true
    pan_vat_number?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: number
    venue_name: string
    venue_address: string
    contact_person: string
    phone_number: string
    email: string
    pan_vat_number: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venue_name?: boolean
    venue_address?: boolean
    contact_person?: boolean
    phone_number?: boolean
    email?: boolean
    pan_vat_number?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Venue$productsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>


  export type VenueSelectScalar = {
    id?: boolean
    venue_name?: boolean
    venue_address?: boolean
    contact_person?: boolean
    phone_number?: boolean
    email?: boolean
    pan_vat_number?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Venue$productsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      venue_name: string
      venue_address: string
      contact_person: string
      phone_number: string
      email: string
      pan_vat_number: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Venue$productsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */ 
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'Int'>
    readonly venue_name: FieldRef<"Venue", 'String'>
    readonly venue_address: FieldRef<"Venue", 'String'>
    readonly contact_person: FieldRef<"Venue", 'String'>
    readonly phone_number: FieldRef<"Venue", 'String'>
    readonly email: FieldRef<"Venue", 'String'>
    readonly pan_vat_number: FieldRef<"Venue", 'String'>
    readonly active: FieldRef<"Venue", 'Boolean'>
    readonly createdAt: FieldRef<"Venue", 'DateTime'>
    readonly updatedAt: FieldRef<"Venue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
  }

  /**
   * Venue.products
   */
  export type Venue$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    overall_rating: number | null
    category_id: number | null
    districtId: number | null
    businessId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    overall_rating: number | null
    category_id: number | null
    districtId: number | null
    businessId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    address: string | null
    short_description: string | null
    is_active: boolean | null
    overall_rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
    category_id: number | null
    districtId: number | null
    businessId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    address: string | null
    short_description: string | null
    is_active: boolean | null
    overall_rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
    category_id: number | null
    districtId: number | null
    businessId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    description: number
    address: number
    short_description: number
    is_active: number
    overall_rating: number
    createdAt: number
    updatedAt: number
    category_id: number
    districtId: number
    businessId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    overall_rating?: true
    category_id?: true
    districtId?: true
    businessId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    overall_rating?: true
    category_id?: true
    districtId?: true
    businessId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    address?: true
    short_description?: true
    is_active?: true
    overall_rating?: true
    createdAt?: true
    updatedAt?: true
    category_id?: true
    districtId?: true
    businessId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    address?: true
    short_description?: true
    is_active?: true
    overall_rating?: true
    createdAt?: true
    updatedAt?: true
    category_id?: true
    districtId?: true
    businessId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    address?: true
    short_description?: true
    is_active?: true
    overall_rating?: true
    createdAt?: true
    updatedAt?: true
    category_id?: true
    districtId?: true
    businessId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    title: string
    description: string
    address: string
    short_description: string | null
    is_active: boolean
    overall_rating: number
    createdAt: Date
    updatedAt: Date
    category_id: number
    districtId: number
    businessId: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    address?: boolean
    short_description?: boolean
    is_active?: boolean
    overall_rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category_id?: boolean
    districtId?: boolean
    businessId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    multimedia?: boolean | Product$multimediaArgs<ExtArgs>
    entertainment?: boolean | Product$entertainmentArgs<ExtArgs>
    musical?: boolean | Product$musicalArgs<ExtArgs>
    luxury?: boolean | Product$luxuryArgs<ExtArgs>
    meeting?: boolean | Product$meetingArgs<ExtArgs>
    beautydecor?: boolean | Product$beautydecorArgs<ExtArgs>
    adventure?: boolean | Product$adventureArgs<ExtArgs>
    partypalace?: boolean | Product$partypalaceArgs<ExtArgs>
    cateringtent?: boolean | Product$cateringtentArgs<ExtArgs>
    product_image?: boolean | Product$product_imageArgs<ExtArgs>
    event?: boolean | Product$eventArgs<ExtArgs>
    ratings?: boolean | Product$ratingsArgs<ExtArgs>
    District?: boolean | DistrictDefaultArgs<ExtArgs>
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>


  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    address?: boolean
    short_description?: boolean
    is_active?: boolean
    overall_rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category_id?: boolean
    districtId?: boolean
    businessId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    multimedia?: boolean | Product$multimediaArgs<ExtArgs>
    entertainment?: boolean | Product$entertainmentArgs<ExtArgs>
    musical?: boolean | Product$musicalArgs<ExtArgs>
    luxury?: boolean | Product$luxuryArgs<ExtArgs>
    meeting?: boolean | Product$meetingArgs<ExtArgs>
    beautydecor?: boolean | Product$beautydecorArgs<ExtArgs>
    adventure?: boolean | Product$adventureArgs<ExtArgs>
    partypalace?: boolean | Product$partypalaceArgs<ExtArgs>
    cateringtent?: boolean | Product$cateringtentArgs<ExtArgs>
    product_image?: boolean | Product$product_imageArgs<ExtArgs>
    event?: boolean | Product$eventArgs<ExtArgs>
    ratings?: boolean | Product$ratingsArgs<ExtArgs>
    District?: boolean | DistrictDefaultArgs<ExtArgs>
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      multimedia: Prisma.$MultimediaPayload<ExtArgs>[]
      entertainment: Prisma.$EntertainmentPayload<ExtArgs>[]
      musical: Prisma.$MusicalPayload<ExtArgs>[]
      luxury: Prisma.$LuxuryPayload<ExtArgs>[]
      meeting: Prisma.$MeetingPayload<ExtArgs>[]
      beautydecor: Prisma.$BeautyDecorPayload<ExtArgs>[]
      adventure: Prisma.$AdventurePayload<ExtArgs>[]
      partypalace: Prisma.$PartyPalacePayload<ExtArgs>[]
      cateringtent: Prisma.$CateringTentPayload<ExtArgs>[]
      product_image: Prisma.$ProductImagePayload<ExtArgs>[]
      event: Prisma.$EventPayload<ExtArgs>[]
      ratings: Prisma.$ProductRatingPayload<ExtArgs>[]
      District: Prisma.$DistrictPayload<ExtArgs>
      Venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      address: string
      short_description: string | null
      is_active: boolean
      overall_rating: number
      createdAt: Date
      updatedAt: Date
      category_id: number
      districtId: number
      businessId: number
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    multimedia<T extends Product$multimediaArgs<ExtArgs> = {}>(args?: Subset<T, Product$multimediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findMany"> | Null>
    entertainment<T extends Product$entertainmentArgs<ExtArgs> = {}>(args?: Subset<T, Product$entertainmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findMany"> | Null>
    musical<T extends Product$musicalArgs<ExtArgs> = {}>(args?: Subset<T, Product$musicalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findMany"> | Null>
    luxury<T extends Product$luxuryArgs<ExtArgs> = {}>(args?: Subset<T, Product$luxuryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findMany"> | Null>
    meeting<T extends Product$meetingArgs<ExtArgs> = {}>(args?: Subset<T, Product$meetingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    beautydecor<T extends Product$beautydecorArgs<ExtArgs> = {}>(args?: Subset<T, Product$beautydecorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findMany"> | Null>
    adventure<T extends Product$adventureArgs<ExtArgs> = {}>(args?: Subset<T, Product$adventureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany"> | Null>
    partypalace<T extends Product$partypalaceArgs<ExtArgs> = {}>(args?: Subset<T, Product$partypalaceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findMany"> | Null>
    cateringtent<T extends Product$cateringtentArgs<ExtArgs> = {}>(args?: Subset<T, Product$cateringtentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findMany"> | Null>
    product_image<T extends Product$product_imageArgs<ExtArgs> = {}>(args?: Subset<T, Product$product_imageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany"> | Null>
    event<T extends Product$eventArgs<ExtArgs> = {}>(args?: Subset<T, Product$eventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends Product$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Product$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findMany"> | Null>
    District<T extends DistrictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DistrictDefaultArgs<ExtArgs>>): Prisma__DistrictClient<$Result.GetResult<Prisma.$DistrictPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly address: FieldRef<"Product", 'String'>
    readonly short_description: FieldRef<"Product", 'String'>
    readonly is_active: FieldRef<"Product", 'Boolean'>
    readonly overall_rating: FieldRef<"Product", 'Float'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly category_id: FieldRef<"Product", 'Int'>
    readonly districtId: FieldRef<"Product", 'Int'>
    readonly businessId: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.multimedia
   */
  export type Product$multimediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    where?: MultimediaWhereInput
    orderBy?: MultimediaOrderByWithRelationInput | MultimediaOrderByWithRelationInput[]
    cursor?: MultimediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultimediaScalarFieldEnum | MultimediaScalarFieldEnum[]
  }

  /**
   * Product.entertainment
   */
  export type Product$entertainmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    where?: EntertainmentWhereInput
    orderBy?: EntertainmentOrderByWithRelationInput | EntertainmentOrderByWithRelationInput[]
    cursor?: EntertainmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntertainmentScalarFieldEnum | EntertainmentScalarFieldEnum[]
  }

  /**
   * Product.musical
   */
  export type Product$musicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    where?: MusicalWhereInput
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    cursor?: MusicalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Product.luxury
   */
  export type Product$luxuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    where?: LuxuryWhereInput
    orderBy?: LuxuryOrderByWithRelationInput | LuxuryOrderByWithRelationInput[]
    cursor?: LuxuryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LuxuryScalarFieldEnum | LuxuryScalarFieldEnum[]
  }

  /**
   * Product.meeting
   */
  export type Product$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Product.beautydecor
   */
  export type Product$beautydecorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    where?: BeautyDecorWhereInput
    orderBy?: BeautyDecorOrderByWithRelationInput | BeautyDecorOrderByWithRelationInput[]
    cursor?: BeautyDecorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeautyDecorScalarFieldEnum | BeautyDecorScalarFieldEnum[]
  }

  /**
   * Product.adventure
   */
  export type Product$adventureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    cursor?: AdventureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Product.partypalace
   */
  export type Product$partypalaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    where?: PartyPalaceWhereInput
    orderBy?: PartyPalaceOrderByWithRelationInput | PartyPalaceOrderByWithRelationInput[]
    cursor?: PartyPalaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartyPalaceScalarFieldEnum | PartyPalaceScalarFieldEnum[]
  }

  /**
   * Product.cateringtent
   */
  export type Product$cateringtentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    where?: CateringTentWhereInput
    orderBy?: CateringTentOrderByWithRelationInput | CateringTentOrderByWithRelationInput[]
    cursor?: CateringTentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CateringTentScalarFieldEnum | CateringTentScalarFieldEnum[]
  }

  /**
   * Product.product_image
   */
  export type Product$product_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * Product.event
   */
  export type Product$eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Product.ratings
   */
  export type Product$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    where?: ProductRatingWhereInput
    orderBy?: ProductRatingOrderByWithRelationInput | ProductRatingOrderByWithRelationInput[]
    cursor?: ProductRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductRatingScalarFieldEnum | ProductRatingScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    approved_by_id: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    approved_by_id: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    start_date: Date | null
    end_date: Date | null
    start_time: Date | null
    end_time: Date | null
    is_approved: boolean | null
    is_rejected: boolean | null
    userId: number | null
    productId: number | null
    approved_by_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    start_date: Date | null
    end_date: Date | null
    start_time: Date | null
    end_time: Date | null
    is_approved: boolean | null
    is_rejected: boolean | null
    userId: number | null
    productId: number | null
    approved_by_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    start_date: number
    end_date: number
    start_time: number
    end_time: number
    is_approved: number
    is_rejected: number
    userId: number
    productId: number
    approved_by_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    approved_by_id?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    approved_by_id?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    start_time?: true
    end_time?: true
    is_approved?: true
    is_rejected?: true
    userId?: true
    productId?: true
    approved_by_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    start_time?: true
    end_time?: true
    is_approved?: true
    is_rejected?: true
    userId?: true
    productId?: true
    approved_by_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    start_time?: true
    end_time?: true
    is_approved?: true
    is_rejected?: true
    userId?: true
    productId?: true
    approved_by_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    start_date: Date
    end_date: Date
    start_time: Date | null
    end_time: Date | null
    is_approved: boolean
    is_rejected: boolean
    userId: number
    productId: number
    approved_by_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    start_time?: boolean
    end_time?: boolean
    is_approved?: boolean
    is_rejected?: boolean
    userId?: boolean
    productId?: boolean
    approved_by_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    PartyPalace?: boolean | Event$PartyPalaceArgs<ExtArgs>
    CateringTent?: boolean | Event$CateringTentArgs<ExtArgs>
    Adventure?: boolean | Event$AdventureArgs<ExtArgs>
    BeautyDecor?: boolean | Event$BeautyDecorArgs<ExtArgs>
    Meeting?: boolean | Event$MeetingArgs<ExtArgs>
    Entertainment?: boolean | Event$EntertainmentArgs<ExtArgs>
    Luxury?: boolean | Event$LuxuryArgs<ExtArgs>
    Musical?: boolean | Event$MusicalArgs<ExtArgs>
    Multimedia?: boolean | Event$MultimediaArgs<ExtArgs>
    EventTypes?: boolean | Event$EventTypesArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>


  export type EventSelectScalar = {
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    start_time?: boolean
    end_time?: boolean
    is_approved?: boolean
    is_rejected?: boolean
    userId?: boolean
    productId?: boolean
    approved_by_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    PartyPalace?: boolean | Event$PartyPalaceArgs<ExtArgs>
    CateringTent?: boolean | Event$CateringTentArgs<ExtArgs>
    Adventure?: boolean | Event$AdventureArgs<ExtArgs>
    BeautyDecor?: boolean | Event$BeautyDecorArgs<ExtArgs>
    Meeting?: boolean | Event$MeetingArgs<ExtArgs>
    Entertainment?: boolean | Event$EntertainmentArgs<ExtArgs>
    Luxury?: boolean | Event$LuxuryArgs<ExtArgs>
    Musical?: boolean | Event$MusicalArgs<ExtArgs>
    Multimedia?: boolean | Event$MultimediaArgs<ExtArgs>
    EventTypes?: boolean | Event$EventTypesArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
      PartyPalace: Prisma.$PartyPalacePayload<ExtArgs>[]
      CateringTent: Prisma.$CateringTentPayload<ExtArgs>[]
      Adventure: Prisma.$AdventurePayload<ExtArgs>[]
      BeautyDecor: Prisma.$BeautyDecorPayload<ExtArgs>[]
      Meeting: Prisma.$MeetingPayload<ExtArgs>[]
      Entertainment: Prisma.$EntertainmentPayload<ExtArgs>[]
      Luxury: Prisma.$LuxuryPayload<ExtArgs>[]
      Musical: Prisma.$MusicalPayload<ExtArgs>[]
      Multimedia: Prisma.$MultimediaPayload<ExtArgs>[]
      EventTypes: Prisma.$EventEventTypePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      start_date: Date
      end_date: Date
      start_time: Date | null
      end_time: Date | null
      is_approved: boolean
      is_rejected: boolean
      userId: number
      productId: number
      approved_by_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PartyPalace<T extends Event$PartyPalaceArgs<ExtArgs> = {}>(args?: Subset<T, Event$PartyPalaceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findMany"> | Null>
    CateringTent<T extends Event$CateringTentArgs<ExtArgs> = {}>(args?: Subset<T, Event$CateringTentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findMany"> | Null>
    Adventure<T extends Event$AdventureArgs<ExtArgs> = {}>(args?: Subset<T, Event$AdventureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany"> | Null>
    BeautyDecor<T extends Event$BeautyDecorArgs<ExtArgs> = {}>(args?: Subset<T, Event$BeautyDecorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findMany"> | Null>
    Meeting<T extends Event$MeetingArgs<ExtArgs> = {}>(args?: Subset<T, Event$MeetingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    Entertainment<T extends Event$EntertainmentArgs<ExtArgs> = {}>(args?: Subset<T, Event$EntertainmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findMany"> | Null>
    Luxury<T extends Event$LuxuryArgs<ExtArgs> = {}>(args?: Subset<T, Event$LuxuryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findMany"> | Null>
    Musical<T extends Event$MusicalArgs<ExtArgs> = {}>(args?: Subset<T, Event$MusicalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findMany"> | Null>
    Multimedia<T extends Event$MultimediaArgs<ExtArgs> = {}>(args?: Subset<T, Event$MultimediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findMany"> | Null>
    EventTypes<T extends Event$EventTypesArgs<ExtArgs> = {}>(args?: Subset<T, Event$EventTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findMany"> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'Int'>
    readonly start_date: FieldRef<"Event", 'DateTime'>
    readonly end_date: FieldRef<"Event", 'DateTime'>
    readonly start_time: FieldRef<"Event", 'DateTime'>
    readonly end_time: FieldRef<"Event", 'DateTime'>
    readonly is_approved: FieldRef<"Event", 'Boolean'>
    readonly is_rejected: FieldRef<"Event", 'Boolean'>
    readonly userId: FieldRef<"Event", 'Int'>
    readonly productId: FieldRef<"Event", 'Int'>
    readonly approved_by_id: FieldRef<"Event", 'Int'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.PartyPalace
   */
  export type Event$PartyPalaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    where?: PartyPalaceWhereInput
    orderBy?: PartyPalaceOrderByWithRelationInput | PartyPalaceOrderByWithRelationInput[]
    cursor?: PartyPalaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartyPalaceScalarFieldEnum | PartyPalaceScalarFieldEnum[]
  }

  /**
   * Event.CateringTent
   */
  export type Event$CateringTentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    where?: CateringTentWhereInput
    orderBy?: CateringTentOrderByWithRelationInput | CateringTentOrderByWithRelationInput[]
    cursor?: CateringTentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CateringTentScalarFieldEnum | CateringTentScalarFieldEnum[]
  }

  /**
   * Event.Adventure
   */
  export type Event$AdventureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    cursor?: AdventureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Event.BeautyDecor
   */
  export type Event$BeautyDecorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    where?: BeautyDecorWhereInput
    orderBy?: BeautyDecorOrderByWithRelationInput | BeautyDecorOrderByWithRelationInput[]
    cursor?: BeautyDecorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeautyDecorScalarFieldEnum | BeautyDecorScalarFieldEnum[]
  }

  /**
   * Event.Meeting
   */
  export type Event$MeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Event.Entertainment
   */
  export type Event$EntertainmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    where?: EntertainmentWhereInput
    orderBy?: EntertainmentOrderByWithRelationInput | EntertainmentOrderByWithRelationInput[]
    cursor?: EntertainmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntertainmentScalarFieldEnum | EntertainmentScalarFieldEnum[]
  }

  /**
   * Event.Luxury
   */
  export type Event$LuxuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    where?: LuxuryWhereInput
    orderBy?: LuxuryOrderByWithRelationInput | LuxuryOrderByWithRelationInput[]
    cursor?: LuxuryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LuxuryScalarFieldEnum | LuxuryScalarFieldEnum[]
  }

  /**
   * Event.Musical
   */
  export type Event$MusicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    where?: MusicalWhereInput
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    cursor?: MusicalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Event.Multimedia
   */
  export type Event$MultimediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    where?: MultimediaWhereInput
    orderBy?: MultimediaOrderByWithRelationInput | MultimediaOrderByWithRelationInput[]
    cursor?: MultimediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultimediaScalarFieldEnum | MultimediaScalarFieldEnum[]
  }

  /**
   * Event.EventTypes
   */
  export type Event$EventTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    where?: EventEventTypeWhereInput
    orderBy?: EventEventTypeOrderByWithRelationInput | EventEventTypeOrderByWithRelationInput[]
    cursor?: EventEventTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventEventTypeScalarFieldEnum | EventEventTypeScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventType
   */

  export type AggregateEventType = {
    _count: EventTypeCountAggregateOutputType | null
    _avg: EventTypeAvgAggregateOutputType | null
    _sum: EventTypeSumAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  export type EventTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type EventTypeSumAggregateOutputType = {
    id: number | null
  }

  export type EventTypeMinAggregateOutputType = {
    id: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventTypeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventTypeCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventTypeAvgAggregateInputType = {
    id?: true
  }

  export type EventTypeSumAggregateInputType = {
    id?: true
  }

  export type EventTypeMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventTypeMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventTypeCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventType to aggregate.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTypes
    **/
    _count?: true | EventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTypeMaxAggregateInputType
  }

  export type GetEventTypeAggregateType<T extends EventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventType[P]>
      : GetScalarType<T[P], AggregateEventType[P]>
  }




  export type EventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTypeWhereInput
    orderBy?: EventTypeOrderByWithAggregationInput | EventTypeOrderByWithAggregationInput[]
    by: EventTypeScalarFieldEnum[] | EventTypeScalarFieldEnum
    having?: EventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTypeCountAggregateInputType | true
    _avg?: EventTypeAvgAggregateInputType
    _sum?: EventTypeSumAggregateInputType
    _min?: EventTypeMinAggregateInputType
    _max?: EventTypeMaxAggregateInputType
  }

  export type EventTypeGroupByOutputType = {
    id: number
    title: string
    createdAt: Date
    updatedAt: Date
    _count: EventTypeCountAggregateOutputType | null
    _avg: EventTypeAvgAggregateOutputType | null
    _sum: EventTypeSumAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  type GetEventTypeGroupByPayload<T extends EventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
        }
      >
    >


  export type EventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Events?: boolean | EventType$EventsArgs<ExtArgs>
    _count?: boolean | EventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventType"]>


  export type EventTypeSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Events?: boolean | EventType$EventsArgs<ExtArgs>
    _count?: boolean | EventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventType"
    objects: {
      Events: Prisma.$EventEventTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventType"]>
    composites: {}
  }

  type EventTypeGetPayload<S extends boolean | null | undefined | EventTypeDefaultArgs> = $Result.GetResult<Prisma.$EventTypePayload, S>

  type EventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventTypeCountAggregateInputType | true
    }

  export interface EventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventType'], meta: { name: 'EventType' } }
    /**
     * Find zero or one EventType that matches the filter.
     * @param {EventTypeFindUniqueArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTypeFindUniqueArgs>(args: SelectSubset<T, EventTypeFindUniqueArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventTypeFindUniqueOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTypeFindFirstArgs>(args?: SelectSubset<T, EventTypeFindFirstArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTypes
     * const eventTypes = await prisma.eventType.findMany()
     * 
     * // Get first 10 EventTypes
     * const eventTypes = await prisma.eventType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventTypeWithIdOnly = await prisma.eventType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventTypeFindManyArgs>(args?: SelectSubset<T, EventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventType.
     * @param {EventTypeCreateArgs} args - Arguments to create a EventType.
     * @example
     * // Create one EventType
     * const EventType = await prisma.eventType.create({
     *   data: {
     *     // ... data to create a EventType
     *   }
     * })
     * 
     */
    create<T extends EventTypeCreateArgs>(args: SelectSubset<T, EventTypeCreateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventTypes.
     * @param {EventTypeCreateManyArgs} args - Arguments to create many EventTypes.
     * @example
     * // Create many EventTypes
     * const eventType = await prisma.eventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTypeCreateManyArgs>(args?: SelectSubset<T, EventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventType.
     * @param {EventTypeDeleteArgs} args - Arguments to delete one EventType.
     * @example
     * // Delete one EventType
     * const EventType = await prisma.eventType.delete({
     *   where: {
     *     // ... filter to delete one EventType
     *   }
     * })
     * 
     */
    delete<T extends EventTypeDeleteArgs>(args: SelectSubset<T, EventTypeDeleteArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventType.
     * @param {EventTypeUpdateArgs} args - Arguments to update one EventType.
     * @example
     * // Update one EventType
     * const eventType = await prisma.eventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTypeUpdateArgs>(args: SelectSubset<T, EventTypeUpdateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventTypes.
     * @param {EventTypeDeleteManyArgs} args - Arguments to filter EventTypes to delete.
     * @example
     * // Delete a few EventTypes
     * const { count } = await prisma.eventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTypeDeleteManyArgs>(args?: SelectSubset<T, EventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTypes
     * const eventType = await prisma.eventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTypeUpdateManyArgs>(args: SelectSubset<T, EventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventType.
     * @param {EventTypeUpsertArgs} args - Arguments to update or create a EventType.
     * @example
     * // Update or create a EventType
     * const eventType = await prisma.eventType.upsert({
     *   create: {
     *     // ... data to create a EventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventType we want to update
     *   }
     * })
     */
    upsert<T extends EventTypeUpsertArgs>(args: SelectSubset<T, EventTypeUpsertArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeCountArgs} args - Arguments to filter EventTypes to count.
     * @example
     * // Count the number of EventTypes
     * const count = await prisma.eventType.count({
     *   where: {
     *     // ... the filter for the EventTypes we want to count
     *   }
     * })
    **/
    count<T extends EventTypeCountArgs>(
      args?: Subset<T, EventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTypeAggregateArgs>(args: Subset<T, EventTypeAggregateArgs>): Prisma.PrismaPromise<GetEventTypeAggregateType<T>>

    /**
     * Group by EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTypeGroupByArgs['orderBy'] }
        : { orderBy?: EventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventType model
   */
  readonly fields: EventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Events<T extends EventType$EventsArgs<ExtArgs> = {}>(args?: Subset<T, EventType$EventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventType model
   */ 
  interface EventTypeFieldRefs {
    readonly id: FieldRef<"EventType", 'Int'>
    readonly title: FieldRef<"EventType", 'String'>
    readonly createdAt: FieldRef<"EventType", 'DateTime'>
    readonly updatedAt: FieldRef<"EventType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventType findUnique
   */
  export type EventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findUniqueOrThrow
   */
  export type EventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findFirst
   */
  export type EventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findFirstOrThrow
   */
  export type EventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findMany
   */
  export type EventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventTypes to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType create
   */
  export type EventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventType.
     */
    data: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
  }

  /**
   * EventType createMany
   */
  export type EventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTypes.
     */
    data: EventTypeCreateManyInput | EventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventType update
   */
  export type EventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventType.
     */
    data: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
    /**
     * Choose, which EventType to update.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType updateMany
   */
  export type EventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTypes.
     */
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventTypes to update
     */
    where?: EventTypeWhereInput
  }

  /**
   * EventType upsert
   */
  export type EventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventType to update in case it exists.
     */
    where: EventTypeWhereUniqueInput
    /**
     * In case the EventType found by the `where` argument doesn't exist, create a new EventType with this data.
     */
    create: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
    /**
     * In case the EventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
  }

  /**
   * EventType delete
   */
  export type EventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter which EventType to delete.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType deleteMany
   */
  export type EventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTypes to delete
     */
    where?: EventTypeWhereInput
  }

  /**
   * EventType.Events
   */
  export type EventType$EventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    where?: EventEventTypeWhereInput
    orderBy?: EventEventTypeOrderByWithRelationInput | EventEventTypeOrderByWithRelationInput[]
    cursor?: EventEventTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventEventTypeScalarFieldEnum | EventEventTypeScalarFieldEnum[]
  }

  /**
   * EventType without action
   */
  export type EventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
  }


  /**
   * Model EventEventType
   */

  export type AggregateEventEventType = {
    _count: EventEventTypeCountAggregateOutputType | null
    _avg: EventEventTypeAvgAggregateOutputType | null
    _sum: EventEventTypeSumAggregateOutputType | null
    _min: EventEventTypeMinAggregateOutputType | null
    _max: EventEventTypeMaxAggregateOutputType | null
  }

  export type EventEventTypeAvgAggregateOutputType = {
    eventId: number | null
    eventTypeId: number | null
  }

  export type EventEventTypeSumAggregateOutputType = {
    eventId: number | null
    eventTypeId: number | null
  }

  export type EventEventTypeMinAggregateOutputType = {
    eventId: number | null
    eventTypeId: number | null
  }

  export type EventEventTypeMaxAggregateOutputType = {
    eventId: number | null
    eventTypeId: number | null
  }

  export type EventEventTypeCountAggregateOutputType = {
    eventId: number
    eventTypeId: number
    _all: number
  }


  export type EventEventTypeAvgAggregateInputType = {
    eventId?: true
    eventTypeId?: true
  }

  export type EventEventTypeSumAggregateInputType = {
    eventId?: true
    eventTypeId?: true
  }

  export type EventEventTypeMinAggregateInputType = {
    eventId?: true
    eventTypeId?: true
  }

  export type EventEventTypeMaxAggregateInputType = {
    eventId?: true
    eventTypeId?: true
  }

  export type EventEventTypeCountAggregateInputType = {
    eventId?: true
    eventTypeId?: true
    _all?: true
  }

  export type EventEventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventEventType to aggregate.
     */
    where?: EventEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventEventTypes to fetch.
     */
    orderBy?: EventEventTypeOrderByWithRelationInput | EventEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventEventTypes
    **/
    _count?: true | EventEventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventEventTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventEventTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventEventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventEventTypeMaxAggregateInputType
  }

  export type GetEventEventTypeAggregateType<T extends EventEventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventEventType[P]>
      : GetScalarType<T[P], AggregateEventEventType[P]>
  }




  export type EventEventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventEventTypeWhereInput
    orderBy?: EventEventTypeOrderByWithAggregationInput | EventEventTypeOrderByWithAggregationInput[]
    by: EventEventTypeScalarFieldEnum[] | EventEventTypeScalarFieldEnum
    having?: EventEventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventEventTypeCountAggregateInputType | true
    _avg?: EventEventTypeAvgAggregateInputType
    _sum?: EventEventTypeSumAggregateInputType
    _min?: EventEventTypeMinAggregateInputType
    _max?: EventEventTypeMaxAggregateInputType
  }

  export type EventEventTypeGroupByOutputType = {
    eventId: number
    eventTypeId: number
    _count: EventEventTypeCountAggregateOutputType | null
    _avg: EventEventTypeAvgAggregateOutputType | null
    _sum: EventEventTypeSumAggregateOutputType | null
    _min: EventEventTypeMinAggregateOutputType | null
    _max: EventEventTypeMaxAggregateOutputType | null
  }

  type GetEventEventTypeGroupByPayload<T extends EventEventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventEventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventEventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventEventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EventEventTypeGroupByOutputType[P]>
        }
      >
    >


  export type EventEventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    eventTypeId?: boolean
    Event?: boolean | EventDefaultArgs<ExtArgs>
    EventType?: boolean | EventTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventEventType"]>


  export type EventEventTypeSelectScalar = {
    eventId?: boolean
    eventTypeId?: boolean
  }

  export type EventEventTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Event?: boolean | EventDefaultArgs<ExtArgs>
    EventType?: boolean | EventTypeDefaultArgs<ExtArgs>
  }

  export type $EventEventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventEventType"
    objects: {
      Event: Prisma.$EventPayload<ExtArgs>
      EventType: Prisma.$EventTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      eventId: number
      eventTypeId: number
    }, ExtArgs["result"]["eventEventType"]>
    composites: {}
  }

  type EventEventTypeGetPayload<S extends boolean | null | undefined | EventEventTypeDefaultArgs> = $Result.GetResult<Prisma.$EventEventTypePayload, S>

  type EventEventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventEventTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventEventTypeCountAggregateInputType | true
    }

  export interface EventEventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventEventType'], meta: { name: 'EventEventType' } }
    /**
     * Find zero or one EventEventType that matches the filter.
     * @param {EventEventTypeFindUniqueArgs} args - Arguments to find a EventEventType
     * @example
     * // Get one EventEventType
     * const eventEventType = await prisma.eventEventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventEventTypeFindUniqueArgs>(args: SelectSubset<T, EventEventTypeFindUniqueArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventEventType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventEventTypeFindUniqueOrThrowArgs} args - Arguments to find a EventEventType
     * @example
     * // Get one EventEventType
     * const eventEventType = await prisma.eventEventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventEventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventEventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventEventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeFindFirstArgs} args - Arguments to find a EventEventType
     * @example
     * // Get one EventEventType
     * const eventEventType = await prisma.eventEventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventEventTypeFindFirstArgs>(args?: SelectSubset<T, EventEventTypeFindFirstArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventEventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeFindFirstOrThrowArgs} args - Arguments to find a EventEventType
     * @example
     * // Get one EventEventType
     * const eventEventType = await prisma.eventEventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventEventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventEventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventEventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventEventTypes
     * const eventEventTypes = await prisma.eventEventType.findMany()
     * 
     * // Get first 10 EventEventTypes
     * const eventEventTypes = await prisma.eventEventType.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const eventEventTypeWithEventIdOnly = await prisma.eventEventType.findMany({ select: { eventId: true } })
     * 
     */
    findMany<T extends EventEventTypeFindManyArgs>(args?: SelectSubset<T, EventEventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventEventType.
     * @param {EventEventTypeCreateArgs} args - Arguments to create a EventEventType.
     * @example
     * // Create one EventEventType
     * const EventEventType = await prisma.eventEventType.create({
     *   data: {
     *     // ... data to create a EventEventType
     *   }
     * })
     * 
     */
    create<T extends EventEventTypeCreateArgs>(args: SelectSubset<T, EventEventTypeCreateArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventEventTypes.
     * @param {EventEventTypeCreateManyArgs} args - Arguments to create many EventEventTypes.
     * @example
     * // Create many EventEventTypes
     * const eventEventType = await prisma.eventEventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventEventTypeCreateManyArgs>(args?: SelectSubset<T, EventEventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventEventType.
     * @param {EventEventTypeDeleteArgs} args - Arguments to delete one EventEventType.
     * @example
     * // Delete one EventEventType
     * const EventEventType = await prisma.eventEventType.delete({
     *   where: {
     *     // ... filter to delete one EventEventType
     *   }
     * })
     * 
     */
    delete<T extends EventEventTypeDeleteArgs>(args: SelectSubset<T, EventEventTypeDeleteArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventEventType.
     * @param {EventEventTypeUpdateArgs} args - Arguments to update one EventEventType.
     * @example
     * // Update one EventEventType
     * const eventEventType = await prisma.eventEventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventEventTypeUpdateArgs>(args: SelectSubset<T, EventEventTypeUpdateArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventEventTypes.
     * @param {EventEventTypeDeleteManyArgs} args - Arguments to filter EventEventTypes to delete.
     * @example
     * // Delete a few EventEventTypes
     * const { count } = await prisma.eventEventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventEventTypeDeleteManyArgs>(args?: SelectSubset<T, EventEventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventEventTypes
     * const eventEventType = await prisma.eventEventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventEventTypeUpdateManyArgs>(args: SelectSubset<T, EventEventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventEventType.
     * @param {EventEventTypeUpsertArgs} args - Arguments to update or create a EventEventType.
     * @example
     * // Update or create a EventEventType
     * const eventEventType = await prisma.eventEventType.upsert({
     *   create: {
     *     // ... data to create a EventEventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventEventType we want to update
     *   }
     * })
     */
    upsert<T extends EventEventTypeUpsertArgs>(args: SelectSubset<T, EventEventTypeUpsertArgs<ExtArgs>>): Prisma__EventEventTypeClient<$Result.GetResult<Prisma.$EventEventTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeCountArgs} args - Arguments to filter EventEventTypes to count.
     * @example
     * // Count the number of EventEventTypes
     * const count = await prisma.eventEventType.count({
     *   where: {
     *     // ... the filter for the EventEventTypes we want to count
     *   }
     * })
    **/
    count<T extends EventEventTypeCountArgs>(
      args?: Subset<T, EventEventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventEventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventEventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventEventTypeAggregateArgs>(args: Subset<T, EventEventTypeAggregateArgs>): Prisma.PrismaPromise<GetEventEventTypeAggregateType<T>>

    /**
     * Group by EventEventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventEventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventEventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventEventTypeGroupByArgs['orderBy'] }
        : { orderBy?: EventEventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventEventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventEventType model
   */
  readonly fields: EventEventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventEventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventEventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    EventType<T extends EventTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventTypeDefaultArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventEventType model
   */ 
  interface EventEventTypeFieldRefs {
    readonly eventId: FieldRef<"EventEventType", 'Int'>
    readonly eventTypeId: FieldRef<"EventEventType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EventEventType findUnique
   */
  export type EventEventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventEventType to fetch.
     */
    where: EventEventTypeWhereUniqueInput
  }

  /**
   * EventEventType findUniqueOrThrow
   */
  export type EventEventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventEventType to fetch.
     */
    where: EventEventTypeWhereUniqueInput
  }

  /**
   * EventEventType findFirst
   */
  export type EventEventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventEventType to fetch.
     */
    where?: EventEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventEventTypes to fetch.
     */
    orderBy?: EventEventTypeOrderByWithRelationInput | EventEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventEventTypes.
     */
    cursor?: EventEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventEventTypes.
     */
    distinct?: EventEventTypeScalarFieldEnum | EventEventTypeScalarFieldEnum[]
  }

  /**
   * EventEventType findFirstOrThrow
   */
  export type EventEventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventEventType to fetch.
     */
    where?: EventEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventEventTypes to fetch.
     */
    orderBy?: EventEventTypeOrderByWithRelationInput | EventEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventEventTypes.
     */
    cursor?: EventEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventEventTypes.
     */
    distinct?: EventEventTypeScalarFieldEnum | EventEventTypeScalarFieldEnum[]
  }

  /**
   * EventEventType findMany
   */
  export type EventEventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventEventTypes to fetch.
     */
    where?: EventEventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventEventTypes to fetch.
     */
    orderBy?: EventEventTypeOrderByWithRelationInput | EventEventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventEventTypes.
     */
    cursor?: EventEventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventEventTypes.
     */
    skip?: number
    distinct?: EventEventTypeScalarFieldEnum | EventEventTypeScalarFieldEnum[]
  }

  /**
   * EventEventType create
   */
  export type EventEventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventEventType.
     */
    data: XOR<EventEventTypeCreateInput, EventEventTypeUncheckedCreateInput>
  }

  /**
   * EventEventType createMany
   */
  export type EventEventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventEventTypes.
     */
    data: EventEventTypeCreateManyInput | EventEventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventEventType update
   */
  export type EventEventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventEventType.
     */
    data: XOR<EventEventTypeUpdateInput, EventEventTypeUncheckedUpdateInput>
    /**
     * Choose, which EventEventType to update.
     */
    where: EventEventTypeWhereUniqueInput
  }

  /**
   * EventEventType updateMany
   */
  export type EventEventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventEventTypes.
     */
    data: XOR<EventEventTypeUpdateManyMutationInput, EventEventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventEventTypes to update
     */
    where?: EventEventTypeWhereInput
  }

  /**
   * EventEventType upsert
   */
  export type EventEventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventEventType to update in case it exists.
     */
    where: EventEventTypeWhereUniqueInput
    /**
     * In case the EventEventType found by the `where` argument doesn't exist, create a new EventEventType with this data.
     */
    create: XOR<EventEventTypeCreateInput, EventEventTypeUncheckedCreateInput>
    /**
     * In case the EventEventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventEventTypeUpdateInput, EventEventTypeUncheckedUpdateInput>
  }

  /**
   * EventEventType delete
   */
  export type EventEventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
    /**
     * Filter which EventEventType to delete.
     */
    where: EventEventTypeWhereUniqueInput
  }

  /**
   * EventEventType deleteMany
   */
  export type EventEventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventEventTypes to delete
     */
    where?: EventEventTypeWhereInput
  }

  /**
   * EventEventType without action
   */
  export type EventEventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventEventType
     */
    select?: EventEventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventEventTypeInclude<ExtArgs> | null
  }


  /**
   * Model Multimedia
   */

  export type AggregateMultimedia = {
    _count: MultimediaCountAggregateOutputType | null
    _avg: MultimediaAvgAggregateOutputType | null
    _sum: MultimediaSumAggregateOutputType | null
    _min: MultimediaMinAggregateOutputType | null
    _max: MultimediaMaxAggregateOutputType | null
  }

  export type MultimediaAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type MultimediaSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type MultimediaMinAggregateOutputType = {
    id: number | null
    multimedia_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type MultimediaMaxAggregateOutputType = {
    id: number | null
    multimedia_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type MultimediaCountAggregateOutputType = {
    id: number
    multimedia_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type MultimediaAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type MultimediaSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type MultimediaMinAggregateInputType = {
    id?: true
    multimedia_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type MultimediaMaxAggregateInputType = {
    id?: true
    multimedia_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type MultimediaCountAggregateInputType = {
    id?: true
    multimedia_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type MultimediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Multimedia to aggregate.
     */
    where?: MultimediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Multimedias to fetch.
     */
    orderBy?: MultimediaOrderByWithRelationInput | MultimediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultimediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Multimedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Multimedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Multimedias
    **/
    _count?: true | MultimediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultimediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultimediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultimediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultimediaMaxAggregateInputType
  }

  export type GetMultimediaAggregateType<T extends MultimediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMultimedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultimedia[P]>
      : GetScalarType<T[P], AggregateMultimedia[P]>
  }




  export type MultimediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultimediaWhereInput
    orderBy?: MultimediaOrderByWithAggregationInput | MultimediaOrderByWithAggregationInput[]
    by: MultimediaScalarFieldEnum[] | MultimediaScalarFieldEnum
    having?: MultimediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultimediaCountAggregateInputType | true
    _avg?: MultimediaAvgAggregateInputType
    _sum?: MultimediaSumAggregateInputType
    _min?: MultimediaMinAggregateInputType
    _max?: MultimediaMaxAggregateInputType
  }

  export type MultimediaGroupByOutputType = {
    id: number
    multimedia_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: MultimediaCountAggregateOutputType | null
    _avg: MultimediaAvgAggregateOutputType | null
    _sum: MultimediaSumAggregateOutputType | null
    _min: MultimediaMinAggregateOutputType | null
    _max: MultimediaMaxAggregateOutputType | null
  }

  type GetMultimediaGroupByPayload<T extends MultimediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultimediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultimediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultimediaGroupByOutputType[P]>
            : GetScalarType<T[P], MultimediaGroupByOutputType[P]>
        }
      >
    >


  export type MultimediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multimedia_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | Multimedia$ProductArgs<ExtArgs>
    events?: boolean | Multimedia$eventsArgs<ExtArgs>
    _count?: boolean | MultimediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multimedia"]>


  export type MultimediaSelectScalar = {
    id?: boolean
    multimedia_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type MultimediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Multimedia$ProductArgs<ExtArgs>
    events?: boolean | Multimedia$eventsArgs<ExtArgs>
    _count?: boolean | MultimediaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MultimediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Multimedia"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      multimedia_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["multimedia"]>
    composites: {}
  }

  type MultimediaGetPayload<S extends boolean | null | undefined | MultimediaDefaultArgs> = $Result.GetResult<Prisma.$MultimediaPayload, S>

  type MultimediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MultimediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MultimediaCountAggregateInputType | true
    }

  export interface MultimediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Multimedia'], meta: { name: 'Multimedia' } }
    /**
     * Find zero or one Multimedia that matches the filter.
     * @param {MultimediaFindUniqueArgs} args - Arguments to find a Multimedia
     * @example
     * // Get one Multimedia
     * const multimedia = await prisma.multimedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultimediaFindUniqueArgs>(args: SelectSubset<T, MultimediaFindUniqueArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Multimedia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MultimediaFindUniqueOrThrowArgs} args - Arguments to find a Multimedia
     * @example
     * // Get one Multimedia
     * const multimedia = await prisma.multimedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultimediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MultimediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Multimedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaFindFirstArgs} args - Arguments to find a Multimedia
     * @example
     * // Get one Multimedia
     * const multimedia = await prisma.multimedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultimediaFindFirstArgs>(args?: SelectSubset<T, MultimediaFindFirstArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Multimedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaFindFirstOrThrowArgs} args - Arguments to find a Multimedia
     * @example
     * // Get one Multimedia
     * const multimedia = await prisma.multimedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultimediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MultimediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Multimedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Multimedias
     * const multimedias = await prisma.multimedia.findMany()
     * 
     * // Get first 10 Multimedias
     * const multimedias = await prisma.multimedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multimediaWithIdOnly = await prisma.multimedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultimediaFindManyArgs>(args?: SelectSubset<T, MultimediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Multimedia.
     * @param {MultimediaCreateArgs} args - Arguments to create a Multimedia.
     * @example
     * // Create one Multimedia
     * const Multimedia = await prisma.multimedia.create({
     *   data: {
     *     // ... data to create a Multimedia
     *   }
     * })
     * 
     */
    create<T extends MultimediaCreateArgs>(args: SelectSubset<T, MultimediaCreateArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Multimedias.
     * @param {MultimediaCreateManyArgs} args - Arguments to create many Multimedias.
     * @example
     * // Create many Multimedias
     * const multimedia = await prisma.multimedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultimediaCreateManyArgs>(args?: SelectSubset<T, MultimediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Multimedia.
     * @param {MultimediaDeleteArgs} args - Arguments to delete one Multimedia.
     * @example
     * // Delete one Multimedia
     * const Multimedia = await prisma.multimedia.delete({
     *   where: {
     *     // ... filter to delete one Multimedia
     *   }
     * })
     * 
     */
    delete<T extends MultimediaDeleteArgs>(args: SelectSubset<T, MultimediaDeleteArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Multimedia.
     * @param {MultimediaUpdateArgs} args - Arguments to update one Multimedia.
     * @example
     * // Update one Multimedia
     * const multimedia = await prisma.multimedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultimediaUpdateArgs>(args: SelectSubset<T, MultimediaUpdateArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Multimedias.
     * @param {MultimediaDeleteManyArgs} args - Arguments to filter Multimedias to delete.
     * @example
     * // Delete a few Multimedias
     * const { count } = await prisma.multimedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultimediaDeleteManyArgs>(args?: SelectSubset<T, MultimediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Multimedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Multimedias
     * const multimedia = await prisma.multimedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultimediaUpdateManyArgs>(args: SelectSubset<T, MultimediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Multimedia.
     * @param {MultimediaUpsertArgs} args - Arguments to update or create a Multimedia.
     * @example
     * // Update or create a Multimedia
     * const multimedia = await prisma.multimedia.upsert({
     *   create: {
     *     // ... data to create a Multimedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Multimedia we want to update
     *   }
     * })
     */
    upsert<T extends MultimediaUpsertArgs>(args: SelectSubset<T, MultimediaUpsertArgs<ExtArgs>>): Prisma__MultimediaClient<$Result.GetResult<Prisma.$MultimediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Multimedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaCountArgs} args - Arguments to filter Multimedias to count.
     * @example
     * // Count the number of Multimedias
     * const count = await prisma.multimedia.count({
     *   where: {
     *     // ... the filter for the Multimedias we want to count
     *   }
     * })
    **/
    count<T extends MultimediaCountArgs>(
      args?: Subset<T, MultimediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultimediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Multimedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultimediaAggregateArgs>(args: Subset<T, MultimediaAggregateArgs>): Prisma.PrismaPromise<GetMultimediaAggregateType<T>>

    /**
     * Group by Multimedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultimediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultimediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultimediaGroupByArgs['orderBy'] }
        : { orderBy?: MultimediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultimediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultimediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Multimedia model
   */
  readonly fields: MultimediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Multimedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultimediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Multimedia$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Multimedia$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Multimedia$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Multimedia$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Multimedia model
   */ 
  interface MultimediaFieldRefs {
    readonly id: FieldRef<"Multimedia", 'Int'>
    readonly multimedia_name: FieldRef<"Multimedia", 'String'>
    readonly price: FieldRef<"Multimedia", 'Int'>
    readonly offerPrice: FieldRef<"Multimedia", 'Int'>
    readonly description: FieldRef<"Multimedia", 'String'>
    readonly createdAt: FieldRef<"Multimedia", 'DateTime'>
    readonly updatedAt: FieldRef<"Multimedia", 'DateTime'>
    readonly productId: FieldRef<"Multimedia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Multimedia findUnique
   */
  export type MultimediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * Filter, which Multimedia to fetch.
     */
    where: MultimediaWhereUniqueInput
  }

  /**
   * Multimedia findUniqueOrThrow
   */
  export type MultimediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * Filter, which Multimedia to fetch.
     */
    where: MultimediaWhereUniqueInput
  }

  /**
   * Multimedia findFirst
   */
  export type MultimediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * Filter, which Multimedia to fetch.
     */
    where?: MultimediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Multimedias to fetch.
     */
    orderBy?: MultimediaOrderByWithRelationInput | MultimediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Multimedias.
     */
    cursor?: MultimediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Multimedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Multimedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Multimedias.
     */
    distinct?: MultimediaScalarFieldEnum | MultimediaScalarFieldEnum[]
  }

  /**
   * Multimedia findFirstOrThrow
   */
  export type MultimediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * Filter, which Multimedia to fetch.
     */
    where?: MultimediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Multimedias to fetch.
     */
    orderBy?: MultimediaOrderByWithRelationInput | MultimediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Multimedias.
     */
    cursor?: MultimediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Multimedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Multimedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Multimedias.
     */
    distinct?: MultimediaScalarFieldEnum | MultimediaScalarFieldEnum[]
  }

  /**
   * Multimedia findMany
   */
  export type MultimediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * Filter, which Multimedias to fetch.
     */
    where?: MultimediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Multimedias to fetch.
     */
    orderBy?: MultimediaOrderByWithRelationInput | MultimediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Multimedias.
     */
    cursor?: MultimediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Multimedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Multimedias.
     */
    skip?: number
    distinct?: MultimediaScalarFieldEnum | MultimediaScalarFieldEnum[]
  }

  /**
   * Multimedia create
   */
  export type MultimediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Multimedia.
     */
    data: XOR<MultimediaCreateInput, MultimediaUncheckedCreateInput>
  }

  /**
   * Multimedia createMany
   */
  export type MultimediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Multimedias.
     */
    data: MultimediaCreateManyInput | MultimediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Multimedia update
   */
  export type MultimediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Multimedia.
     */
    data: XOR<MultimediaUpdateInput, MultimediaUncheckedUpdateInput>
    /**
     * Choose, which Multimedia to update.
     */
    where: MultimediaWhereUniqueInput
  }

  /**
   * Multimedia updateMany
   */
  export type MultimediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Multimedias.
     */
    data: XOR<MultimediaUpdateManyMutationInput, MultimediaUncheckedUpdateManyInput>
    /**
     * Filter which Multimedias to update
     */
    where?: MultimediaWhereInput
  }

  /**
   * Multimedia upsert
   */
  export type MultimediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Multimedia to update in case it exists.
     */
    where: MultimediaWhereUniqueInput
    /**
     * In case the Multimedia found by the `where` argument doesn't exist, create a new Multimedia with this data.
     */
    create: XOR<MultimediaCreateInput, MultimediaUncheckedCreateInput>
    /**
     * In case the Multimedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultimediaUpdateInput, MultimediaUncheckedUpdateInput>
  }

  /**
   * Multimedia delete
   */
  export type MultimediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
    /**
     * Filter which Multimedia to delete.
     */
    where: MultimediaWhereUniqueInput
  }

  /**
   * Multimedia deleteMany
   */
  export type MultimediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Multimedias to delete
     */
    where?: MultimediaWhereInput
  }

  /**
   * Multimedia.Product
   */
  export type Multimedia$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Multimedia.events
   */
  export type Multimedia$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Multimedia without action
   */
  export type MultimediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Multimedia
     */
    select?: MultimediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultimediaInclude<ExtArgs> | null
  }


  /**
   * Model Musical
   */

  export type AggregateMusical = {
    _count: MusicalCountAggregateOutputType | null
    _avg: MusicalAvgAggregateOutputType | null
    _sum: MusicalSumAggregateOutputType | null
    _min: MusicalMinAggregateOutputType | null
    _max: MusicalMaxAggregateOutputType | null
  }

  export type MusicalAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type MusicalSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type MusicalMinAggregateOutputType = {
    id: number | null
    instrument_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type MusicalMaxAggregateOutputType = {
    id: number | null
    instrument_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type MusicalCountAggregateOutputType = {
    id: number
    instrument_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type MusicalAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type MusicalSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type MusicalMinAggregateInputType = {
    id?: true
    instrument_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type MusicalMaxAggregateInputType = {
    id?: true
    instrument_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type MusicalCountAggregateInputType = {
    id?: true
    instrument_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type MusicalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Musical to aggregate.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Musicals
    **/
    _count?: true | MusicalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MusicalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MusicalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MusicalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MusicalMaxAggregateInputType
  }

  export type GetMusicalAggregateType<T extends MusicalAggregateArgs> = {
        [P in keyof T & keyof AggregateMusical]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMusical[P]>
      : GetScalarType<T[P], AggregateMusical[P]>
  }




  export type MusicalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MusicalWhereInput
    orderBy?: MusicalOrderByWithAggregationInput | MusicalOrderByWithAggregationInput[]
    by: MusicalScalarFieldEnum[] | MusicalScalarFieldEnum
    having?: MusicalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MusicalCountAggregateInputType | true
    _avg?: MusicalAvgAggregateInputType
    _sum?: MusicalSumAggregateInputType
    _min?: MusicalMinAggregateInputType
    _max?: MusicalMaxAggregateInputType
  }

  export type MusicalGroupByOutputType = {
    id: number
    instrument_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: MusicalCountAggregateOutputType | null
    _avg: MusicalAvgAggregateOutputType | null
    _sum: MusicalSumAggregateOutputType | null
    _min: MusicalMinAggregateOutputType | null
    _max: MusicalMaxAggregateOutputType | null
  }

  type GetMusicalGroupByPayload<T extends MusicalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MusicalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MusicalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MusicalGroupByOutputType[P]>
            : GetScalarType<T[P], MusicalGroupByOutputType[P]>
        }
      >
    >


  export type MusicalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instrument_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | Musical$ProductArgs<ExtArgs>
    events?: boolean | Musical$eventsArgs<ExtArgs>
    _count?: boolean | MusicalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["musical"]>


  export type MusicalSelectScalar = {
    id?: boolean
    instrument_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type MusicalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Musical$ProductArgs<ExtArgs>
    events?: boolean | Musical$eventsArgs<ExtArgs>
    _count?: boolean | MusicalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MusicalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Musical"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instrument_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["musical"]>
    composites: {}
  }

  type MusicalGetPayload<S extends boolean | null | undefined | MusicalDefaultArgs> = $Result.GetResult<Prisma.$MusicalPayload, S>

  type MusicalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MusicalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MusicalCountAggregateInputType | true
    }

  export interface MusicalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Musical'], meta: { name: 'Musical' } }
    /**
     * Find zero or one Musical that matches the filter.
     * @param {MusicalFindUniqueArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MusicalFindUniqueArgs>(args: SelectSubset<T, MusicalFindUniqueArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Musical that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MusicalFindUniqueOrThrowArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MusicalFindUniqueOrThrowArgs>(args: SelectSubset<T, MusicalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Musical that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalFindFirstArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MusicalFindFirstArgs>(args?: SelectSubset<T, MusicalFindFirstArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Musical that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalFindFirstOrThrowArgs} args - Arguments to find a Musical
     * @example
     * // Get one Musical
     * const musical = await prisma.musical.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MusicalFindFirstOrThrowArgs>(args?: SelectSubset<T, MusicalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Musicals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Musicals
     * const musicals = await prisma.musical.findMany()
     * 
     * // Get first 10 Musicals
     * const musicals = await prisma.musical.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const musicalWithIdOnly = await prisma.musical.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MusicalFindManyArgs>(args?: SelectSubset<T, MusicalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Musical.
     * @param {MusicalCreateArgs} args - Arguments to create a Musical.
     * @example
     * // Create one Musical
     * const Musical = await prisma.musical.create({
     *   data: {
     *     // ... data to create a Musical
     *   }
     * })
     * 
     */
    create<T extends MusicalCreateArgs>(args: SelectSubset<T, MusicalCreateArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Musicals.
     * @param {MusicalCreateManyArgs} args - Arguments to create many Musicals.
     * @example
     * // Create many Musicals
     * const musical = await prisma.musical.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MusicalCreateManyArgs>(args?: SelectSubset<T, MusicalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Musical.
     * @param {MusicalDeleteArgs} args - Arguments to delete one Musical.
     * @example
     * // Delete one Musical
     * const Musical = await prisma.musical.delete({
     *   where: {
     *     // ... filter to delete one Musical
     *   }
     * })
     * 
     */
    delete<T extends MusicalDeleteArgs>(args: SelectSubset<T, MusicalDeleteArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Musical.
     * @param {MusicalUpdateArgs} args - Arguments to update one Musical.
     * @example
     * // Update one Musical
     * const musical = await prisma.musical.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MusicalUpdateArgs>(args: SelectSubset<T, MusicalUpdateArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Musicals.
     * @param {MusicalDeleteManyArgs} args - Arguments to filter Musicals to delete.
     * @example
     * // Delete a few Musicals
     * const { count } = await prisma.musical.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MusicalDeleteManyArgs>(args?: SelectSubset<T, MusicalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Musicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Musicals
     * const musical = await prisma.musical.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MusicalUpdateManyArgs>(args: SelectSubset<T, MusicalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Musical.
     * @param {MusicalUpsertArgs} args - Arguments to update or create a Musical.
     * @example
     * // Update or create a Musical
     * const musical = await prisma.musical.upsert({
     *   create: {
     *     // ... data to create a Musical
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Musical we want to update
     *   }
     * })
     */
    upsert<T extends MusicalUpsertArgs>(args: SelectSubset<T, MusicalUpsertArgs<ExtArgs>>): Prisma__MusicalClient<$Result.GetResult<Prisma.$MusicalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Musicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalCountArgs} args - Arguments to filter Musicals to count.
     * @example
     * // Count the number of Musicals
     * const count = await prisma.musical.count({
     *   where: {
     *     // ... the filter for the Musicals we want to count
     *   }
     * })
    **/
    count<T extends MusicalCountArgs>(
      args?: Subset<T, MusicalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MusicalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Musical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MusicalAggregateArgs>(args: Subset<T, MusicalAggregateArgs>): Prisma.PrismaPromise<GetMusicalAggregateType<T>>

    /**
     * Group by Musical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MusicalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MusicalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MusicalGroupByArgs['orderBy'] }
        : { orderBy?: MusicalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MusicalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMusicalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Musical model
   */
  readonly fields: MusicalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Musical.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MusicalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Musical$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Musical$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Musical$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Musical$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Musical model
   */ 
  interface MusicalFieldRefs {
    readonly id: FieldRef<"Musical", 'Int'>
    readonly instrument_name: FieldRef<"Musical", 'String'>
    readonly price: FieldRef<"Musical", 'Int'>
    readonly offerPrice: FieldRef<"Musical", 'Int'>
    readonly description: FieldRef<"Musical", 'String'>
    readonly createdAt: FieldRef<"Musical", 'DateTime'>
    readonly updatedAt: FieldRef<"Musical", 'DateTime'>
    readonly productId: FieldRef<"Musical", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Musical findUnique
   */
  export type MusicalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical findUniqueOrThrow
   */
  export type MusicalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical findFirst
   */
  export type MusicalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Musicals.
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Musicals.
     */
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Musical findFirstOrThrow
   */
  export type MusicalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musical to fetch.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Musicals.
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Musicals.
     */
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Musical findMany
   */
  export type MusicalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter, which Musicals to fetch.
     */
    where?: MusicalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Musicals to fetch.
     */
    orderBy?: MusicalOrderByWithRelationInput | MusicalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Musicals.
     */
    cursor?: MusicalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Musicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Musicals.
     */
    skip?: number
    distinct?: MusicalScalarFieldEnum | MusicalScalarFieldEnum[]
  }

  /**
   * Musical create
   */
  export type MusicalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * The data needed to create a Musical.
     */
    data: XOR<MusicalCreateInput, MusicalUncheckedCreateInput>
  }

  /**
   * Musical createMany
   */
  export type MusicalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Musicals.
     */
    data: MusicalCreateManyInput | MusicalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Musical update
   */
  export type MusicalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * The data needed to update a Musical.
     */
    data: XOR<MusicalUpdateInput, MusicalUncheckedUpdateInput>
    /**
     * Choose, which Musical to update.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical updateMany
   */
  export type MusicalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Musicals.
     */
    data: XOR<MusicalUpdateManyMutationInput, MusicalUncheckedUpdateManyInput>
    /**
     * Filter which Musicals to update
     */
    where?: MusicalWhereInput
  }

  /**
   * Musical upsert
   */
  export type MusicalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * The filter to search for the Musical to update in case it exists.
     */
    where: MusicalWhereUniqueInput
    /**
     * In case the Musical found by the `where` argument doesn't exist, create a new Musical with this data.
     */
    create: XOR<MusicalCreateInput, MusicalUncheckedCreateInput>
    /**
     * In case the Musical was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MusicalUpdateInput, MusicalUncheckedUpdateInput>
  }

  /**
   * Musical delete
   */
  export type MusicalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
    /**
     * Filter which Musical to delete.
     */
    where: MusicalWhereUniqueInput
  }

  /**
   * Musical deleteMany
   */
  export type MusicalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Musicals to delete
     */
    where?: MusicalWhereInput
  }

  /**
   * Musical.Product
   */
  export type Musical$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Musical.events
   */
  export type Musical$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Musical without action
   */
  export type MusicalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Musical
     */
    select?: MusicalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MusicalInclude<ExtArgs> | null
  }


  /**
   * Model Luxury
   */

  export type AggregateLuxury = {
    _count: LuxuryCountAggregateOutputType | null
    _avg: LuxuryAvgAggregateOutputType | null
    _sum: LuxurySumAggregateOutputType | null
    _min: LuxuryMinAggregateOutputType | null
    _max: LuxuryMaxAggregateOutputType | null
  }

  export type LuxuryAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type LuxurySumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type LuxuryMinAggregateOutputType = {
    id: number | null
    luxury_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type LuxuryMaxAggregateOutputType = {
    id: number | null
    luxury_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type LuxuryCountAggregateOutputType = {
    id: number
    luxury_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type LuxuryAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type LuxurySumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type LuxuryMinAggregateInputType = {
    id?: true
    luxury_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type LuxuryMaxAggregateInputType = {
    id?: true
    luxury_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type LuxuryCountAggregateInputType = {
    id?: true
    luxury_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type LuxuryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Luxury to aggregate.
     */
    where?: LuxuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Luxuries to fetch.
     */
    orderBy?: LuxuryOrderByWithRelationInput | LuxuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LuxuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Luxuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Luxuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Luxuries
    **/
    _count?: true | LuxuryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LuxuryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LuxurySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LuxuryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LuxuryMaxAggregateInputType
  }

  export type GetLuxuryAggregateType<T extends LuxuryAggregateArgs> = {
        [P in keyof T & keyof AggregateLuxury]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLuxury[P]>
      : GetScalarType<T[P], AggregateLuxury[P]>
  }




  export type LuxuryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LuxuryWhereInput
    orderBy?: LuxuryOrderByWithAggregationInput | LuxuryOrderByWithAggregationInput[]
    by: LuxuryScalarFieldEnum[] | LuxuryScalarFieldEnum
    having?: LuxuryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LuxuryCountAggregateInputType | true
    _avg?: LuxuryAvgAggregateInputType
    _sum?: LuxurySumAggregateInputType
    _min?: LuxuryMinAggregateInputType
    _max?: LuxuryMaxAggregateInputType
  }

  export type LuxuryGroupByOutputType = {
    id: number
    luxury_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: LuxuryCountAggregateOutputType | null
    _avg: LuxuryAvgAggregateOutputType | null
    _sum: LuxurySumAggregateOutputType | null
    _min: LuxuryMinAggregateOutputType | null
    _max: LuxuryMaxAggregateOutputType | null
  }

  type GetLuxuryGroupByPayload<T extends LuxuryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LuxuryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LuxuryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LuxuryGroupByOutputType[P]>
            : GetScalarType<T[P], LuxuryGroupByOutputType[P]>
        }
      >
    >


  export type LuxurySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    luxury_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | Luxury$ProductArgs<ExtArgs>
    events?: boolean | Luxury$eventsArgs<ExtArgs>
    _count?: boolean | LuxuryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["luxury"]>


  export type LuxurySelectScalar = {
    id?: boolean
    luxury_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type LuxuryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Luxury$ProductArgs<ExtArgs>
    events?: boolean | Luxury$eventsArgs<ExtArgs>
    _count?: boolean | LuxuryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LuxuryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Luxury"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      luxury_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["luxury"]>
    composites: {}
  }

  type LuxuryGetPayload<S extends boolean | null | undefined | LuxuryDefaultArgs> = $Result.GetResult<Prisma.$LuxuryPayload, S>

  type LuxuryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LuxuryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LuxuryCountAggregateInputType | true
    }

  export interface LuxuryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Luxury'], meta: { name: 'Luxury' } }
    /**
     * Find zero or one Luxury that matches the filter.
     * @param {LuxuryFindUniqueArgs} args - Arguments to find a Luxury
     * @example
     * // Get one Luxury
     * const luxury = await prisma.luxury.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LuxuryFindUniqueArgs>(args: SelectSubset<T, LuxuryFindUniqueArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Luxury that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LuxuryFindUniqueOrThrowArgs} args - Arguments to find a Luxury
     * @example
     * // Get one Luxury
     * const luxury = await prisma.luxury.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LuxuryFindUniqueOrThrowArgs>(args: SelectSubset<T, LuxuryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Luxury that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryFindFirstArgs} args - Arguments to find a Luxury
     * @example
     * // Get one Luxury
     * const luxury = await prisma.luxury.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LuxuryFindFirstArgs>(args?: SelectSubset<T, LuxuryFindFirstArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Luxury that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryFindFirstOrThrowArgs} args - Arguments to find a Luxury
     * @example
     * // Get one Luxury
     * const luxury = await prisma.luxury.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LuxuryFindFirstOrThrowArgs>(args?: SelectSubset<T, LuxuryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Luxuries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Luxuries
     * const luxuries = await prisma.luxury.findMany()
     * 
     * // Get first 10 Luxuries
     * const luxuries = await prisma.luxury.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const luxuryWithIdOnly = await prisma.luxury.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LuxuryFindManyArgs>(args?: SelectSubset<T, LuxuryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Luxury.
     * @param {LuxuryCreateArgs} args - Arguments to create a Luxury.
     * @example
     * // Create one Luxury
     * const Luxury = await prisma.luxury.create({
     *   data: {
     *     // ... data to create a Luxury
     *   }
     * })
     * 
     */
    create<T extends LuxuryCreateArgs>(args: SelectSubset<T, LuxuryCreateArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Luxuries.
     * @param {LuxuryCreateManyArgs} args - Arguments to create many Luxuries.
     * @example
     * // Create many Luxuries
     * const luxury = await prisma.luxury.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LuxuryCreateManyArgs>(args?: SelectSubset<T, LuxuryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Luxury.
     * @param {LuxuryDeleteArgs} args - Arguments to delete one Luxury.
     * @example
     * // Delete one Luxury
     * const Luxury = await prisma.luxury.delete({
     *   where: {
     *     // ... filter to delete one Luxury
     *   }
     * })
     * 
     */
    delete<T extends LuxuryDeleteArgs>(args: SelectSubset<T, LuxuryDeleteArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Luxury.
     * @param {LuxuryUpdateArgs} args - Arguments to update one Luxury.
     * @example
     * // Update one Luxury
     * const luxury = await prisma.luxury.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LuxuryUpdateArgs>(args: SelectSubset<T, LuxuryUpdateArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Luxuries.
     * @param {LuxuryDeleteManyArgs} args - Arguments to filter Luxuries to delete.
     * @example
     * // Delete a few Luxuries
     * const { count } = await prisma.luxury.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LuxuryDeleteManyArgs>(args?: SelectSubset<T, LuxuryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Luxuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Luxuries
     * const luxury = await prisma.luxury.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LuxuryUpdateManyArgs>(args: SelectSubset<T, LuxuryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Luxury.
     * @param {LuxuryUpsertArgs} args - Arguments to update or create a Luxury.
     * @example
     * // Update or create a Luxury
     * const luxury = await prisma.luxury.upsert({
     *   create: {
     *     // ... data to create a Luxury
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Luxury we want to update
     *   }
     * })
     */
    upsert<T extends LuxuryUpsertArgs>(args: SelectSubset<T, LuxuryUpsertArgs<ExtArgs>>): Prisma__LuxuryClient<$Result.GetResult<Prisma.$LuxuryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Luxuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryCountArgs} args - Arguments to filter Luxuries to count.
     * @example
     * // Count the number of Luxuries
     * const count = await prisma.luxury.count({
     *   where: {
     *     // ... the filter for the Luxuries we want to count
     *   }
     * })
    **/
    count<T extends LuxuryCountArgs>(
      args?: Subset<T, LuxuryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LuxuryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Luxury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LuxuryAggregateArgs>(args: Subset<T, LuxuryAggregateArgs>): Prisma.PrismaPromise<GetLuxuryAggregateType<T>>

    /**
     * Group by Luxury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuxuryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LuxuryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LuxuryGroupByArgs['orderBy'] }
        : { orderBy?: LuxuryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LuxuryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLuxuryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Luxury model
   */
  readonly fields: LuxuryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Luxury.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LuxuryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Luxury$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Luxury$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Luxury$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Luxury$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Luxury model
   */ 
  interface LuxuryFieldRefs {
    readonly id: FieldRef<"Luxury", 'Int'>
    readonly luxury_name: FieldRef<"Luxury", 'String'>
    readonly price: FieldRef<"Luxury", 'Int'>
    readonly offerPrice: FieldRef<"Luxury", 'Int'>
    readonly description: FieldRef<"Luxury", 'String'>
    readonly createdAt: FieldRef<"Luxury", 'DateTime'>
    readonly updatedAt: FieldRef<"Luxury", 'DateTime'>
    readonly productId: FieldRef<"Luxury", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Luxury findUnique
   */
  export type LuxuryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * Filter, which Luxury to fetch.
     */
    where: LuxuryWhereUniqueInput
  }

  /**
   * Luxury findUniqueOrThrow
   */
  export type LuxuryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * Filter, which Luxury to fetch.
     */
    where: LuxuryWhereUniqueInput
  }

  /**
   * Luxury findFirst
   */
  export type LuxuryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * Filter, which Luxury to fetch.
     */
    where?: LuxuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Luxuries to fetch.
     */
    orderBy?: LuxuryOrderByWithRelationInput | LuxuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Luxuries.
     */
    cursor?: LuxuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Luxuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Luxuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Luxuries.
     */
    distinct?: LuxuryScalarFieldEnum | LuxuryScalarFieldEnum[]
  }

  /**
   * Luxury findFirstOrThrow
   */
  export type LuxuryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * Filter, which Luxury to fetch.
     */
    where?: LuxuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Luxuries to fetch.
     */
    orderBy?: LuxuryOrderByWithRelationInput | LuxuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Luxuries.
     */
    cursor?: LuxuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Luxuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Luxuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Luxuries.
     */
    distinct?: LuxuryScalarFieldEnum | LuxuryScalarFieldEnum[]
  }

  /**
   * Luxury findMany
   */
  export type LuxuryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * Filter, which Luxuries to fetch.
     */
    where?: LuxuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Luxuries to fetch.
     */
    orderBy?: LuxuryOrderByWithRelationInput | LuxuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Luxuries.
     */
    cursor?: LuxuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Luxuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Luxuries.
     */
    skip?: number
    distinct?: LuxuryScalarFieldEnum | LuxuryScalarFieldEnum[]
  }

  /**
   * Luxury create
   */
  export type LuxuryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * The data needed to create a Luxury.
     */
    data: XOR<LuxuryCreateInput, LuxuryUncheckedCreateInput>
  }

  /**
   * Luxury createMany
   */
  export type LuxuryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Luxuries.
     */
    data: LuxuryCreateManyInput | LuxuryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Luxury update
   */
  export type LuxuryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * The data needed to update a Luxury.
     */
    data: XOR<LuxuryUpdateInput, LuxuryUncheckedUpdateInput>
    /**
     * Choose, which Luxury to update.
     */
    where: LuxuryWhereUniqueInput
  }

  /**
   * Luxury updateMany
   */
  export type LuxuryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Luxuries.
     */
    data: XOR<LuxuryUpdateManyMutationInput, LuxuryUncheckedUpdateManyInput>
    /**
     * Filter which Luxuries to update
     */
    where?: LuxuryWhereInput
  }

  /**
   * Luxury upsert
   */
  export type LuxuryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * The filter to search for the Luxury to update in case it exists.
     */
    where: LuxuryWhereUniqueInput
    /**
     * In case the Luxury found by the `where` argument doesn't exist, create a new Luxury with this data.
     */
    create: XOR<LuxuryCreateInput, LuxuryUncheckedCreateInput>
    /**
     * In case the Luxury was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LuxuryUpdateInput, LuxuryUncheckedUpdateInput>
  }

  /**
   * Luxury delete
   */
  export type LuxuryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
    /**
     * Filter which Luxury to delete.
     */
    where: LuxuryWhereUniqueInput
  }

  /**
   * Luxury deleteMany
   */
  export type LuxuryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Luxuries to delete
     */
    where?: LuxuryWhereInput
  }

  /**
   * Luxury.Product
   */
  export type Luxury$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Luxury.events
   */
  export type Luxury$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Luxury without action
   */
  export type LuxuryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Luxury
     */
    select?: LuxurySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LuxuryInclude<ExtArgs> | null
  }


  /**
   * Model Entertainment
   */

  export type AggregateEntertainment = {
    _count: EntertainmentCountAggregateOutputType | null
    _avg: EntertainmentAvgAggregateOutputType | null
    _sum: EntertainmentSumAggregateOutputType | null
    _min: EntertainmentMinAggregateOutputType | null
    _max: EntertainmentMaxAggregateOutputType | null
  }

  export type EntertainmentAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type EntertainmentSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type EntertainmentMinAggregateOutputType = {
    id: number | null
    entertainment_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type EntertainmentMaxAggregateOutputType = {
    id: number | null
    entertainment_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type EntertainmentCountAggregateOutputType = {
    id: number
    entertainment_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type EntertainmentAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type EntertainmentSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type EntertainmentMinAggregateInputType = {
    id?: true
    entertainment_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type EntertainmentMaxAggregateInputType = {
    id?: true
    entertainment_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type EntertainmentCountAggregateInputType = {
    id?: true
    entertainment_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type EntertainmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entertainment to aggregate.
     */
    where?: EntertainmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entertainments to fetch.
     */
    orderBy?: EntertainmentOrderByWithRelationInput | EntertainmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntertainmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entertainments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entertainments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entertainments
    **/
    _count?: true | EntertainmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntertainmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntertainmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntertainmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntertainmentMaxAggregateInputType
  }

  export type GetEntertainmentAggregateType<T extends EntertainmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEntertainment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntertainment[P]>
      : GetScalarType<T[P], AggregateEntertainment[P]>
  }




  export type EntertainmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntertainmentWhereInput
    orderBy?: EntertainmentOrderByWithAggregationInput | EntertainmentOrderByWithAggregationInput[]
    by: EntertainmentScalarFieldEnum[] | EntertainmentScalarFieldEnum
    having?: EntertainmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntertainmentCountAggregateInputType | true
    _avg?: EntertainmentAvgAggregateInputType
    _sum?: EntertainmentSumAggregateInputType
    _min?: EntertainmentMinAggregateInputType
    _max?: EntertainmentMaxAggregateInputType
  }

  export type EntertainmentGroupByOutputType = {
    id: number
    entertainment_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: EntertainmentCountAggregateOutputType | null
    _avg: EntertainmentAvgAggregateOutputType | null
    _sum: EntertainmentSumAggregateOutputType | null
    _min: EntertainmentMinAggregateOutputType | null
    _max: EntertainmentMaxAggregateOutputType | null
  }

  type GetEntertainmentGroupByPayload<T extends EntertainmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntertainmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntertainmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntertainmentGroupByOutputType[P]>
            : GetScalarType<T[P], EntertainmentGroupByOutputType[P]>
        }
      >
    >


  export type EntertainmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entertainment_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | Entertainment$ProductArgs<ExtArgs>
    events?: boolean | Entertainment$eventsArgs<ExtArgs>
    _count?: boolean | EntertainmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entertainment"]>


  export type EntertainmentSelectScalar = {
    id?: boolean
    entertainment_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type EntertainmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Entertainment$ProductArgs<ExtArgs>
    events?: boolean | Entertainment$eventsArgs<ExtArgs>
    _count?: boolean | EntertainmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EntertainmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entertainment"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entertainment_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["entertainment"]>
    composites: {}
  }

  type EntertainmentGetPayload<S extends boolean | null | undefined | EntertainmentDefaultArgs> = $Result.GetResult<Prisma.$EntertainmentPayload, S>

  type EntertainmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntertainmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntertainmentCountAggregateInputType | true
    }

  export interface EntertainmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entertainment'], meta: { name: 'Entertainment' } }
    /**
     * Find zero or one Entertainment that matches the filter.
     * @param {EntertainmentFindUniqueArgs} args - Arguments to find a Entertainment
     * @example
     * // Get one Entertainment
     * const entertainment = await prisma.entertainment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntertainmentFindUniqueArgs>(args: SelectSubset<T, EntertainmentFindUniqueArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Entertainment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntertainmentFindUniqueOrThrowArgs} args - Arguments to find a Entertainment
     * @example
     * // Get one Entertainment
     * const entertainment = await prisma.entertainment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntertainmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EntertainmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Entertainment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentFindFirstArgs} args - Arguments to find a Entertainment
     * @example
     * // Get one Entertainment
     * const entertainment = await prisma.entertainment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntertainmentFindFirstArgs>(args?: SelectSubset<T, EntertainmentFindFirstArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Entertainment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentFindFirstOrThrowArgs} args - Arguments to find a Entertainment
     * @example
     * // Get one Entertainment
     * const entertainment = await prisma.entertainment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntertainmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EntertainmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Entertainments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entertainments
     * const entertainments = await prisma.entertainment.findMany()
     * 
     * // Get first 10 Entertainments
     * const entertainments = await prisma.entertainment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entertainmentWithIdOnly = await prisma.entertainment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntertainmentFindManyArgs>(args?: SelectSubset<T, EntertainmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Entertainment.
     * @param {EntertainmentCreateArgs} args - Arguments to create a Entertainment.
     * @example
     * // Create one Entertainment
     * const Entertainment = await prisma.entertainment.create({
     *   data: {
     *     // ... data to create a Entertainment
     *   }
     * })
     * 
     */
    create<T extends EntertainmentCreateArgs>(args: SelectSubset<T, EntertainmentCreateArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Entertainments.
     * @param {EntertainmentCreateManyArgs} args - Arguments to create many Entertainments.
     * @example
     * // Create many Entertainments
     * const entertainment = await prisma.entertainment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntertainmentCreateManyArgs>(args?: SelectSubset<T, EntertainmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entertainment.
     * @param {EntertainmentDeleteArgs} args - Arguments to delete one Entertainment.
     * @example
     * // Delete one Entertainment
     * const Entertainment = await prisma.entertainment.delete({
     *   where: {
     *     // ... filter to delete one Entertainment
     *   }
     * })
     * 
     */
    delete<T extends EntertainmentDeleteArgs>(args: SelectSubset<T, EntertainmentDeleteArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Entertainment.
     * @param {EntertainmentUpdateArgs} args - Arguments to update one Entertainment.
     * @example
     * // Update one Entertainment
     * const entertainment = await prisma.entertainment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntertainmentUpdateArgs>(args: SelectSubset<T, EntertainmentUpdateArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Entertainments.
     * @param {EntertainmentDeleteManyArgs} args - Arguments to filter Entertainments to delete.
     * @example
     * // Delete a few Entertainments
     * const { count } = await prisma.entertainment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntertainmentDeleteManyArgs>(args?: SelectSubset<T, EntertainmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entertainments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entertainments
     * const entertainment = await prisma.entertainment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntertainmentUpdateManyArgs>(args: SelectSubset<T, EntertainmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entertainment.
     * @param {EntertainmentUpsertArgs} args - Arguments to update or create a Entertainment.
     * @example
     * // Update or create a Entertainment
     * const entertainment = await prisma.entertainment.upsert({
     *   create: {
     *     // ... data to create a Entertainment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entertainment we want to update
     *   }
     * })
     */
    upsert<T extends EntertainmentUpsertArgs>(args: SelectSubset<T, EntertainmentUpsertArgs<ExtArgs>>): Prisma__EntertainmentClient<$Result.GetResult<Prisma.$EntertainmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Entertainments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentCountArgs} args - Arguments to filter Entertainments to count.
     * @example
     * // Count the number of Entertainments
     * const count = await prisma.entertainment.count({
     *   where: {
     *     // ... the filter for the Entertainments we want to count
     *   }
     * })
    **/
    count<T extends EntertainmentCountArgs>(
      args?: Subset<T, EntertainmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntertainmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entertainment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntertainmentAggregateArgs>(args: Subset<T, EntertainmentAggregateArgs>): Prisma.PrismaPromise<GetEntertainmentAggregateType<T>>

    /**
     * Group by Entertainment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntertainmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntertainmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntertainmentGroupByArgs['orderBy'] }
        : { orderBy?: EntertainmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntertainmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntertainmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entertainment model
   */
  readonly fields: EntertainmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entertainment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntertainmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Entertainment$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Entertainment$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Entertainment$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Entertainment$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entertainment model
   */ 
  interface EntertainmentFieldRefs {
    readonly id: FieldRef<"Entertainment", 'Int'>
    readonly entertainment_name: FieldRef<"Entertainment", 'String'>
    readonly price: FieldRef<"Entertainment", 'Int'>
    readonly offerPrice: FieldRef<"Entertainment", 'Int'>
    readonly description: FieldRef<"Entertainment", 'String'>
    readonly createdAt: FieldRef<"Entertainment", 'DateTime'>
    readonly updatedAt: FieldRef<"Entertainment", 'DateTime'>
    readonly productId: FieldRef<"Entertainment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Entertainment findUnique
   */
  export type EntertainmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * Filter, which Entertainment to fetch.
     */
    where: EntertainmentWhereUniqueInput
  }

  /**
   * Entertainment findUniqueOrThrow
   */
  export type EntertainmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * Filter, which Entertainment to fetch.
     */
    where: EntertainmentWhereUniqueInput
  }

  /**
   * Entertainment findFirst
   */
  export type EntertainmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * Filter, which Entertainment to fetch.
     */
    where?: EntertainmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entertainments to fetch.
     */
    orderBy?: EntertainmentOrderByWithRelationInput | EntertainmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entertainments.
     */
    cursor?: EntertainmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entertainments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entertainments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entertainments.
     */
    distinct?: EntertainmentScalarFieldEnum | EntertainmentScalarFieldEnum[]
  }

  /**
   * Entertainment findFirstOrThrow
   */
  export type EntertainmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * Filter, which Entertainment to fetch.
     */
    where?: EntertainmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entertainments to fetch.
     */
    orderBy?: EntertainmentOrderByWithRelationInput | EntertainmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entertainments.
     */
    cursor?: EntertainmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entertainments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entertainments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entertainments.
     */
    distinct?: EntertainmentScalarFieldEnum | EntertainmentScalarFieldEnum[]
  }

  /**
   * Entertainment findMany
   */
  export type EntertainmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * Filter, which Entertainments to fetch.
     */
    where?: EntertainmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entertainments to fetch.
     */
    orderBy?: EntertainmentOrderByWithRelationInput | EntertainmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entertainments.
     */
    cursor?: EntertainmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entertainments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entertainments.
     */
    skip?: number
    distinct?: EntertainmentScalarFieldEnum | EntertainmentScalarFieldEnum[]
  }

  /**
   * Entertainment create
   */
  export type EntertainmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Entertainment.
     */
    data: XOR<EntertainmentCreateInput, EntertainmentUncheckedCreateInput>
  }

  /**
   * Entertainment createMany
   */
  export type EntertainmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entertainments.
     */
    data: EntertainmentCreateManyInput | EntertainmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entertainment update
   */
  export type EntertainmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Entertainment.
     */
    data: XOR<EntertainmentUpdateInput, EntertainmentUncheckedUpdateInput>
    /**
     * Choose, which Entertainment to update.
     */
    where: EntertainmentWhereUniqueInput
  }

  /**
   * Entertainment updateMany
   */
  export type EntertainmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entertainments.
     */
    data: XOR<EntertainmentUpdateManyMutationInput, EntertainmentUncheckedUpdateManyInput>
    /**
     * Filter which Entertainments to update
     */
    where?: EntertainmentWhereInput
  }

  /**
   * Entertainment upsert
   */
  export type EntertainmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Entertainment to update in case it exists.
     */
    where: EntertainmentWhereUniqueInput
    /**
     * In case the Entertainment found by the `where` argument doesn't exist, create a new Entertainment with this data.
     */
    create: XOR<EntertainmentCreateInput, EntertainmentUncheckedCreateInput>
    /**
     * In case the Entertainment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntertainmentUpdateInput, EntertainmentUncheckedUpdateInput>
  }

  /**
   * Entertainment delete
   */
  export type EntertainmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
    /**
     * Filter which Entertainment to delete.
     */
    where: EntertainmentWhereUniqueInput
  }

  /**
   * Entertainment deleteMany
   */
  export type EntertainmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entertainments to delete
     */
    where?: EntertainmentWhereInput
  }

  /**
   * Entertainment.Product
   */
  export type Entertainment$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Entertainment.events
   */
  export type Entertainment$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Entertainment without action
   */
  export type EntertainmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entertainment
     */
    select?: EntertainmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntertainmentInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
    eventId: number | null
  }

  export type MeetingSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
    eventId: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: number | null
    meeting_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
    eventId: number | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: number | null
    meeting_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
    eventId: number | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    meeting_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    eventId: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
    eventId?: true
  }

  export type MeetingSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
    eventId?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    meeting_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    eventId?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    meeting_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    eventId?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    meeting_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    eventId?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: number
    meeting_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    eventId: number
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meeting_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    eventId?: boolean
    Product?: boolean | Meeting$ProductArgs<ExtArgs>
    events?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>


  export type MeetingSelectScalar = {
    id?: boolean
    meeting_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    eventId?: boolean
  }

  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Meeting$ProductArgs<ExtArgs>
    events?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      meeting_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
      eventId: number
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Meeting$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */ 
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'Int'>
    readonly meeting_name: FieldRef<"Meeting", 'String'>
    readonly price: FieldRef<"Meeting", 'Int'>
    readonly offerPrice: FieldRef<"Meeting", 'Int'>
    readonly description: FieldRef<"Meeting", 'String'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
    readonly productId: FieldRef<"Meeting", 'Int'>
    readonly eventId: FieldRef<"Meeting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting.Product
   */
  export type Meeting$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model BeautyDecor
   */

  export type AggregateBeautyDecor = {
    _count: BeautyDecorCountAggregateOutputType | null
    _avg: BeautyDecorAvgAggregateOutputType | null
    _sum: BeautyDecorSumAggregateOutputType | null
    _min: BeautyDecorMinAggregateOutputType | null
    _max: BeautyDecorMaxAggregateOutputType | null
  }

  export type BeautyDecorAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type BeautyDecorSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type BeautyDecorMinAggregateOutputType = {
    id: number | null
    beauty_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type BeautyDecorMaxAggregateOutputType = {
    id: number | null
    beauty_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type BeautyDecorCountAggregateOutputType = {
    id: number
    beauty_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type BeautyDecorAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type BeautyDecorSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type BeautyDecorMinAggregateInputType = {
    id?: true
    beauty_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type BeautyDecorMaxAggregateInputType = {
    id?: true
    beauty_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type BeautyDecorCountAggregateInputType = {
    id?: true
    beauty_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type BeautyDecorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BeautyDecor to aggregate.
     */
    where?: BeautyDecorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeautyDecors to fetch.
     */
    orderBy?: BeautyDecorOrderByWithRelationInput | BeautyDecorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BeautyDecorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeautyDecors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeautyDecors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BeautyDecors
    **/
    _count?: true | BeautyDecorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeautyDecorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeautyDecorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeautyDecorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeautyDecorMaxAggregateInputType
  }

  export type GetBeautyDecorAggregateType<T extends BeautyDecorAggregateArgs> = {
        [P in keyof T & keyof AggregateBeautyDecor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeautyDecor[P]>
      : GetScalarType<T[P], AggregateBeautyDecor[P]>
  }




  export type BeautyDecorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BeautyDecorWhereInput
    orderBy?: BeautyDecorOrderByWithAggregationInput | BeautyDecorOrderByWithAggregationInput[]
    by: BeautyDecorScalarFieldEnum[] | BeautyDecorScalarFieldEnum
    having?: BeautyDecorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeautyDecorCountAggregateInputType | true
    _avg?: BeautyDecorAvgAggregateInputType
    _sum?: BeautyDecorSumAggregateInputType
    _min?: BeautyDecorMinAggregateInputType
    _max?: BeautyDecorMaxAggregateInputType
  }

  export type BeautyDecorGroupByOutputType = {
    id: number
    beauty_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: BeautyDecorCountAggregateOutputType | null
    _avg: BeautyDecorAvgAggregateOutputType | null
    _sum: BeautyDecorSumAggregateOutputType | null
    _min: BeautyDecorMinAggregateOutputType | null
    _max: BeautyDecorMaxAggregateOutputType | null
  }

  type GetBeautyDecorGroupByPayload<T extends BeautyDecorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeautyDecorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeautyDecorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeautyDecorGroupByOutputType[P]>
            : GetScalarType<T[P], BeautyDecorGroupByOutputType[P]>
        }
      >
    >


  export type BeautyDecorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    beauty_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | BeautyDecor$ProductArgs<ExtArgs>
    events?: boolean | BeautyDecor$eventsArgs<ExtArgs>
    _count?: boolean | BeautyDecorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beautyDecor"]>


  export type BeautyDecorSelectScalar = {
    id?: boolean
    beauty_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type BeautyDecorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | BeautyDecor$ProductArgs<ExtArgs>
    events?: boolean | BeautyDecor$eventsArgs<ExtArgs>
    _count?: boolean | BeautyDecorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BeautyDecorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BeautyDecor"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      beauty_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["beautyDecor"]>
    composites: {}
  }

  type BeautyDecorGetPayload<S extends boolean | null | undefined | BeautyDecorDefaultArgs> = $Result.GetResult<Prisma.$BeautyDecorPayload, S>

  type BeautyDecorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BeautyDecorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BeautyDecorCountAggregateInputType | true
    }

  export interface BeautyDecorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BeautyDecor'], meta: { name: 'BeautyDecor' } }
    /**
     * Find zero or one BeautyDecor that matches the filter.
     * @param {BeautyDecorFindUniqueArgs} args - Arguments to find a BeautyDecor
     * @example
     * // Get one BeautyDecor
     * const beautyDecor = await prisma.beautyDecor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BeautyDecorFindUniqueArgs>(args: SelectSubset<T, BeautyDecorFindUniqueArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BeautyDecor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BeautyDecorFindUniqueOrThrowArgs} args - Arguments to find a BeautyDecor
     * @example
     * // Get one BeautyDecor
     * const beautyDecor = await prisma.beautyDecor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BeautyDecorFindUniqueOrThrowArgs>(args: SelectSubset<T, BeautyDecorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BeautyDecor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorFindFirstArgs} args - Arguments to find a BeautyDecor
     * @example
     * // Get one BeautyDecor
     * const beautyDecor = await prisma.beautyDecor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BeautyDecorFindFirstArgs>(args?: SelectSubset<T, BeautyDecorFindFirstArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BeautyDecor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorFindFirstOrThrowArgs} args - Arguments to find a BeautyDecor
     * @example
     * // Get one BeautyDecor
     * const beautyDecor = await prisma.beautyDecor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BeautyDecorFindFirstOrThrowArgs>(args?: SelectSubset<T, BeautyDecorFindFirstOrThrowArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BeautyDecors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BeautyDecors
     * const beautyDecors = await prisma.beautyDecor.findMany()
     * 
     * // Get first 10 BeautyDecors
     * const beautyDecors = await prisma.beautyDecor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beautyDecorWithIdOnly = await prisma.beautyDecor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BeautyDecorFindManyArgs>(args?: SelectSubset<T, BeautyDecorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BeautyDecor.
     * @param {BeautyDecorCreateArgs} args - Arguments to create a BeautyDecor.
     * @example
     * // Create one BeautyDecor
     * const BeautyDecor = await prisma.beautyDecor.create({
     *   data: {
     *     // ... data to create a BeautyDecor
     *   }
     * })
     * 
     */
    create<T extends BeautyDecorCreateArgs>(args: SelectSubset<T, BeautyDecorCreateArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BeautyDecors.
     * @param {BeautyDecorCreateManyArgs} args - Arguments to create many BeautyDecors.
     * @example
     * // Create many BeautyDecors
     * const beautyDecor = await prisma.beautyDecor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BeautyDecorCreateManyArgs>(args?: SelectSubset<T, BeautyDecorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BeautyDecor.
     * @param {BeautyDecorDeleteArgs} args - Arguments to delete one BeautyDecor.
     * @example
     * // Delete one BeautyDecor
     * const BeautyDecor = await prisma.beautyDecor.delete({
     *   where: {
     *     // ... filter to delete one BeautyDecor
     *   }
     * })
     * 
     */
    delete<T extends BeautyDecorDeleteArgs>(args: SelectSubset<T, BeautyDecorDeleteArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BeautyDecor.
     * @param {BeautyDecorUpdateArgs} args - Arguments to update one BeautyDecor.
     * @example
     * // Update one BeautyDecor
     * const beautyDecor = await prisma.beautyDecor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BeautyDecorUpdateArgs>(args: SelectSubset<T, BeautyDecorUpdateArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BeautyDecors.
     * @param {BeautyDecorDeleteManyArgs} args - Arguments to filter BeautyDecors to delete.
     * @example
     * // Delete a few BeautyDecors
     * const { count } = await prisma.beautyDecor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BeautyDecorDeleteManyArgs>(args?: SelectSubset<T, BeautyDecorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeautyDecors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BeautyDecors
     * const beautyDecor = await prisma.beautyDecor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BeautyDecorUpdateManyArgs>(args: SelectSubset<T, BeautyDecorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BeautyDecor.
     * @param {BeautyDecorUpsertArgs} args - Arguments to update or create a BeautyDecor.
     * @example
     * // Update or create a BeautyDecor
     * const beautyDecor = await prisma.beautyDecor.upsert({
     *   create: {
     *     // ... data to create a BeautyDecor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BeautyDecor we want to update
     *   }
     * })
     */
    upsert<T extends BeautyDecorUpsertArgs>(args: SelectSubset<T, BeautyDecorUpsertArgs<ExtArgs>>): Prisma__BeautyDecorClient<$Result.GetResult<Prisma.$BeautyDecorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BeautyDecors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorCountArgs} args - Arguments to filter BeautyDecors to count.
     * @example
     * // Count the number of BeautyDecors
     * const count = await prisma.beautyDecor.count({
     *   where: {
     *     // ... the filter for the BeautyDecors we want to count
     *   }
     * })
    **/
    count<T extends BeautyDecorCountArgs>(
      args?: Subset<T, BeautyDecorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeautyDecorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BeautyDecor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeautyDecorAggregateArgs>(args: Subset<T, BeautyDecorAggregateArgs>): Prisma.PrismaPromise<GetBeautyDecorAggregateType<T>>

    /**
     * Group by BeautyDecor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeautyDecorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BeautyDecorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BeautyDecorGroupByArgs['orderBy'] }
        : { orderBy?: BeautyDecorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BeautyDecorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeautyDecorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BeautyDecor model
   */
  readonly fields: BeautyDecorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BeautyDecor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BeautyDecorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends BeautyDecor$ProductArgs<ExtArgs> = {}>(args?: Subset<T, BeautyDecor$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends BeautyDecor$eventsArgs<ExtArgs> = {}>(args?: Subset<T, BeautyDecor$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BeautyDecor model
   */ 
  interface BeautyDecorFieldRefs {
    readonly id: FieldRef<"BeautyDecor", 'Int'>
    readonly beauty_name: FieldRef<"BeautyDecor", 'String'>
    readonly price: FieldRef<"BeautyDecor", 'Int'>
    readonly offerPrice: FieldRef<"BeautyDecor", 'Int'>
    readonly description: FieldRef<"BeautyDecor", 'String'>
    readonly createdAt: FieldRef<"BeautyDecor", 'DateTime'>
    readonly updatedAt: FieldRef<"BeautyDecor", 'DateTime'>
    readonly productId: FieldRef<"BeautyDecor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BeautyDecor findUnique
   */
  export type BeautyDecorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * Filter, which BeautyDecor to fetch.
     */
    where: BeautyDecorWhereUniqueInput
  }

  /**
   * BeautyDecor findUniqueOrThrow
   */
  export type BeautyDecorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * Filter, which BeautyDecor to fetch.
     */
    where: BeautyDecorWhereUniqueInput
  }

  /**
   * BeautyDecor findFirst
   */
  export type BeautyDecorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * Filter, which BeautyDecor to fetch.
     */
    where?: BeautyDecorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeautyDecors to fetch.
     */
    orderBy?: BeautyDecorOrderByWithRelationInput | BeautyDecorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BeautyDecors.
     */
    cursor?: BeautyDecorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeautyDecors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeautyDecors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BeautyDecors.
     */
    distinct?: BeautyDecorScalarFieldEnum | BeautyDecorScalarFieldEnum[]
  }

  /**
   * BeautyDecor findFirstOrThrow
   */
  export type BeautyDecorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * Filter, which BeautyDecor to fetch.
     */
    where?: BeautyDecorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeautyDecors to fetch.
     */
    orderBy?: BeautyDecorOrderByWithRelationInput | BeautyDecorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BeautyDecors.
     */
    cursor?: BeautyDecorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeautyDecors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeautyDecors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BeautyDecors.
     */
    distinct?: BeautyDecorScalarFieldEnum | BeautyDecorScalarFieldEnum[]
  }

  /**
   * BeautyDecor findMany
   */
  export type BeautyDecorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * Filter, which BeautyDecors to fetch.
     */
    where?: BeautyDecorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BeautyDecors to fetch.
     */
    orderBy?: BeautyDecorOrderByWithRelationInput | BeautyDecorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BeautyDecors.
     */
    cursor?: BeautyDecorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BeautyDecors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BeautyDecors.
     */
    skip?: number
    distinct?: BeautyDecorScalarFieldEnum | BeautyDecorScalarFieldEnum[]
  }

  /**
   * BeautyDecor create
   */
  export type BeautyDecorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * The data needed to create a BeautyDecor.
     */
    data: XOR<BeautyDecorCreateInput, BeautyDecorUncheckedCreateInput>
  }

  /**
   * BeautyDecor createMany
   */
  export type BeautyDecorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BeautyDecors.
     */
    data: BeautyDecorCreateManyInput | BeautyDecorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BeautyDecor update
   */
  export type BeautyDecorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * The data needed to update a BeautyDecor.
     */
    data: XOR<BeautyDecorUpdateInput, BeautyDecorUncheckedUpdateInput>
    /**
     * Choose, which BeautyDecor to update.
     */
    where: BeautyDecorWhereUniqueInput
  }

  /**
   * BeautyDecor updateMany
   */
  export type BeautyDecorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BeautyDecors.
     */
    data: XOR<BeautyDecorUpdateManyMutationInput, BeautyDecorUncheckedUpdateManyInput>
    /**
     * Filter which BeautyDecors to update
     */
    where?: BeautyDecorWhereInput
  }

  /**
   * BeautyDecor upsert
   */
  export type BeautyDecorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * The filter to search for the BeautyDecor to update in case it exists.
     */
    where: BeautyDecorWhereUniqueInput
    /**
     * In case the BeautyDecor found by the `where` argument doesn't exist, create a new BeautyDecor with this data.
     */
    create: XOR<BeautyDecorCreateInput, BeautyDecorUncheckedCreateInput>
    /**
     * In case the BeautyDecor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BeautyDecorUpdateInput, BeautyDecorUncheckedUpdateInput>
  }

  /**
   * BeautyDecor delete
   */
  export type BeautyDecorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
    /**
     * Filter which BeautyDecor to delete.
     */
    where: BeautyDecorWhereUniqueInput
  }

  /**
   * BeautyDecor deleteMany
   */
  export type BeautyDecorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BeautyDecors to delete
     */
    where?: BeautyDecorWhereInput
  }

  /**
   * BeautyDecor.Product
   */
  export type BeautyDecor$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * BeautyDecor.events
   */
  export type BeautyDecor$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * BeautyDecor without action
   */
  export type BeautyDecorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BeautyDecor
     */
    select?: BeautyDecorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BeautyDecorInclude<ExtArgs> | null
  }


  /**
   * Model Adventure
   */

  export type AggregateAdventure = {
    _count: AdventureCountAggregateOutputType | null
    _avg: AdventureAvgAggregateOutputType | null
    _sum: AdventureSumAggregateOutputType | null
    _min: AdventureMinAggregateOutputType | null
    _max: AdventureMaxAggregateOutputType | null
  }

  export type AdventureAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type AdventureSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type AdventureMinAggregateOutputType = {
    id: number | null
    adventure_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type AdventureMaxAggregateOutputType = {
    id: number | null
    adventure_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type AdventureCountAggregateOutputType = {
    id: number
    adventure_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type AdventureAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type AdventureSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type AdventureMinAggregateInputType = {
    id?: true
    adventure_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type AdventureMaxAggregateInputType = {
    id?: true
    adventure_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type AdventureCountAggregateInputType = {
    id?: true
    adventure_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type AdventureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adventure to aggregate.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adventures
    **/
    _count?: true | AdventureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdventureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdventureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdventureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdventureMaxAggregateInputType
  }

  export type GetAdventureAggregateType<T extends AdventureAggregateArgs> = {
        [P in keyof T & keyof AggregateAdventure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdventure[P]>
      : GetScalarType<T[P], AggregateAdventure[P]>
  }




  export type AdventureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithAggregationInput | AdventureOrderByWithAggregationInput[]
    by: AdventureScalarFieldEnum[] | AdventureScalarFieldEnum
    having?: AdventureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdventureCountAggregateInputType | true
    _avg?: AdventureAvgAggregateInputType
    _sum?: AdventureSumAggregateInputType
    _min?: AdventureMinAggregateInputType
    _max?: AdventureMaxAggregateInputType
  }

  export type AdventureGroupByOutputType = {
    id: number
    adventure_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: AdventureCountAggregateOutputType | null
    _avg: AdventureAvgAggregateOutputType | null
    _sum: AdventureSumAggregateOutputType | null
    _min: AdventureMinAggregateOutputType | null
    _max: AdventureMaxAggregateOutputType | null
  }

  type GetAdventureGroupByPayload<T extends AdventureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdventureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdventureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdventureGroupByOutputType[P]>
            : GetScalarType<T[P], AdventureGroupByOutputType[P]>
        }
      >
    >


  export type AdventureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adventure_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | Adventure$ProductArgs<ExtArgs>
    events?: boolean | Adventure$eventsArgs<ExtArgs>
    _count?: boolean | AdventureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>


  export type AdventureSelectScalar = {
    id?: boolean
    adventure_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type AdventureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Adventure$ProductArgs<ExtArgs>
    events?: boolean | Adventure$eventsArgs<ExtArgs>
    _count?: boolean | AdventureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdventurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adventure"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adventure_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["adventure"]>
    composites: {}
  }

  type AdventureGetPayload<S extends boolean | null | undefined | AdventureDefaultArgs> = $Result.GetResult<Prisma.$AdventurePayload, S>

  type AdventureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdventureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdventureCountAggregateInputType | true
    }

  export interface AdventureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adventure'], meta: { name: 'Adventure' } }
    /**
     * Find zero or one Adventure that matches the filter.
     * @param {AdventureFindUniqueArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdventureFindUniqueArgs>(args: SelectSubset<T, AdventureFindUniqueArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Adventure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdventureFindUniqueOrThrowArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdventureFindUniqueOrThrowArgs>(args: SelectSubset<T, AdventureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Adventure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindFirstArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdventureFindFirstArgs>(args?: SelectSubset<T, AdventureFindFirstArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Adventure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindFirstOrThrowArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdventureFindFirstOrThrowArgs>(args?: SelectSubset<T, AdventureFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Adventures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adventures
     * const adventures = await prisma.adventure.findMany()
     * 
     * // Get first 10 Adventures
     * const adventures = await prisma.adventure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adventureWithIdOnly = await prisma.adventure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdventureFindManyArgs>(args?: SelectSubset<T, AdventureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Adventure.
     * @param {AdventureCreateArgs} args - Arguments to create a Adventure.
     * @example
     * // Create one Adventure
     * const Adventure = await prisma.adventure.create({
     *   data: {
     *     // ... data to create a Adventure
     *   }
     * })
     * 
     */
    create<T extends AdventureCreateArgs>(args: SelectSubset<T, AdventureCreateArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Adventures.
     * @param {AdventureCreateManyArgs} args - Arguments to create many Adventures.
     * @example
     * // Create many Adventures
     * const adventure = await prisma.adventure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdventureCreateManyArgs>(args?: SelectSubset<T, AdventureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Adventure.
     * @param {AdventureDeleteArgs} args - Arguments to delete one Adventure.
     * @example
     * // Delete one Adventure
     * const Adventure = await prisma.adventure.delete({
     *   where: {
     *     // ... filter to delete one Adventure
     *   }
     * })
     * 
     */
    delete<T extends AdventureDeleteArgs>(args: SelectSubset<T, AdventureDeleteArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Adventure.
     * @param {AdventureUpdateArgs} args - Arguments to update one Adventure.
     * @example
     * // Update one Adventure
     * const adventure = await prisma.adventure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdventureUpdateArgs>(args: SelectSubset<T, AdventureUpdateArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Adventures.
     * @param {AdventureDeleteManyArgs} args - Arguments to filter Adventures to delete.
     * @example
     * // Delete a few Adventures
     * const { count } = await prisma.adventure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdventureDeleteManyArgs>(args?: SelectSubset<T, AdventureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adventures
     * const adventure = await prisma.adventure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdventureUpdateManyArgs>(args: SelectSubset<T, AdventureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Adventure.
     * @param {AdventureUpsertArgs} args - Arguments to update or create a Adventure.
     * @example
     * // Update or create a Adventure
     * const adventure = await prisma.adventure.upsert({
     *   create: {
     *     // ... data to create a Adventure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adventure we want to update
     *   }
     * })
     */
    upsert<T extends AdventureUpsertArgs>(args: SelectSubset<T, AdventureUpsertArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Adventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureCountArgs} args - Arguments to filter Adventures to count.
     * @example
     * // Count the number of Adventures
     * const count = await prisma.adventure.count({
     *   where: {
     *     // ... the filter for the Adventures we want to count
     *   }
     * })
    **/
    count<T extends AdventureCountArgs>(
      args?: Subset<T, AdventureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdventureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adventure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdventureAggregateArgs>(args: Subset<T, AdventureAggregateArgs>): Prisma.PrismaPromise<GetAdventureAggregateType<T>>

    /**
     * Group by Adventure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdventureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdventureGroupByArgs['orderBy'] }
        : { orderBy?: AdventureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdventureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdventureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adventure model
   */
  readonly fields: AdventureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adventure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdventureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Adventure$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Adventure$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends Adventure$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Adventure$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adventure model
   */ 
  interface AdventureFieldRefs {
    readonly id: FieldRef<"Adventure", 'Int'>
    readonly adventure_name: FieldRef<"Adventure", 'String'>
    readonly price: FieldRef<"Adventure", 'Int'>
    readonly offerPrice: FieldRef<"Adventure", 'Int'>
    readonly description: FieldRef<"Adventure", 'String'>
    readonly createdAt: FieldRef<"Adventure", 'DateTime'>
    readonly updatedAt: FieldRef<"Adventure", 'DateTime'>
    readonly productId: FieldRef<"Adventure", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Adventure findUnique
   */
  export type AdventureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure findUniqueOrThrow
   */
  export type AdventureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure findFirst
   */
  export type AdventureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adventures.
     */
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure findFirstOrThrow
   */
  export type AdventureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adventures.
     */
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure findMany
   */
  export type AdventureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventures to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure create
   */
  export type AdventureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The data needed to create a Adventure.
     */
    data: XOR<AdventureCreateInput, AdventureUncheckedCreateInput>
  }

  /**
   * Adventure createMany
   */
  export type AdventureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adventures.
     */
    data: AdventureCreateManyInput | AdventureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adventure update
   */
  export type AdventureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The data needed to update a Adventure.
     */
    data: XOR<AdventureUpdateInput, AdventureUncheckedUpdateInput>
    /**
     * Choose, which Adventure to update.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure updateMany
   */
  export type AdventureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adventures.
     */
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyInput>
    /**
     * Filter which Adventures to update
     */
    where?: AdventureWhereInput
  }

  /**
   * Adventure upsert
   */
  export type AdventureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The filter to search for the Adventure to update in case it exists.
     */
    where: AdventureWhereUniqueInput
    /**
     * In case the Adventure found by the `where` argument doesn't exist, create a new Adventure with this data.
     */
    create: XOR<AdventureCreateInput, AdventureUncheckedCreateInput>
    /**
     * In case the Adventure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdventureUpdateInput, AdventureUncheckedUpdateInput>
  }

  /**
   * Adventure delete
   */
  export type AdventureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter which Adventure to delete.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure deleteMany
   */
  export type AdventureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adventures to delete
     */
    where?: AdventureWhereInput
  }

  /**
   * Adventure.Product
   */
  export type Adventure$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Adventure.events
   */
  export type Adventure$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Adventure without action
   */
  export type AdventureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
  }


  /**
   * Model PartyPalace
   */

  export type AggregatePartyPalace = {
    _count: PartyPalaceCountAggregateOutputType | null
    _avg: PartyPalaceAvgAggregateOutputType | null
    _sum: PartyPalaceSumAggregateOutputType | null
    _min: PartyPalaceMinAggregateOutputType | null
    _max: PartyPalaceMaxAggregateOutputType | null
  }

  export type PartyPalaceAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type PartyPalaceSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type PartyPalaceMinAggregateOutputType = {
    id: number | null
    partypalace_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type PartyPalaceMaxAggregateOutputType = {
    id: number | null
    partypalace_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type PartyPalaceCountAggregateOutputType = {
    id: number
    partypalace_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type PartyPalaceAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type PartyPalaceSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type PartyPalaceMinAggregateInputType = {
    id?: true
    partypalace_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type PartyPalaceMaxAggregateInputType = {
    id?: true
    partypalace_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type PartyPalaceCountAggregateInputType = {
    id?: true
    partypalace_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type PartyPalaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartyPalace to aggregate.
     */
    where?: PartyPalaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartyPalaces to fetch.
     */
    orderBy?: PartyPalaceOrderByWithRelationInput | PartyPalaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartyPalaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartyPalaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartyPalaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartyPalaces
    **/
    _count?: true | PartyPalaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartyPalaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartyPalaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartyPalaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartyPalaceMaxAggregateInputType
  }

  export type GetPartyPalaceAggregateType<T extends PartyPalaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePartyPalace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartyPalace[P]>
      : GetScalarType<T[P], AggregatePartyPalace[P]>
  }




  export type PartyPalaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartyPalaceWhereInput
    orderBy?: PartyPalaceOrderByWithAggregationInput | PartyPalaceOrderByWithAggregationInput[]
    by: PartyPalaceScalarFieldEnum[] | PartyPalaceScalarFieldEnum
    having?: PartyPalaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartyPalaceCountAggregateInputType | true
    _avg?: PartyPalaceAvgAggregateInputType
    _sum?: PartyPalaceSumAggregateInputType
    _min?: PartyPalaceMinAggregateInputType
    _max?: PartyPalaceMaxAggregateInputType
  }

  export type PartyPalaceGroupByOutputType = {
    id: number
    partypalace_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: PartyPalaceCountAggregateOutputType | null
    _avg: PartyPalaceAvgAggregateOutputType | null
    _sum: PartyPalaceSumAggregateOutputType | null
    _min: PartyPalaceMinAggregateOutputType | null
    _max: PartyPalaceMaxAggregateOutputType | null
  }

  type GetPartyPalaceGroupByPayload<T extends PartyPalaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartyPalaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartyPalaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartyPalaceGroupByOutputType[P]>
            : GetScalarType<T[P], PartyPalaceGroupByOutputType[P]>
        }
      >
    >


  export type PartyPalaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partypalace_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | PartyPalace$ProductArgs<ExtArgs>
    events?: boolean | PartyPalace$eventsArgs<ExtArgs>
    _count?: boolean | PartyPalaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partyPalace"]>


  export type PartyPalaceSelectScalar = {
    id?: boolean
    partypalace_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type PartyPalaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | PartyPalace$ProductArgs<ExtArgs>
    events?: boolean | PartyPalace$eventsArgs<ExtArgs>
    _count?: boolean | PartyPalaceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PartyPalacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartyPalace"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partypalace_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["partyPalace"]>
    composites: {}
  }

  type PartyPalaceGetPayload<S extends boolean | null | undefined | PartyPalaceDefaultArgs> = $Result.GetResult<Prisma.$PartyPalacePayload, S>

  type PartyPalaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartyPalaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartyPalaceCountAggregateInputType | true
    }

  export interface PartyPalaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartyPalace'], meta: { name: 'PartyPalace' } }
    /**
     * Find zero or one PartyPalace that matches the filter.
     * @param {PartyPalaceFindUniqueArgs} args - Arguments to find a PartyPalace
     * @example
     * // Get one PartyPalace
     * const partyPalace = await prisma.partyPalace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartyPalaceFindUniqueArgs>(args: SelectSubset<T, PartyPalaceFindUniqueArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PartyPalace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartyPalaceFindUniqueOrThrowArgs} args - Arguments to find a PartyPalace
     * @example
     * // Get one PartyPalace
     * const partyPalace = await prisma.partyPalace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartyPalaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PartyPalaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PartyPalace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceFindFirstArgs} args - Arguments to find a PartyPalace
     * @example
     * // Get one PartyPalace
     * const partyPalace = await prisma.partyPalace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartyPalaceFindFirstArgs>(args?: SelectSubset<T, PartyPalaceFindFirstArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PartyPalace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceFindFirstOrThrowArgs} args - Arguments to find a PartyPalace
     * @example
     * // Get one PartyPalace
     * const partyPalace = await prisma.partyPalace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartyPalaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PartyPalaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PartyPalaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartyPalaces
     * const partyPalaces = await prisma.partyPalace.findMany()
     * 
     * // Get first 10 PartyPalaces
     * const partyPalaces = await prisma.partyPalace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partyPalaceWithIdOnly = await prisma.partyPalace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartyPalaceFindManyArgs>(args?: SelectSubset<T, PartyPalaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PartyPalace.
     * @param {PartyPalaceCreateArgs} args - Arguments to create a PartyPalace.
     * @example
     * // Create one PartyPalace
     * const PartyPalace = await prisma.partyPalace.create({
     *   data: {
     *     // ... data to create a PartyPalace
     *   }
     * })
     * 
     */
    create<T extends PartyPalaceCreateArgs>(args: SelectSubset<T, PartyPalaceCreateArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PartyPalaces.
     * @param {PartyPalaceCreateManyArgs} args - Arguments to create many PartyPalaces.
     * @example
     * // Create many PartyPalaces
     * const partyPalace = await prisma.partyPalace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartyPalaceCreateManyArgs>(args?: SelectSubset<T, PartyPalaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PartyPalace.
     * @param {PartyPalaceDeleteArgs} args - Arguments to delete one PartyPalace.
     * @example
     * // Delete one PartyPalace
     * const PartyPalace = await prisma.partyPalace.delete({
     *   where: {
     *     // ... filter to delete one PartyPalace
     *   }
     * })
     * 
     */
    delete<T extends PartyPalaceDeleteArgs>(args: SelectSubset<T, PartyPalaceDeleteArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PartyPalace.
     * @param {PartyPalaceUpdateArgs} args - Arguments to update one PartyPalace.
     * @example
     * // Update one PartyPalace
     * const partyPalace = await prisma.partyPalace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartyPalaceUpdateArgs>(args: SelectSubset<T, PartyPalaceUpdateArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PartyPalaces.
     * @param {PartyPalaceDeleteManyArgs} args - Arguments to filter PartyPalaces to delete.
     * @example
     * // Delete a few PartyPalaces
     * const { count } = await prisma.partyPalace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartyPalaceDeleteManyArgs>(args?: SelectSubset<T, PartyPalaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartyPalaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartyPalaces
     * const partyPalace = await prisma.partyPalace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartyPalaceUpdateManyArgs>(args: SelectSubset<T, PartyPalaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PartyPalace.
     * @param {PartyPalaceUpsertArgs} args - Arguments to update or create a PartyPalace.
     * @example
     * // Update or create a PartyPalace
     * const partyPalace = await prisma.partyPalace.upsert({
     *   create: {
     *     // ... data to create a PartyPalace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartyPalace we want to update
     *   }
     * })
     */
    upsert<T extends PartyPalaceUpsertArgs>(args: SelectSubset<T, PartyPalaceUpsertArgs<ExtArgs>>): Prisma__PartyPalaceClient<$Result.GetResult<Prisma.$PartyPalacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PartyPalaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceCountArgs} args - Arguments to filter PartyPalaces to count.
     * @example
     * // Count the number of PartyPalaces
     * const count = await prisma.partyPalace.count({
     *   where: {
     *     // ... the filter for the PartyPalaces we want to count
     *   }
     * })
    **/
    count<T extends PartyPalaceCountArgs>(
      args?: Subset<T, PartyPalaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartyPalaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartyPalace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartyPalaceAggregateArgs>(args: Subset<T, PartyPalaceAggregateArgs>): Prisma.PrismaPromise<GetPartyPalaceAggregateType<T>>

    /**
     * Group by PartyPalace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyPalaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartyPalaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartyPalaceGroupByArgs['orderBy'] }
        : { orderBy?: PartyPalaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartyPalaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartyPalaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartyPalace model
   */
  readonly fields: PartyPalaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartyPalace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartyPalaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends PartyPalace$ProductArgs<ExtArgs> = {}>(args?: Subset<T, PartyPalace$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends PartyPalace$eventsArgs<ExtArgs> = {}>(args?: Subset<T, PartyPalace$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartyPalace model
   */ 
  interface PartyPalaceFieldRefs {
    readonly id: FieldRef<"PartyPalace", 'Int'>
    readonly partypalace_name: FieldRef<"PartyPalace", 'String'>
    readonly price: FieldRef<"PartyPalace", 'Int'>
    readonly offerPrice: FieldRef<"PartyPalace", 'Int'>
    readonly description: FieldRef<"PartyPalace", 'String'>
    readonly createdAt: FieldRef<"PartyPalace", 'DateTime'>
    readonly updatedAt: FieldRef<"PartyPalace", 'DateTime'>
    readonly productId: FieldRef<"PartyPalace", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PartyPalace findUnique
   */
  export type PartyPalaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * Filter, which PartyPalace to fetch.
     */
    where: PartyPalaceWhereUniqueInput
  }

  /**
   * PartyPalace findUniqueOrThrow
   */
  export type PartyPalaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * Filter, which PartyPalace to fetch.
     */
    where: PartyPalaceWhereUniqueInput
  }

  /**
   * PartyPalace findFirst
   */
  export type PartyPalaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * Filter, which PartyPalace to fetch.
     */
    where?: PartyPalaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartyPalaces to fetch.
     */
    orderBy?: PartyPalaceOrderByWithRelationInput | PartyPalaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartyPalaces.
     */
    cursor?: PartyPalaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartyPalaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartyPalaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartyPalaces.
     */
    distinct?: PartyPalaceScalarFieldEnum | PartyPalaceScalarFieldEnum[]
  }

  /**
   * PartyPalace findFirstOrThrow
   */
  export type PartyPalaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * Filter, which PartyPalace to fetch.
     */
    where?: PartyPalaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartyPalaces to fetch.
     */
    orderBy?: PartyPalaceOrderByWithRelationInput | PartyPalaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartyPalaces.
     */
    cursor?: PartyPalaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartyPalaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartyPalaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartyPalaces.
     */
    distinct?: PartyPalaceScalarFieldEnum | PartyPalaceScalarFieldEnum[]
  }

  /**
   * PartyPalace findMany
   */
  export type PartyPalaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * Filter, which PartyPalaces to fetch.
     */
    where?: PartyPalaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartyPalaces to fetch.
     */
    orderBy?: PartyPalaceOrderByWithRelationInput | PartyPalaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartyPalaces.
     */
    cursor?: PartyPalaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartyPalaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartyPalaces.
     */
    skip?: number
    distinct?: PartyPalaceScalarFieldEnum | PartyPalaceScalarFieldEnum[]
  }

  /**
   * PartyPalace create
   */
  export type PartyPalaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * The data needed to create a PartyPalace.
     */
    data: XOR<PartyPalaceCreateInput, PartyPalaceUncheckedCreateInput>
  }

  /**
   * PartyPalace createMany
   */
  export type PartyPalaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartyPalaces.
     */
    data: PartyPalaceCreateManyInput | PartyPalaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartyPalace update
   */
  export type PartyPalaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * The data needed to update a PartyPalace.
     */
    data: XOR<PartyPalaceUpdateInput, PartyPalaceUncheckedUpdateInput>
    /**
     * Choose, which PartyPalace to update.
     */
    where: PartyPalaceWhereUniqueInput
  }

  /**
   * PartyPalace updateMany
   */
  export type PartyPalaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartyPalaces.
     */
    data: XOR<PartyPalaceUpdateManyMutationInput, PartyPalaceUncheckedUpdateManyInput>
    /**
     * Filter which PartyPalaces to update
     */
    where?: PartyPalaceWhereInput
  }

  /**
   * PartyPalace upsert
   */
  export type PartyPalaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * The filter to search for the PartyPalace to update in case it exists.
     */
    where: PartyPalaceWhereUniqueInput
    /**
     * In case the PartyPalace found by the `where` argument doesn't exist, create a new PartyPalace with this data.
     */
    create: XOR<PartyPalaceCreateInput, PartyPalaceUncheckedCreateInput>
    /**
     * In case the PartyPalace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartyPalaceUpdateInput, PartyPalaceUncheckedUpdateInput>
  }

  /**
   * PartyPalace delete
   */
  export type PartyPalaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
    /**
     * Filter which PartyPalace to delete.
     */
    where: PartyPalaceWhereUniqueInput
  }

  /**
   * PartyPalace deleteMany
   */
  export type PartyPalaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartyPalaces to delete
     */
    where?: PartyPalaceWhereInput
  }

  /**
   * PartyPalace.Product
   */
  export type PartyPalace$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * PartyPalace.events
   */
  export type PartyPalace$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * PartyPalace without action
   */
  export type PartyPalaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyPalace
     */
    select?: PartyPalaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyPalaceInclude<ExtArgs> | null
  }


  /**
   * Model CateringTent
   */

  export type AggregateCateringTent = {
    _count: CateringTentCountAggregateOutputType | null
    _avg: CateringTentAvgAggregateOutputType | null
    _sum: CateringTentSumAggregateOutputType | null
    _min: CateringTentMinAggregateOutputType | null
    _max: CateringTentMaxAggregateOutputType | null
  }

  export type CateringTentAvgAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type CateringTentSumAggregateOutputType = {
    id: number | null
    price: number | null
    offerPrice: number | null
    productId: number | null
  }

  export type CateringTentMinAggregateOutputType = {
    id: number | null
    catering_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type CateringTentMaxAggregateOutputType = {
    id: number | null
    catering_name: string | null
    price: number | null
    offerPrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: number | null
  }

  export type CateringTentCountAggregateOutputType = {
    id: number
    catering_name: number
    price: number
    offerPrice: number
    description: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type CateringTentAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type CateringTentSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    productId?: true
  }

  export type CateringTentMinAggregateInputType = {
    id?: true
    catering_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type CateringTentMaxAggregateInputType = {
    id?: true
    catering_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type CateringTentCountAggregateInputType = {
    id?: true
    catering_name?: true
    price?: true
    offerPrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type CateringTentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CateringTent to aggregate.
     */
    where?: CateringTentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringTents to fetch.
     */
    orderBy?: CateringTentOrderByWithRelationInput | CateringTentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CateringTentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringTents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringTents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CateringTents
    **/
    _count?: true | CateringTentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CateringTentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CateringTentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CateringTentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CateringTentMaxAggregateInputType
  }

  export type GetCateringTentAggregateType<T extends CateringTentAggregateArgs> = {
        [P in keyof T & keyof AggregateCateringTent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCateringTent[P]>
      : GetScalarType<T[P], AggregateCateringTent[P]>
  }




  export type CateringTentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CateringTentWhereInput
    orderBy?: CateringTentOrderByWithAggregationInput | CateringTentOrderByWithAggregationInput[]
    by: CateringTentScalarFieldEnum[] | CateringTentScalarFieldEnum
    having?: CateringTentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CateringTentCountAggregateInputType | true
    _avg?: CateringTentAvgAggregateInputType
    _sum?: CateringTentSumAggregateInputType
    _min?: CateringTentMinAggregateInputType
    _max?: CateringTentMaxAggregateInputType
  }

  export type CateringTentGroupByOutputType = {
    id: number
    catering_name: string
    price: number
    offerPrice: number | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    productId: number | null
    _count: CateringTentCountAggregateOutputType | null
    _avg: CateringTentAvgAggregateOutputType | null
    _sum: CateringTentSumAggregateOutputType | null
    _min: CateringTentMinAggregateOutputType | null
    _max: CateringTentMaxAggregateOutputType | null
  }

  type GetCateringTentGroupByPayload<T extends CateringTentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CateringTentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CateringTentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CateringTentGroupByOutputType[P]>
            : GetScalarType<T[P], CateringTentGroupByOutputType[P]>
        }
      >
    >


  export type CateringTentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catering_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | CateringTent$ProductArgs<ExtArgs>
    events?: boolean | CateringTent$eventsArgs<ExtArgs>
    _count?: boolean | CateringTentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cateringTent"]>


  export type CateringTentSelectScalar = {
    id?: boolean
    catering_name?: boolean
    price?: boolean
    offerPrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type CateringTentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | CateringTent$ProductArgs<ExtArgs>
    events?: boolean | CateringTent$eventsArgs<ExtArgs>
    _count?: boolean | CateringTentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CateringTentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CateringTent"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      catering_name: string
      price: number
      offerPrice: number | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      productId: number | null
    }, ExtArgs["result"]["cateringTent"]>
    composites: {}
  }

  type CateringTentGetPayload<S extends boolean | null | undefined | CateringTentDefaultArgs> = $Result.GetResult<Prisma.$CateringTentPayload, S>

  type CateringTentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CateringTentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CateringTentCountAggregateInputType | true
    }

  export interface CateringTentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CateringTent'], meta: { name: 'CateringTent' } }
    /**
     * Find zero or one CateringTent that matches the filter.
     * @param {CateringTentFindUniqueArgs} args - Arguments to find a CateringTent
     * @example
     * // Get one CateringTent
     * const cateringTent = await prisma.cateringTent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CateringTentFindUniqueArgs>(args: SelectSubset<T, CateringTentFindUniqueArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CateringTent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CateringTentFindUniqueOrThrowArgs} args - Arguments to find a CateringTent
     * @example
     * // Get one CateringTent
     * const cateringTent = await prisma.cateringTent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CateringTentFindUniqueOrThrowArgs>(args: SelectSubset<T, CateringTentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CateringTent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentFindFirstArgs} args - Arguments to find a CateringTent
     * @example
     * // Get one CateringTent
     * const cateringTent = await prisma.cateringTent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CateringTentFindFirstArgs>(args?: SelectSubset<T, CateringTentFindFirstArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CateringTent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentFindFirstOrThrowArgs} args - Arguments to find a CateringTent
     * @example
     * // Get one CateringTent
     * const cateringTent = await prisma.cateringTent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CateringTentFindFirstOrThrowArgs>(args?: SelectSubset<T, CateringTentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CateringTents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CateringTents
     * const cateringTents = await prisma.cateringTent.findMany()
     * 
     * // Get first 10 CateringTents
     * const cateringTents = await prisma.cateringTent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cateringTentWithIdOnly = await prisma.cateringTent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CateringTentFindManyArgs>(args?: SelectSubset<T, CateringTentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CateringTent.
     * @param {CateringTentCreateArgs} args - Arguments to create a CateringTent.
     * @example
     * // Create one CateringTent
     * const CateringTent = await prisma.cateringTent.create({
     *   data: {
     *     // ... data to create a CateringTent
     *   }
     * })
     * 
     */
    create<T extends CateringTentCreateArgs>(args: SelectSubset<T, CateringTentCreateArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CateringTents.
     * @param {CateringTentCreateManyArgs} args - Arguments to create many CateringTents.
     * @example
     * // Create many CateringTents
     * const cateringTent = await prisma.cateringTent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CateringTentCreateManyArgs>(args?: SelectSubset<T, CateringTentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CateringTent.
     * @param {CateringTentDeleteArgs} args - Arguments to delete one CateringTent.
     * @example
     * // Delete one CateringTent
     * const CateringTent = await prisma.cateringTent.delete({
     *   where: {
     *     // ... filter to delete one CateringTent
     *   }
     * })
     * 
     */
    delete<T extends CateringTentDeleteArgs>(args: SelectSubset<T, CateringTentDeleteArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CateringTent.
     * @param {CateringTentUpdateArgs} args - Arguments to update one CateringTent.
     * @example
     * // Update one CateringTent
     * const cateringTent = await prisma.cateringTent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CateringTentUpdateArgs>(args: SelectSubset<T, CateringTentUpdateArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CateringTents.
     * @param {CateringTentDeleteManyArgs} args - Arguments to filter CateringTents to delete.
     * @example
     * // Delete a few CateringTents
     * const { count } = await prisma.cateringTent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CateringTentDeleteManyArgs>(args?: SelectSubset<T, CateringTentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CateringTents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CateringTents
     * const cateringTent = await prisma.cateringTent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CateringTentUpdateManyArgs>(args: SelectSubset<T, CateringTentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CateringTent.
     * @param {CateringTentUpsertArgs} args - Arguments to update or create a CateringTent.
     * @example
     * // Update or create a CateringTent
     * const cateringTent = await prisma.cateringTent.upsert({
     *   create: {
     *     // ... data to create a CateringTent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CateringTent we want to update
     *   }
     * })
     */
    upsert<T extends CateringTentUpsertArgs>(args: SelectSubset<T, CateringTentUpsertArgs<ExtArgs>>): Prisma__CateringTentClient<$Result.GetResult<Prisma.$CateringTentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CateringTents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentCountArgs} args - Arguments to filter CateringTents to count.
     * @example
     * // Count the number of CateringTents
     * const count = await prisma.cateringTent.count({
     *   where: {
     *     // ... the filter for the CateringTents we want to count
     *   }
     * })
    **/
    count<T extends CateringTentCountArgs>(
      args?: Subset<T, CateringTentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CateringTentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CateringTent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CateringTentAggregateArgs>(args: Subset<T, CateringTentAggregateArgs>): Prisma.PrismaPromise<GetCateringTentAggregateType<T>>

    /**
     * Group by CateringTent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CateringTentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CateringTentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CateringTentGroupByArgs['orderBy'] }
        : { orderBy?: CateringTentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CateringTentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCateringTentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CateringTent model
   */
  readonly fields: CateringTentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CateringTent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CateringTentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends CateringTent$ProductArgs<ExtArgs> = {}>(args?: Subset<T, CateringTent$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    events<T extends CateringTent$eventsArgs<ExtArgs> = {}>(args?: Subset<T, CateringTent$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CateringTent model
   */ 
  interface CateringTentFieldRefs {
    readonly id: FieldRef<"CateringTent", 'Int'>
    readonly catering_name: FieldRef<"CateringTent", 'String'>
    readonly price: FieldRef<"CateringTent", 'Int'>
    readonly offerPrice: FieldRef<"CateringTent", 'Int'>
    readonly description: FieldRef<"CateringTent", 'String'>
    readonly createdAt: FieldRef<"CateringTent", 'DateTime'>
    readonly updatedAt: FieldRef<"CateringTent", 'DateTime'>
    readonly productId: FieldRef<"CateringTent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CateringTent findUnique
   */
  export type CateringTentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * Filter, which CateringTent to fetch.
     */
    where: CateringTentWhereUniqueInput
  }

  /**
   * CateringTent findUniqueOrThrow
   */
  export type CateringTentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * Filter, which CateringTent to fetch.
     */
    where: CateringTentWhereUniqueInput
  }

  /**
   * CateringTent findFirst
   */
  export type CateringTentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * Filter, which CateringTent to fetch.
     */
    where?: CateringTentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringTents to fetch.
     */
    orderBy?: CateringTentOrderByWithRelationInput | CateringTentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CateringTents.
     */
    cursor?: CateringTentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringTents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringTents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CateringTents.
     */
    distinct?: CateringTentScalarFieldEnum | CateringTentScalarFieldEnum[]
  }

  /**
   * CateringTent findFirstOrThrow
   */
  export type CateringTentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * Filter, which CateringTent to fetch.
     */
    where?: CateringTentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringTents to fetch.
     */
    orderBy?: CateringTentOrderByWithRelationInput | CateringTentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CateringTents.
     */
    cursor?: CateringTentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringTents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringTents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CateringTents.
     */
    distinct?: CateringTentScalarFieldEnum | CateringTentScalarFieldEnum[]
  }

  /**
   * CateringTent findMany
   */
  export type CateringTentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * Filter, which CateringTents to fetch.
     */
    where?: CateringTentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CateringTents to fetch.
     */
    orderBy?: CateringTentOrderByWithRelationInput | CateringTentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CateringTents.
     */
    cursor?: CateringTentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CateringTents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CateringTents.
     */
    skip?: number
    distinct?: CateringTentScalarFieldEnum | CateringTentScalarFieldEnum[]
  }

  /**
   * CateringTent create
   */
  export type CateringTentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * The data needed to create a CateringTent.
     */
    data: XOR<CateringTentCreateInput, CateringTentUncheckedCreateInput>
  }

  /**
   * CateringTent createMany
   */
  export type CateringTentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CateringTents.
     */
    data: CateringTentCreateManyInput | CateringTentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CateringTent update
   */
  export type CateringTentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * The data needed to update a CateringTent.
     */
    data: XOR<CateringTentUpdateInput, CateringTentUncheckedUpdateInput>
    /**
     * Choose, which CateringTent to update.
     */
    where: CateringTentWhereUniqueInput
  }

  /**
   * CateringTent updateMany
   */
  export type CateringTentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CateringTents.
     */
    data: XOR<CateringTentUpdateManyMutationInput, CateringTentUncheckedUpdateManyInput>
    /**
     * Filter which CateringTents to update
     */
    where?: CateringTentWhereInput
  }

  /**
   * CateringTent upsert
   */
  export type CateringTentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * The filter to search for the CateringTent to update in case it exists.
     */
    where: CateringTentWhereUniqueInput
    /**
     * In case the CateringTent found by the `where` argument doesn't exist, create a new CateringTent with this data.
     */
    create: XOR<CateringTentCreateInput, CateringTentUncheckedCreateInput>
    /**
     * In case the CateringTent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CateringTentUpdateInput, CateringTentUncheckedUpdateInput>
  }

  /**
   * CateringTent delete
   */
  export type CateringTentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
    /**
     * Filter which CateringTent to delete.
     */
    where: CateringTentWhereUniqueInput
  }

  /**
   * CateringTent deleteMany
   */
  export type CateringTentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CateringTents to delete
     */
    where?: CateringTentWhereInput
  }

  /**
   * CateringTent.Product
   */
  export type CateringTent$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * CateringTent.events
   */
  export type CateringTent$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * CateringTent without action
   */
  export type CateringTentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CateringTent
     */
    select?: CateringTentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CateringTentInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    url: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    url?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    url?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    url?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: number
    url: string
    productId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | ProductImage$ProductArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>


  export type ProductImageSelectScalar = {
    id?: boolean
    url?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductImage$ProductArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      productId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductImage$ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */ 
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'Int'>
    readonly url: FieldRef<"ProductImage", 'String'>
    readonly productId: FieldRef<"ProductImage", 'Int'>
    readonly createdAt: FieldRef<"ProductImage", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
  }

  /**
   * ProductImage.Product
   */
  export type ProductImage$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Model ContactUs
   */

  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _avg: ContactUsAvgAggregateOutputType | null
    _sum: ContactUsSumAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactUsSumAggregateOutputType = {
    id: number | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: number | null
    business_name: string | null
    email: string | null
    address: string | null
    phone_number: string | null
    another_phone_number: string | null
    contact_person: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: number | null
    business_name: string | null
    email: string | null
    address: string | null
    phone_number: string | null
    another_phone_number: string | null
    contact_person: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    business_name: number
    email: number
    address: number
    phone_number: number
    another_phone_number: number
    contact_person: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactUsAvgAggregateInputType = {
    id?: true
  }

  export type ContactUsSumAggregateInputType = {
    id?: true
  }

  export type ContactUsMinAggregateInputType = {
    id?: true
    business_name?: true
    email?: true
    address?: true
    phone_number?: true
    another_phone_number?: true
    contact_person?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    business_name?: true
    email?: true
    address?: true
    phone_number?: true
    another_phone_number?: true
    contact_person?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    business_name?: true
    email?: true
    address?: true
    phone_number?: true
    another_phone_number?: true
    contact_person?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUs to aggregate.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactUsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactUsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
    orderBy?: ContactUsOrderByWithAggregationInput | ContactUsOrderByWithAggregationInput[]
    by: ContactUsScalarFieldEnum[] | ContactUsScalarFieldEnum
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _avg?: ContactUsAvgAggregateInputType
    _sum?: ContactUsSumAggregateInputType
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }

  export type ContactUsGroupByOutputType = {
    id: number
    business_name: string
    email: string
    address: string
    phone_number: string | null
    another_phone_number: string | null
    contact_person: string
    createdAt: Date
    updatedAt: Date
    _count: ContactUsCountAggregateOutputType | null
    _avg: ContactUsAvgAggregateOutputType | null
    _sum: ContactUsSumAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_name?: boolean
    email?: boolean
    address?: boolean
    phone_number?: boolean
    another_phone_number?: boolean
    contact_person?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactUs"]>


  export type ContactUsSelectScalar = {
    id?: boolean
    business_name?: boolean
    email?: boolean
    address?: boolean
    phone_number?: boolean
    another_phone_number?: boolean
    contact_person?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ContactUsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactUs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      business_name: string
      email: string
      address: string
      phone_number: string | null
      another_phone_number: string | null
      contact_person: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactUs"]>
    composites: {}
  }

  type ContactUsGetPayload<S extends boolean | null | undefined | ContactUsDefaultArgs> = $Result.GetResult<Prisma.$ContactUsPayload, S>

  type ContactUsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactUsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface ContactUsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUs'], meta: { name: 'ContactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactUsFindUniqueArgs>(args: SelectSubset<T, ContactUsFindUniqueArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactUs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactUsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactUsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactUsFindFirstArgs>(args?: SelectSubset<T, ContactUsFindFirstArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactUsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactUsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactUsFindManyArgs>(args?: SelectSubset<T, ContactUsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
     */
    create<T extends ContactUsCreateArgs>(args: SelectSubset<T, ContactUsCreateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contactuses.
     * @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactUsCreateManyArgs>(args?: SelectSubset<T, ContactUsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
     */
    delete<T extends ContactUsDeleteArgs>(args: SelectSubset<T, ContactUsDeleteArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUsUpdateArgs>(args: SelectSubset<T, ContactUsUpdateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactUsDeleteManyArgs>(args?: SelectSubset<T, ContactUsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUsUpdateManyArgs>(args: SelectSubset<T, ContactUsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
     */
    upsert<T extends ContactUsUpsertArgs>(args: SelectSubset<T, ContactUsUpsertArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactUs model
   */
  readonly fields: ContactUsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactUsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactUs model
   */ 
  interface ContactUsFieldRefs {
    readonly id: FieldRef<"ContactUs", 'Int'>
    readonly business_name: FieldRef<"ContactUs", 'String'>
    readonly email: FieldRef<"ContactUs", 'String'>
    readonly address: FieldRef<"ContactUs", 'String'>
    readonly phone_number: FieldRef<"ContactUs", 'String'>
    readonly another_phone_number: FieldRef<"ContactUs", 'String'>
    readonly contact_person: FieldRef<"ContactUs", 'String'>
    readonly createdAt: FieldRef<"ContactUs", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactUs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactUs findUnique
   */
  export type ContactUsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findUniqueOrThrow
   */
  export type ContactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findFirst
   */
  export type ContactUsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findFirstOrThrow
   */
  export type ContactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Filter, which Contactuses to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * The data needed to create a ContactUs.
     */
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }

  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * The data needed to update a ContactUs.
     */
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
  }

  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     */
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     */
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }

  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Filter which ContactUs to delete.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactuses to delete
     */
    where?: ContactUsWhereInput
  }

  /**
   * ContactUs without action
   */
  export type ContactUsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    approved_by_id: number | null
  }

  export type BlogSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    approved_by_id: number | null
  }

  export type BlogMinAggregateOutputType = {
    id: number | null
    title: string | null
    short_description: string | null
    image: string | null
    description: string | null
    is_approved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: number | null
    approved_by_id: number | null
  }

  export type BlogMaxAggregateOutputType = {
    id: number | null
    title: string | null
    short_description: string | null
    image: string | null
    description: string | null
    is_approved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: number | null
    approved_by_id: number | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    title: number
    short_description: number
    image: number
    description: number
    is_approved: number
    createdAt: number
    updatedAt: number
    authorId: number
    approved_by_id: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    id?: true
    authorId?: true
    approved_by_id?: true
  }

  export type BlogSumAggregateInputType = {
    id?: true
    authorId?: true
    approved_by_id?: true
  }

  export type BlogMinAggregateInputType = {
    id?: true
    title?: true
    short_description?: true
    image?: true
    description?: true
    is_approved?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    approved_by_id?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    title?: true
    short_description?: true
    image?: true
    description?: true
    is_approved?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    approved_by_id?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    title?: true
    short_description?: true
    image?: true
    description?: true
    is_approved?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    approved_by_id?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: number
    title: string
    short_description: string | null
    image: string
    description: string
    is_approved: boolean | null
    createdAt: Date
    updatedAt: Date
    authorId: number | null
    approved_by_id: number | null
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    short_description?: boolean
    image?: boolean
    description?: boolean
    is_approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    approved_by_id?: boolean
    author?: boolean | Blog$authorArgs<ExtArgs>
    approved_by?: boolean | Blog$approved_byArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>


  export type BlogSelectScalar = {
    id?: boolean
    title?: boolean
    short_description?: boolean
    image?: boolean
    description?: boolean
    is_approved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    approved_by_id?: boolean
  }

  export type BlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Blog$authorArgs<ExtArgs>
    approved_by?: boolean | Blog$approved_byArgs<ExtArgs>
  }

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {
      author: Prisma.$UserPayload<ExtArgs> | null
      approved_by: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      short_description: string | null
      image: string
      description: string
      is_approved: boolean | null
      createdAt: Date
      updatedAt: Date
      authorId: number | null
      approved_by_id: number | null
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends Blog$authorArgs<ExtArgs> = {}>(args?: Subset<T, Blog$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    approved_by<T extends Blog$approved_byArgs<ExtArgs> = {}>(args?: Subset<T, Blog$approved_byArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */ 
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'Int'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly short_description: FieldRef<"Blog", 'String'>
    readonly image: FieldRef<"Blog", 'String'>
    readonly description: FieldRef<"Blog", 'String'>
    readonly is_approved: FieldRef<"Blog", 'Boolean'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
    readonly authorId: FieldRef<"Blog", 'Int'>
    readonly approved_by_id: FieldRef<"Blog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
  }

  /**
   * Blog.author
   */
  export type Blog$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Blog.approved_by
   */
  export type Blog$approved_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
  }


  /**
   * Model ProductRating
   */

  export type AggregateProductRating = {
    _count: ProductRatingCountAggregateOutputType | null
    _avg: ProductRatingAvgAggregateOutputType | null
    _sum: ProductRatingSumAggregateOutputType | null
    _min: ProductRatingMinAggregateOutputType | null
    _max: ProductRatingMaxAggregateOutputType | null
  }

  export type ProductRatingAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    userId: number | null
    productId: number | null
  }

  export type ProductRatingSumAggregateOutputType = {
    id: number | null
    rating: number | null
    userId: number | null
    productId: number | null
  }

  export type ProductRatingMinAggregateOutputType = {
    id: number | null
    rating: number | null
    review: string | null
    userId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductRatingMaxAggregateOutputType = {
    id: number | null
    rating: number | null
    review: string | null
    userId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductRatingCountAggregateOutputType = {
    id: number
    rating: number
    review: number
    userId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductRatingAvgAggregateInputType = {
    id?: true
    rating?: true
    userId?: true
    productId?: true
  }

  export type ProductRatingSumAggregateInputType = {
    id?: true
    rating?: true
    userId?: true
    productId?: true
  }

  export type ProductRatingMinAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductRatingMaxAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductRatingCountAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRating to aggregate.
     */
    where?: ProductRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRatings to fetch.
     */
    orderBy?: ProductRatingOrderByWithRelationInput | ProductRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductRatings
    **/
    _count?: true | ProductRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductRatingMaxAggregateInputType
  }

  export type GetProductRatingAggregateType<T extends ProductRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateProductRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductRating[P]>
      : GetScalarType<T[P], AggregateProductRating[P]>
  }




  export type ProductRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRatingWhereInput
    orderBy?: ProductRatingOrderByWithAggregationInput | ProductRatingOrderByWithAggregationInput[]
    by: ProductRatingScalarFieldEnum[] | ProductRatingScalarFieldEnum
    having?: ProductRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductRatingCountAggregateInputType | true
    _avg?: ProductRatingAvgAggregateInputType
    _sum?: ProductRatingSumAggregateInputType
    _min?: ProductRatingMinAggregateInputType
    _max?: ProductRatingMaxAggregateInputType
  }

  export type ProductRatingGroupByOutputType = {
    id: number
    rating: number
    review: string | null
    userId: number
    productId: number
    createdAt: Date
    updatedAt: Date
    _count: ProductRatingCountAggregateOutputType | null
    _avg: ProductRatingAvgAggregateOutputType | null
    _sum: ProductRatingSumAggregateOutputType | null
    _min: ProductRatingMinAggregateOutputType | null
    _max: ProductRatingMaxAggregateOutputType | null
  }

  type GetProductRatingGroupByPayload<T extends ProductRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ProductRatingGroupByOutputType[P]>
        }
      >
    >


  export type ProductRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRating"]>


  export type ProductRatingSelectScalar = {
    id?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductRating"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rating: number
      review: string | null
      userId: number
      productId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productRating"]>
    composites: {}
  }

  type ProductRatingGetPayload<S extends boolean | null | undefined | ProductRatingDefaultArgs> = $Result.GetResult<Prisma.$ProductRatingPayload, S>

  type ProductRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductRatingCountAggregateInputType | true
    }

  export interface ProductRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductRating'], meta: { name: 'ProductRating' } }
    /**
     * Find zero or one ProductRating that matches the filter.
     * @param {ProductRatingFindUniqueArgs} args - Arguments to find a ProductRating
     * @example
     * // Get one ProductRating
     * const productRating = await prisma.productRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductRatingFindUniqueArgs>(args: SelectSubset<T, ProductRatingFindUniqueArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductRatingFindUniqueOrThrowArgs} args - Arguments to find a ProductRating
     * @example
     * // Get one ProductRating
     * const productRating = await prisma.productRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingFindFirstArgs} args - Arguments to find a ProductRating
     * @example
     * // Get one ProductRating
     * const productRating = await prisma.productRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductRatingFindFirstArgs>(args?: SelectSubset<T, ProductRatingFindFirstArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingFindFirstOrThrowArgs} args - Arguments to find a ProductRating
     * @example
     * // Get one ProductRating
     * const productRating = await prisma.productRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductRatings
     * const productRatings = await prisma.productRating.findMany()
     * 
     * // Get first 10 ProductRatings
     * const productRatings = await prisma.productRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productRatingWithIdOnly = await prisma.productRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductRatingFindManyArgs>(args?: SelectSubset<T, ProductRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductRating.
     * @param {ProductRatingCreateArgs} args - Arguments to create a ProductRating.
     * @example
     * // Create one ProductRating
     * const ProductRating = await prisma.productRating.create({
     *   data: {
     *     // ... data to create a ProductRating
     *   }
     * })
     * 
     */
    create<T extends ProductRatingCreateArgs>(args: SelectSubset<T, ProductRatingCreateArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductRatings.
     * @param {ProductRatingCreateManyArgs} args - Arguments to create many ProductRatings.
     * @example
     * // Create many ProductRatings
     * const productRating = await prisma.productRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductRatingCreateManyArgs>(args?: SelectSubset<T, ProductRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductRating.
     * @param {ProductRatingDeleteArgs} args - Arguments to delete one ProductRating.
     * @example
     * // Delete one ProductRating
     * const ProductRating = await prisma.productRating.delete({
     *   where: {
     *     // ... filter to delete one ProductRating
     *   }
     * })
     * 
     */
    delete<T extends ProductRatingDeleteArgs>(args: SelectSubset<T, ProductRatingDeleteArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductRating.
     * @param {ProductRatingUpdateArgs} args - Arguments to update one ProductRating.
     * @example
     * // Update one ProductRating
     * const productRating = await prisma.productRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductRatingUpdateArgs>(args: SelectSubset<T, ProductRatingUpdateArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductRatings.
     * @param {ProductRatingDeleteManyArgs} args - Arguments to filter ProductRatings to delete.
     * @example
     * // Delete a few ProductRatings
     * const { count } = await prisma.productRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductRatingDeleteManyArgs>(args?: SelectSubset<T, ProductRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductRatings
     * const productRating = await prisma.productRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductRatingUpdateManyArgs>(args: SelectSubset<T, ProductRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductRating.
     * @param {ProductRatingUpsertArgs} args - Arguments to update or create a ProductRating.
     * @example
     * // Update or create a ProductRating
     * const productRating = await prisma.productRating.upsert({
     *   create: {
     *     // ... data to create a ProductRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductRating we want to update
     *   }
     * })
     */
    upsert<T extends ProductRatingUpsertArgs>(args: SelectSubset<T, ProductRatingUpsertArgs<ExtArgs>>): Prisma__ProductRatingClient<$Result.GetResult<Prisma.$ProductRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingCountArgs} args - Arguments to filter ProductRatings to count.
     * @example
     * // Count the number of ProductRatings
     * const count = await prisma.productRating.count({
     *   where: {
     *     // ... the filter for the ProductRatings we want to count
     *   }
     * })
    **/
    count<T extends ProductRatingCountArgs>(
      args?: Subset<T, ProductRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductRatingAggregateArgs>(args: Subset<T, ProductRatingAggregateArgs>): Prisma.PrismaPromise<GetProductRatingAggregateType<T>>

    /**
     * Group by ProductRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductRatingGroupByArgs['orderBy'] }
        : { orderBy?: ProductRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductRating model
   */
  readonly fields: ProductRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductRating model
   */ 
  interface ProductRatingFieldRefs {
    readonly id: FieldRef<"ProductRating", 'Int'>
    readonly rating: FieldRef<"ProductRating", 'Int'>
    readonly review: FieldRef<"ProductRating", 'String'>
    readonly userId: FieldRef<"ProductRating", 'Int'>
    readonly productId: FieldRef<"ProductRating", 'Int'>
    readonly createdAt: FieldRef<"ProductRating", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductRating findUnique
   */
  export type ProductRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * Filter, which ProductRating to fetch.
     */
    where: ProductRatingWhereUniqueInput
  }

  /**
   * ProductRating findUniqueOrThrow
   */
  export type ProductRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * Filter, which ProductRating to fetch.
     */
    where: ProductRatingWhereUniqueInput
  }

  /**
   * ProductRating findFirst
   */
  export type ProductRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * Filter, which ProductRating to fetch.
     */
    where?: ProductRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRatings to fetch.
     */
    orderBy?: ProductRatingOrderByWithRelationInput | ProductRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRatings.
     */
    cursor?: ProductRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRatings.
     */
    distinct?: ProductRatingScalarFieldEnum | ProductRatingScalarFieldEnum[]
  }

  /**
   * ProductRating findFirstOrThrow
   */
  export type ProductRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * Filter, which ProductRating to fetch.
     */
    where?: ProductRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRatings to fetch.
     */
    orderBy?: ProductRatingOrderByWithRelationInput | ProductRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRatings.
     */
    cursor?: ProductRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRatings.
     */
    distinct?: ProductRatingScalarFieldEnum | ProductRatingScalarFieldEnum[]
  }

  /**
   * ProductRating findMany
   */
  export type ProductRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * Filter, which ProductRatings to fetch.
     */
    where?: ProductRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRatings to fetch.
     */
    orderBy?: ProductRatingOrderByWithRelationInput | ProductRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductRatings.
     */
    cursor?: ProductRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRatings.
     */
    skip?: number
    distinct?: ProductRatingScalarFieldEnum | ProductRatingScalarFieldEnum[]
  }

  /**
   * ProductRating create
   */
  export type ProductRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductRating.
     */
    data: XOR<ProductRatingCreateInput, ProductRatingUncheckedCreateInput>
  }

  /**
   * ProductRating createMany
   */
  export type ProductRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductRatings.
     */
    data: ProductRatingCreateManyInput | ProductRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductRating update
   */
  export type ProductRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductRating.
     */
    data: XOR<ProductRatingUpdateInput, ProductRatingUncheckedUpdateInput>
    /**
     * Choose, which ProductRating to update.
     */
    where: ProductRatingWhereUniqueInput
  }

  /**
   * ProductRating updateMany
   */
  export type ProductRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductRatings.
     */
    data: XOR<ProductRatingUpdateManyMutationInput, ProductRatingUncheckedUpdateManyInput>
    /**
     * Filter which ProductRatings to update
     */
    where?: ProductRatingWhereInput
  }

  /**
   * ProductRating upsert
   */
  export type ProductRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductRating to update in case it exists.
     */
    where: ProductRatingWhereUniqueInput
    /**
     * In case the ProductRating found by the `where` argument doesn't exist, create a new ProductRating with this data.
     */
    create: XOR<ProductRatingCreateInput, ProductRatingUncheckedCreateInput>
    /**
     * In case the ProductRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductRatingUpdateInput, ProductRatingUncheckedUpdateInput>
  }

  /**
   * ProductRating delete
   */
  export type ProductRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
    /**
     * Filter which ProductRating to delete.
     */
    where: ProductRatingWhereUniqueInput
  }

  /**
   * ProductRating deleteMany
   */
  export type ProductRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRatings to delete
     */
    where?: ProductRatingWhereInput
  }

  /**
   * ProductRating without action
   */
  export type ProductRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRating
     */
    select?: ProductRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRatingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    password: 'password',
    phone_number: 'phone_number',
    role: 'role',
    avatar: 'avatar',
    resetPasswordToken: 'resetPasswordToken',
    resetPasswordTokenExpiry: 'resetPasswordTokenExpiry',
    refreshToken: 'refreshToken',
    otp: 'otp',
    otpExpiresAt: 'otpExpiresAt',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    category_name: 'category_name',
    category_icon: 'category_icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const DistrictScalarFieldEnum: {
    id: 'id',
    district_name: 'district_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DistrictScalarFieldEnum = (typeof DistrictScalarFieldEnum)[keyof typeof DistrictScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    venue_name: 'venue_name',
    venue_address: 'venue_address',
    contact_person: 'contact_person',
    phone_number: 'phone_number',
    email: 'email',
    pan_vat_number: 'pan_vat_number',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    address: 'address',
    short_description: 'short_description',
    is_active: 'is_active',
    overall_rating: 'overall_rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    category_id: 'category_id',
    districtId: 'districtId',
    businessId: 'businessId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    start_date: 'start_date',
    end_date: 'end_date',
    start_time: 'start_time',
    end_time: 'end_time',
    is_approved: 'is_approved',
    is_rejected: 'is_rejected',
    userId: 'userId',
    productId: 'productId',
    approved_by_id: 'approved_by_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventTypeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventTypeScalarFieldEnum = (typeof EventTypeScalarFieldEnum)[keyof typeof EventTypeScalarFieldEnum]


  export const EventEventTypeScalarFieldEnum: {
    eventId: 'eventId',
    eventTypeId: 'eventTypeId'
  };

  export type EventEventTypeScalarFieldEnum = (typeof EventEventTypeScalarFieldEnum)[keyof typeof EventEventTypeScalarFieldEnum]


  export const MultimediaScalarFieldEnum: {
    id: 'id',
    multimedia_name: 'multimedia_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type MultimediaScalarFieldEnum = (typeof MultimediaScalarFieldEnum)[keyof typeof MultimediaScalarFieldEnum]


  export const MusicalScalarFieldEnum: {
    id: 'id',
    instrument_name: 'instrument_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type MusicalScalarFieldEnum = (typeof MusicalScalarFieldEnum)[keyof typeof MusicalScalarFieldEnum]


  export const LuxuryScalarFieldEnum: {
    id: 'id',
    luxury_name: 'luxury_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type LuxuryScalarFieldEnum = (typeof LuxuryScalarFieldEnum)[keyof typeof LuxuryScalarFieldEnum]


  export const EntertainmentScalarFieldEnum: {
    id: 'id',
    entertainment_name: 'entertainment_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type EntertainmentScalarFieldEnum = (typeof EntertainmentScalarFieldEnum)[keyof typeof EntertainmentScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    meeting_name: 'meeting_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId',
    eventId: 'eventId'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const BeautyDecorScalarFieldEnum: {
    id: 'id',
    beauty_name: 'beauty_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type BeautyDecorScalarFieldEnum = (typeof BeautyDecorScalarFieldEnum)[keyof typeof BeautyDecorScalarFieldEnum]


  export const AdventureScalarFieldEnum: {
    id: 'id',
    adventure_name: 'adventure_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type AdventureScalarFieldEnum = (typeof AdventureScalarFieldEnum)[keyof typeof AdventureScalarFieldEnum]


  export const PartyPalaceScalarFieldEnum: {
    id: 'id',
    partypalace_name: 'partypalace_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type PartyPalaceScalarFieldEnum = (typeof PartyPalaceScalarFieldEnum)[keyof typeof PartyPalaceScalarFieldEnum]


  export const CateringTentScalarFieldEnum: {
    id: 'id',
    catering_name: 'catering_name',
    price: 'price',
    offerPrice: 'offerPrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type CateringTentScalarFieldEnum = (typeof CateringTentScalarFieldEnum)[keyof typeof CateringTentScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    business_name: 'business_name',
    email: 'email',
    address: 'address',
    phone_number: 'phone_number',
    another_phone_number: 'another_phone_number',
    contact_person: 'contact_person',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    short_description: 'short_description',
    image: 'image',
    description: 'description',
    is_approved: 'is_approved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId',
    approved_by_id: 'approved_by_id'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const ProductRatingScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    review: 'review',
    userId: 'userId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductRatingScalarFieldEnum = (typeof ProductRatingScalarFieldEnum)[keyof typeof ProductRatingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstname?: StringFilter<"User"> | string
    lastname?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    events_booked?: EventListRelationFilter
    blogs_approved?: BlogListRelationFilter
    blogs_author?: BlogListRelationFilter
    ratings?: ProductRatingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordTokenExpiry?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    events_booked?: EventOrderByRelationAggregateInput
    blogs_approved?: BlogOrderByRelationAggregateInput
    blogs_author?: BlogOrderByRelationAggregateInput
    ratings?: ProductRatingOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone_number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstname?: StringFilter<"User"> | string
    lastname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    events_booked?: EventListRelationFilter
    blogs_approved?: BlogListRelationFilter
    blogs_author?: BlogListRelationFilter
    ratings?: ProductRatingListRelationFilter
  }, "id" | "email" | "phone_number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordTokenExpiry?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpiresAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstname?: StringWithAggregatesFilter<"User"> | string
    lastname?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    otp?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    category_name?: StringFilter<"Category"> | string
    category_icon?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    category_name?: SortOrder
    category_icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    category_name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    category_icon?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "category_name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    category_name?: SortOrder
    category_icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    category_name?: StringWithAggregatesFilter<"Category"> | string
    category_icon?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type DistrictWhereInput = {
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    id?: IntFilter<"District"> | number
    district_name?: StringFilter<"District"> | string
    createdAt?: DateTimeFilter<"District"> | Date | string
    updatedAt?: DateTimeFilter<"District"> | Date | string
    products?: ProductListRelationFilter
  }

  export type DistrictOrderByWithRelationInput = {
    id?: SortOrder
    district_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type DistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    district_name?: string
    AND?: DistrictWhereInput | DistrictWhereInput[]
    OR?: DistrictWhereInput[]
    NOT?: DistrictWhereInput | DistrictWhereInput[]
    createdAt?: DateTimeFilter<"District"> | Date | string
    updatedAt?: DateTimeFilter<"District"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "district_name">

  export type DistrictOrderByWithAggregationInput = {
    id?: SortOrder
    district_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DistrictCountOrderByAggregateInput
    _avg?: DistrictAvgOrderByAggregateInput
    _max?: DistrictMaxOrderByAggregateInput
    _min?: DistrictMinOrderByAggregateInput
    _sum?: DistrictSumOrderByAggregateInput
  }

  export type DistrictScalarWhereWithAggregatesInput = {
    AND?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    OR?: DistrictScalarWhereWithAggregatesInput[]
    NOT?: DistrictScalarWhereWithAggregatesInput | DistrictScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"District"> | number
    district_name?: StringWithAggregatesFilter<"District"> | string
    createdAt?: DateTimeWithAggregatesFilter<"District"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"District"> | Date | string
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: IntFilter<"Venue"> | number
    venue_name?: StringFilter<"Venue"> | string
    venue_address?: StringFilter<"Venue"> | string
    contact_person?: StringFilter<"Venue"> | string
    phone_number?: StringFilter<"Venue"> | string
    email?: StringFilter<"Venue"> | string
    pan_vat_number?: StringNullableFilter<"Venue"> | string | null
    active?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    products?: ProductListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    contact_person?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    pan_vat_number?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    venue_name?: string
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    venue_address?: StringFilter<"Venue"> | string
    contact_person?: StringFilter<"Venue"> | string
    phone_number?: StringFilter<"Venue"> | string
    email?: StringFilter<"Venue"> | string
    pan_vat_number?: StringNullableFilter<"Venue"> | string | null
    active?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "venue_name">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    contact_person?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    pan_vat_number?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Venue"> | number
    venue_name?: StringWithAggregatesFilter<"Venue"> | string
    venue_address?: StringWithAggregatesFilter<"Venue"> | string
    contact_person?: StringWithAggregatesFilter<"Venue"> | string
    phone_number?: StringWithAggregatesFilter<"Venue"> | string
    email?: StringWithAggregatesFilter<"Venue"> | string
    pan_vat_number?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    active?: BoolWithAggregatesFilter<"Venue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    address?: StringFilter<"Product"> | string
    short_description?: StringNullableFilter<"Product"> | string | null
    is_active?: BoolFilter<"Product"> | boolean
    overall_rating?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category_id?: IntFilter<"Product"> | number
    districtId?: IntFilter<"Product"> | number
    businessId?: IntFilter<"Product"> | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    multimedia?: MultimediaListRelationFilter
    entertainment?: EntertainmentListRelationFilter
    musical?: MusicalListRelationFilter
    luxury?: LuxuryListRelationFilter
    meeting?: MeetingListRelationFilter
    beautydecor?: BeautyDecorListRelationFilter
    adventure?: AdventureListRelationFilter
    partypalace?: PartyPalaceListRelationFilter
    cateringtent?: CateringTentListRelationFilter
    product_image?: ProductImageListRelationFilter
    event?: EventListRelationFilter
    ratings?: ProductRatingListRelationFilter
    District?: XOR<DistrictRelationFilter, DistrictWhereInput>
    Venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    short_description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    overall_rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    multimedia?: MultimediaOrderByRelationAggregateInput
    entertainment?: EntertainmentOrderByRelationAggregateInput
    musical?: MusicalOrderByRelationAggregateInput
    luxury?: LuxuryOrderByRelationAggregateInput
    meeting?: MeetingOrderByRelationAggregateInput
    beautydecor?: BeautyDecorOrderByRelationAggregateInput
    adventure?: AdventureOrderByRelationAggregateInput
    partypalace?: PartyPalaceOrderByRelationAggregateInput
    cateringtent?: CateringTentOrderByRelationAggregateInput
    product_image?: ProductImageOrderByRelationAggregateInput
    event?: EventOrderByRelationAggregateInput
    ratings?: ProductRatingOrderByRelationAggregateInput
    District?: DistrictOrderByWithRelationInput
    Venue?: VenueOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    address?: StringFilter<"Product"> | string
    short_description?: StringNullableFilter<"Product"> | string | null
    is_active?: BoolFilter<"Product"> | boolean
    overall_rating?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category_id?: IntFilter<"Product"> | number
    districtId?: IntFilter<"Product"> | number
    businessId?: IntFilter<"Product"> | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    multimedia?: MultimediaListRelationFilter
    entertainment?: EntertainmentListRelationFilter
    musical?: MusicalListRelationFilter
    luxury?: LuxuryListRelationFilter
    meeting?: MeetingListRelationFilter
    beautydecor?: BeautyDecorListRelationFilter
    adventure?: AdventureListRelationFilter
    partypalace?: PartyPalaceListRelationFilter
    cateringtent?: CateringTentListRelationFilter
    product_image?: ProductImageListRelationFilter
    event?: EventListRelationFilter
    ratings?: ProductRatingListRelationFilter
    District?: XOR<DistrictRelationFilter, DistrictWhereInput>
    Venue?: XOR<VenueRelationFilter, VenueWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    short_description?: SortOrderInput | SortOrder
    is_active?: SortOrder
    overall_rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    address?: StringWithAggregatesFilter<"Product"> | string
    short_description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    is_active?: BoolWithAggregatesFilter<"Product"> | boolean
    overall_rating?: FloatWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    category_id?: IntWithAggregatesFilter<"Product"> | number
    districtId?: IntWithAggregatesFilter<"Product"> | number
    businessId?: IntWithAggregatesFilter<"Product"> | number
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: IntFilter<"Event"> | number
    start_date?: DateTimeFilter<"Event"> | Date | string
    end_date?: DateTimeFilter<"Event"> | Date | string
    start_time?: DateTimeNullableFilter<"Event"> | Date | string | null
    end_time?: DateTimeNullableFilter<"Event"> | Date | string | null
    is_approved?: BoolFilter<"Event"> | boolean
    is_rejected?: BoolFilter<"Event"> | boolean
    userId?: IntFilter<"Event"> | number
    productId?: IntFilter<"Event"> | number
    approved_by_id?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
    PartyPalace?: PartyPalaceListRelationFilter
    CateringTent?: CateringTentListRelationFilter
    Adventure?: AdventureListRelationFilter
    BeautyDecor?: BeautyDecorListRelationFilter
    Meeting?: MeetingListRelationFilter
    Entertainment?: EntertainmentListRelationFilter
    Luxury?: LuxuryListRelationFilter
    Musical?: MusicalListRelationFilter
    Multimedia?: MultimediaListRelationFilter
    EventTypes?: EventEventTypeListRelationFilter
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    is_approved?: SortOrder
    is_rejected?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Product?: ProductOrderByWithRelationInput
    PartyPalace?: PartyPalaceOrderByRelationAggregateInput
    CateringTent?: CateringTentOrderByRelationAggregateInput
    Adventure?: AdventureOrderByRelationAggregateInput
    BeautyDecor?: BeautyDecorOrderByRelationAggregateInput
    Meeting?: MeetingOrderByRelationAggregateInput
    Entertainment?: EntertainmentOrderByRelationAggregateInput
    Luxury?: LuxuryOrderByRelationAggregateInput
    Musical?: MusicalOrderByRelationAggregateInput
    Multimedia?: MultimediaOrderByRelationAggregateInput
    EventTypes?: EventEventTypeOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    start_date?: DateTimeFilter<"Event"> | Date | string
    end_date?: DateTimeFilter<"Event"> | Date | string
    start_time?: DateTimeNullableFilter<"Event"> | Date | string | null
    end_time?: DateTimeNullableFilter<"Event"> | Date | string | null
    is_approved?: BoolFilter<"Event"> | boolean
    is_rejected?: BoolFilter<"Event"> | boolean
    userId?: IntFilter<"Event"> | number
    productId?: IntFilter<"Event"> | number
    approved_by_id?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
    PartyPalace?: PartyPalaceListRelationFilter
    CateringTent?: CateringTentListRelationFilter
    Adventure?: AdventureListRelationFilter
    BeautyDecor?: BeautyDecorListRelationFilter
    Meeting?: MeetingListRelationFilter
    Entertainment?: EntertainmentListRelationFilter
    Luxury?: LuxuryListRelationFilter
    Musical?: MusicalListRelationFilter
    Multimedia?: MultimediaListRelationFilter
    EventTypes?: EventEventTypeListRelationFilter
    User?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    is_approved?: SortOrder
    is_rejected?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Event"> | number
    start_date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    start_time?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    is_approved?: BoolWithAggregatesFilter<"Event"> | boolean
    is_rejected?: BoolWithAggregatesFilter<"Event"> | boolean
    userId?: IntWithAggregatesFilter<"Event"> | number
    productId?: IntWithAggregatesFilter<"Event"> | number
    approved_by_id?: IntNullableWithAggregatesFilter<"Event"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventTypeWhereInput = {
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    id?: IntFilter<"EventType"> | number
    title?: StringFilter<"EventType"> | string
    createdAt?: DateTimeFilter<"EventType"> | Date | string
    updatedAt?: DateTimeFilter<"EventType"> | Date | string
    Events?: EventEventTypeListRelationFilter
  }

  export type EventTypeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Events?: EventEventTypeOrderByRelationAggregateInput
  }

  export type EventTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    title?: StringFilter<"EventType"> | string
    createdAt?: DateTimeFilter<"EventType"> | Date | string
    updatedAt?: DateTimeFilter<"EventType"> | Date | string
    Events?: EventEventTypeListRelationFilter
  }, "id">

  export type EventTypeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventTypeCountOrderByAggregateInput
    _avg?: EventTypeAvgOrderByAggregateInput
    _max?: EventTypeMaxOrderByAggregateInput
    _min?: EventTypeMinOrderByAggregateInput
    _sum?: EventTypeSumOrderByAggregateInput
  }

  export type EventTypeScalarWhereWithAggregatesInput = {
    AND?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    OR?: EventTypeScalarWhereWithAggregatesInput[]
    NOT?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EventType"> | number
    title?: StringWithAggregatesFilter<"EventType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventType"> | Date | string
  }

  export type EventEventTypeWhereInput = {
    AND?: EventEventTypeWhereInput | EventEventTypeWhereInput[]
    OR?: EventEventTypeWhereInput[]
    NOT?: EventEventTypeWhereInput | EventEventTypeWhereInput[]
    eventId?: IntFilter<"EventEventType"> | number
    eventTypeId?: IntFilter<"EventEventType"> | number
    Event?: XOR<EventRelationFilter, EventWhereInput>
    EventType?: XOR<EventTypeRelationFilter, EventTypeWhereInput>
  }

  export type EventEventTypeOrderByWithRelationInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
    Event?: EventOrderByWithRelationInput
    EventType?: EventTypeOrderByWithRelationInput
  }

  export type EventEventTypeWhereUniqueInput = Prisma.AtLeast<{
    eventId_eventTypeId?: EventEventTypeEventIdEventTypeIdCompoundUniqueInput
    AND?: EventEventTypeWhereInput | EventEventTypeWhereInput[]
    OR?: EventEventTypeWhereInput[]
    NOT?: EventEventTypeWhereInput | EventEventTypeWhereInput[]
    eventId?: IntFilter<"EventEventType"> | number
    eventTypeId?: IntFilter<"EventEventType"> | number
    Event?: XOR<EventRelationFilter, EventWhereInput>
    EventType?: XOR<EventTypeRelationFilter, EventTypeWhereInput>
  }, "eventId_eventTypeId">

  export type EventEventTypeOrderByWithAggregationInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
    _count?: EventEventTypeCountOrderByAggregateInput
    _avg?: EventEventTypeAvgOrderByAggregateInput
    _max?: EventEventTypeMaxOrderByAggregateInput
    _min?: EventEventTypeMinOrderByAggregateInput
    _sum?: EventEventTypeSumOrderByAggregateInput
  }

  export type EventEventTypeScalarWhereWithAggregatesInput = {
    AND?: EventEventTypeScalarWhereWithAggregatesInput | EventEventTypeScalarWhereWithAggregatesInput[]
    OR?: EventEventTypeScalarWhereWithAggregatesInput[]
    NOT?: EventEventTypeScalarWhereWithAggregatesInput | EventEventTypeScalarWhereWithAggregatesInput[]
    eventId?: IntWithAggregatesFilter<"EventEventType"> | number
    eventTypeId?: IntWithAggregatesFilter<"EventEventType"> | number
  }

  export type MultimediaWhereInput = {
    AND?: MultimediaWhereInput | MultimediaWhereInput[]
    OR?: MultimediaWhereInput[]
    NOT?: MultimediaWhereInput | MultimediaWhereInput[]
    id?: IntFilter<"Multimedia"> | number
    multimedia_name?: StringFilter<"Multimedia"> | string
    price?: IntFilter<"Multimedia"> | number
    offerPrice?: IntNullableFilter<"Multimedia"> | number | null
    description?: StringNullableFilter<"Multimedia"> | string | null
    createdAt?: DateTimeFilter<"Multimedia"> | Date | string
    updatedAt?: DateTimeFilter<"Multimedia"> | Date | string
    productId?: IntNullableFilter<"Multimedia"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type MultimediaOrderByWithRelationInput = {
    id?: SortOrder
    multimedia_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type MultimediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MultimediaWhereInput | MultimediaWhereInput[]
    OR?: MultimediaWhereInput[]
    NOT?: MultimediaWhereInput | MultimediaWhereInput[]
    multimedia_name?: StringFilter<"Multimedia"> | string
    price?: IntFilter<"Multimedia"> | number
    offerPrice?: IntNullableFilter<"Multimedia"> | number | null
    description?: StringNullableFilter<"Multimedia"> | string | null
    createdAt?: DateTimeFilter<"Multimedia"> | Date | string
    updatedAt?: DateTimeFilter<"Multimedia"> | Date | string
    productId?: IntNullableFilter<"Multimedia"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type MultimediaOrderByWithAggregationInput = {
    id?: SortOrder
    multimedia_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: MultimediaCountOrderByAggregateInput
    _avg?: MultimediaAvgOrderByAggregateInput
    _max?: MultimediaMaxOrderByAggregateInput
    _min?: MultimediaMinOrderByAggregateInput
    _sum?: MultimediaSumOrderByAggregateInput
  }

  export type MultimediaScalarWhereWithAggregatesInput = {
    AND?: MultimediaScalarWhereWithAggregatesInput | MultimediaScalarWhereWithAggregatesInput[]
    OR?: MultimediaScalarWhereWithAggregatesInput[]
    NOT?: MultimediaScalarWhereWithAggregatesInput | MultimediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Multimedia"> | number
    multimedia_name?: StringWithAggregatesFilter<"Multimedia"> | string
    price?: IntWithAggregatesFilter<"Multimedia"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"Multimedia"> | number | null
    description?: StringNullableWithAggregatesFilter<"Multimedia"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Multimedia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Multimedia"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"Multimedia"> | number | null
  }

  export type MusicalWhereInput = {
    AND?: MusicalWhereInput | MusicalWhereInput[]
    OR?: MusicalWhereInput[]
    NOT?: MusicalWhereInput | MusicalWhereInput[]
    id?: IntFilter<"Musical"> | number
    instrument_name?: StringFilter<"Musical"> | string
    price?: IntFilter<"Musical"> | number
    offerPrice?: IntNullableFilter<"Musical"> | number | null
    description?: StringNullableFilter<"Musical"> | string | null
    createdAt?: DateTimeFilter<"Musical"> | Date | string
    updatedAt?: DateTimeFilter<"Musical"> | Date | string
    productId?: IntNullableFilter<"Musical"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type MusicalOrderByWithRelationInput = {
    id?: SortOrder
    instrument_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type MusicalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MusicalWhereInput | MusicalWhereInput[]
    OR?: MusicalWhereInput[]
    NOT?: MusicalWhereInput | MusicalWhereInput[]
    instrument_name?: StringFilter<"Musical"> | string
    price?: IntFilter<"Musical"> | number
    offerPrice?: IntNullableFilter<"Musical"> | number | null
    description?: StringNullableFilter<"Musical"> | string | null
    createdAt?: DateTimeFilter<"Musical"> | Date | string
    updatedAt?: DateTimeFilter<"Musical"> | Date | string
    productId?: IntNullableFilter<"Musical"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type MusicalOrderByWithAggregationInput = {
    id?: SortOrder
    instrument_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: MusicalCountOrderByAggregateInput
    _avg?: MusicalAvgOrderByAggregateInput
    _max?: MusicalMaxOrderByAggregateInput
    _min?: MusicalMinOrderByAggregateInput
    _sum?: MusicalSumOrderByAggregateInput
  }

  export type MusicalScalarWhereWithAggregatesInput = {
    AND?: MusicalScalarWhereWithAggregatesInput | MusicalScalarWhereWithAggregatesInput[]
    OR?: MusicalScalarWhereWithAggregatesInput[]
    NOT?: MusicalScalarWhereWithAggregatesInput | MusicalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Musical"> | number
    instrument_name?: StringWithAggregatesFilter<"Musical"> | string
    price?: IntWithAggregatesFilter<"Musical"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"Musical"> | number | null
    description?: StringNullableWithAggregatesFilter<"Musical"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Musical"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Musical"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"Musical"> | number | null
  }

  export type LuxuryWhereInput = {
    AND?: LuxuryWhereInput | LuxuryWhereInput[]
    OR?: LuxuryWhereInput[]
    NOT?: LuxuryWhereInput | LuxuryWhereInput[]
    id?: IntFilter<"Luxury"> | number
    luxury_name?: StringFilter<"Luxury"> | string
    price?: IntFilter<"Luxury"> | number
    offerPrice?: IntNullableFilter<"Luxury"> | number | null
    description?: StringNullableFilter<"Luxury"> | string | null
    createdAt?: DateTimeFilter<"Luxury"> | Date | string
    updatedAt?: DateTimeFilter<"Luxury"> | Date | string
    productId?: IntNullableFilter<"Luxury"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type LuxuryOrderByWithRelationInput = {
    id?: SortOrder
    luxury_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type LuxuryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LuxuryWhereInput | LuxuryWhereInput[]
    OR?: LuxuryWhereInput[]
    NOT?: LuxuryWhereInput | LuxuryWhereInput[]
    luxury_name?: StringFilter<"Luxury"> | string
    price?: IntFilter<"Luxury"> | number
    offerPrice?: IntNullableFilter<"Luxury"> | number | null
    description?: StringNullableFilter<"Luxury"> | string | null
    createdAt?: DateTimeFilter<"Luxury"> | Date | string
    updatedAt?: DateTimeFilter<"Luxury"> | Date | string
    productId?: IntNullableFilter<"Luxury"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type LuxuryOrderByWithAggregationInput = {
    id?: SortOrder
    luxury_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: LuxuryCountOrderByAggregateInput
    _avg?: LuxuryAvgOrderByAggregateInput
    _max?: LuxuryMaxOrderByAggregateInput
    _min?: LuxuryMinOrderByAggregateInput
    _sum?: LuxurySumOrderByAggregateInput
  }

  export type LuxuryScalarWhereWithAggregatesInput = {
    AND?: LuxuryScalarWhereWithAggregatesInput | LuxuryScalarWhereWithAggregatesInput[]
    OR?: LuxuryScalarWhereWithAggregatesInput[]
    NOT?: LuxuryScalarWhereWithAggregatesInput | LuxuryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Luxury"> | number
    luxury_name?: StringWithAggregatesFilter<"Luxury"> | string
    price?: IntWithAggregatesFilter<"Luxury"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"Luxury"> | number | null
    description?: StringNullableWithAggregatesFilter<"Luxury"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Luxury"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Luxury"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"Luxury"> | number | null
  }

  export type EntertainmentWhereInput = {
    AND?: EntertainmentWhereInput | EntertainmentWhereInput[]
    OR?: EntertainmentWhereInput[]
    NOT?: EntertainmentWhereInput | EntertainmentWhereInput[]
    id?: IntFilter<"Entertainment"> | number
    entertainment_name?: StringFilter<"Entertainment"> | string
    price?: IntFilter<"Entertainment"> | number
    offerPrice?: IntNullableFilter<"Entertainment"> | number | null
    description?: StringNullableFilter<"Entertainment"> | string | null
    createdAt?: DateTimeFilter<"Entertainment"> | Date | string
    updatedAt?: DateTimeFilter<"Entertainment"> | Date | string
    productId?: IntNullableFilter<"Entertainment"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type EntertainmentOrderByWithRelationInput = {
    id?: SortOrder
    entertainment_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type EntertainmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntertainmentWhereInput | EntertainmentWhereInput[]
    OR?: EntertainmentWhereInput[]
    NOT?: EntertainmentWhereInput | EntertainmentWhereInput[]
    entertainment_name?: StringFilter<"Entertainment"> | string
    price?: IntFilter<"Entertainment"> | number
    offerPrice?: IntNullableFilter<"Entertainment"> | number | null
    description?: StringNullableFilter<"Entertainment"> | string | null
    createdAt?: DateTimeFilter<"Entertainment"> | Date | string
    updatedAt?: DateTimeFilter<"Entertainment"> | Date | string
    productId?: IntNullableFilter<"Entertainment"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type EntertainmentOrderByWithAggregationInput = {
    id?: SortOrder
    entertainment_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: EntertainmentCountOrderByAggregateInput
    _avg?: EntertainmentAvgOrderByAggregateInput
    _max?: EntertainmentMaxOrderByAggregateInput
    _min?: EntertainmentMinOrderByAggregateInput
    _sum?: EntertainmentSumOrderByAggregateInput
  }

  export type EntertainmentScalarWhereWithAggregatesInput = {
    AND?: EntertainmentScalarWhereWithAggregatesInput | EntertainmentScalarWhereWithAggregatesInput[]
    OR?: EntertainmentScalarWhereWithAggregatesInput[]
    NOT?: EntertainmentScalarWhereWithAggregatesInput | EntertainmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entertainment"> | number
    entertainment_name?: StringWithAggregatesFilter<"Entertainment"> | string
    price?: IntWithAggregatesFilter<"Entertainment"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"Entertainment"> | number | null
    description?: StringNullableWithAggregatesFilter<"Entertainment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Entertainment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Entertainment"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"Entertainment"> | number | null
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: IntFilter<"Meeting"> | number
    meeting_name?: StringFilter<"Meeting"> | string
    price?: IntFilter<"Meeting"> | number
    offerPrice?: IntNullableFilter<"Meeting"> | number | null
    description?: StringNullableFilter<"Meeting"> | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    productId?: IntNullableFilter<"Meeting"> | number | null
    eventId?: IntFilter<"Meeting"> | number
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    meeting_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    eventId?: SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByWithRelationInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    meeting_name?: StringFilter<"Meeting"> | string
    price?: IntFilter<"Meeting"> | number
    offerPrice?: IntNullableFilter<"Meeting"> | number | null
    description?: StringNullableFilter<"Meeting"> | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    productId?: IntNullableFilter<"Meeting"> | number | null
    eventId?: IntFilter<"Meeting"> | number
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: XOR<EventRelationFilter, EventWhereInput>
  }, "id">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    meeting_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    eventId?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Meeting"> | number
    meeting_name?: StringWithAggregatesFilter<"Meeting"> | string
    price?: IntWithAggregatesFilter<"Meeting"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"Meeting"> | number | null
    description?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"Meeting"> | number | null
    eventId?: IntWithAggregatesFilter<"Meeting"> | number
  }

  export type BeautyDecorWhereInput = {
    AND?: BeautyDecorWhereInput | BeautyDecorWhereInput[]
    OR?: BeautyDecorWhereInput[]
    NOT?: BeautyDecorWhereInput | BeautyDecorWhereInput[]
    id?: IntFilter<"BeautyDecor"> | number
    beauty_name?: StringFilter<"BeautyDecor"> | string
    price?: IntFilter<"BeautyDecor"> | number
    offerPrice?: IntNullableFilter<"BeautyDecor"> | number | null
    description?: StringNullableFilter<"BeautyDecor"> | string | null
    createdAt?: DateTimeFilter<"BeautyDecor"> | Date | string
    updatedAt?: DateTimeFilter<"BeautyDecor"> | Date | string
    productId?: IntNullableFilter<"BeautyDecor"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type BeautyDecorOrderByWithRelationInput = {
    id?: SortOrder
    beauty_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type BeautyDecorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BeautyDecorWhereInput | BeautyDecorWhereInput[]
    OR?: BeautyDecorWhereInput[]
    NOT?: BeautyDecorWhereInput | BeautyDecorWhereInput[]
    beauty_name?: StringFilter<"BeautyDecor"> | string
    price?: IntFilter<"BeautyDecor"> | number
    offerPrice?: IntNullableFilter<"BeautyDecor"> | number | null
    description?: StringNullableFilter<"BeautyDecor"> | string | null
    createdAt?: DateTimeFilter<"BeautyDecor"> | Date | string
    updatedAt?: DateTimeFilter<"BeautyDecor"> | Date | string
    productId?: IntNullableFilter<"BeautyDecor"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type BeautyDecorOrderByWithAggregationInput = {
    id?: SortOrder
    beauty_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: BeautyDecorCountOrderByAggregateInput
    _avg?: BeautyDecorAvgOrderByAggregateInput
    _max?: BeautyDecorMaxOrderByAggregateInput
    _min?: BeautyDecorMinOrderByAggregateInput
    _sum?: BeautyDecorSumOrderByAggregateInput
  }

  export type BeautyDecorScalarWhereWithAggregatesInput = {
    AND?: BeautyDecorScalarWhereWithAggregatesInput | BeautyDecorScalarWhereWithAggregatesInput[]
    OR?: BeautyDecorScalarWhereWithAggregatesInput[]
    NOT?: BeautyDecorScalarWhereWithAggregatesInput | BeautyDecorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BeautyDecor"> | number
    beauty_name?: StringWithAggregatesFilter<"BeautyDecor"> | string
    price?: IntWithAggregatesFilter<"BeautyDecor"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"BeautyDecor"> | number | null
    description?: StringNullableWithAggregatesFilter<"BeautyDecor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BeautyDecor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BeautyDecor"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"BeautyDecor"> | number | null
  }

  export type AdventureWhereInput = {
    AND?: AdventureWhereInput | AdventureWhereInput[]
    OR?: AdventureWhereInput[]
    NOT?: AdventureWhereInput | AdventureWhereInput[]
    id?: IntFilter<"Adventure"> | number
    adventure_name?: StringFilter<"Adventure"> | string
    price?: IntFilter<"Adventure"> | number
    offerPrice?: IntNullableFilter<"Adventure"> | number | null
    description?: StringNullableFilter<"Adventure"> | string | null
    createdAt?: DateTimeFilter<"Adventure"> | Date | string
    updatedAt?: DateTimeFilter<"Adventure"> | Date | string
    productId?: IntNullableFilter<"Adventure"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type AdventureOrderByWithRelationInput = {
    id?: SortOrder
    adventure_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type AdventureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdventureWhereInput | AdventureWhereInput[]
    OR?: AdventureWhereInput[]
    NOT?: AdventureWhereInput | AdventureWhereInput[]
    adventure_name?: StringFilter<"Adventure"> | string
    price?: IntFilter<"Adventure"> | number
    offerPrice?: IntNullableFilter<"Adventure"> | number | null
    description?: StringNullableFilter<"Adventure"> | string | null
    createdAt?: DateTimeFilter<"Adventure"> | Date | string
    updatedAt?: DateTimeFilter<"Adventure"> | Date | string
    productId?: IntNullableFilter<"Adventure"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type AdventureOrderByWithAggregationInput = {
    id?: SortOrder
    adventure_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: AdventureCountOrderByAggregateInput
    _avg?: AdventureAvgOrderByAggregateInput
    _max?: AdventureMaxOrderByAggregateInput
    _min?: AdventureMinOrderByAggregateInput
    _sum?: AdventureSumOrderByAggregateInput
  }

  export type AdventureScalarWhereWithAggregatesInput = {
    AND?: AdventureScalarWhereWithAggregatesInput | AdventureScalarWhereWithAggregatesInput[]
    OR?: AdventureScalarWhereWithAggregatesInput[]
    NOT?: AdventureScalarWhereWithAggregatesInput | AdventureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Adventure"> | number
    adventure_name?: StringWithAggregatesFilter<"Adventure"> | string
    price?: IntWithAggregatesFilter<"Adventure"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"Adventure"> | number | null
    description?: StringNullableWithAggregatesFilter<"Adventure"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Adventure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Adventure"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"Adventure"> | number | null
  }

  export type PartyPalaceWhereInput = {
    AND?: PartyPalaceWhereInput | PartyPalaceWhereInput[]
    OR?: PartyPalaceWhereInput[]
    NOT?: PartyPalaceWhereInput | PartyPalaceWhereInput[]
    id?: IntFilter<"PartyPalace"> | number
    partypalace_name?: StringFilter<"PartyPalace"> | string
    price?: IntFilter<"PartyPalace"> | number
    offerPrice?: IntNullableFilter<"PartyPalace"> | number | null
    description?: StringNullableFilter<"PartyPalace"> | string | null
    createdAt?: DateTimeFilter<"PartyPalace"> | Date | string
    updatedAt?: DateTimeFilter<"PartyPalace"> | Date | string
    productId?: IntNullableFilter<"PartyPalace"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type PartyPalaceOrderByWithRelationInput = {
    id?: SortOrder
    partypalace_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type PartyPalaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartyPalaceWhereInput | PartyPalaceWhereInput[]
    OR?: PartyPalaceWhereInput[]
    NOT?: PartyPalaceWhereInput | PartyPalaceWhereInput[]
    partypalace_name?: StringFilter<"PartyPalace"> | string
    price?: IntFilter<"PartyPalace"> | number
    offerPrice?: IntNullableFilter<"PartyPalace"> | number | null
    description?: StringNullableFilter<"PartyPalace"> | string | null
    createdAt?: DateTimeFilter<"PartyPalace"> | Date | string
    updatedAt?: DateTimeFilter<"PartyPalace"> | Date | string
    productId?: IntNullableFilter<"PartyPalace"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type PartyPalaceOrderByWithAggregationInput = {
    id?: SortOrder
    partypalace_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: PartyPalaceCountOrderByAggregateInput
    _avg?: PartyPalaceAvgOrderByAggregateInput
    _max?: PartyPalaceMaxOrderByAggregateInput
    _min?: PartyPalaceMinOrderByAggregateInput
    _sum?: PartyPalaceSumOrderByAggregateInput
  }

  export type PartyPalaceScalarWhereWithAggregatesInput = {
    AND?: PartyPalaceScalarWhereWithAggregatesInput | PartyPalaceScalarWhereWithAggregatesInput[]
    OR?: PartyPalaceScalarWhereWithAggregatesInput[]
    NOT?: PartyPalaceScalarWhereWithAggregatesInput | PartyPalaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PartyPalace"> | number
    partypalace_name?: StringWithAggregatesFilter<"PartyPalace"> | string
    price?: IntWithAggregatesFilter<"PartyPalace"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"PartyPalace"> | number | null
    description?: StringNullableWithAggregatesFilter<"PartyPalace"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PartyPalace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PartyPalace"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"PartyPalace"> | number | null
  }

  export type CateringTentWhereInput = {
    AND?: CateringTentWhereInput | CateringTentWhereInput[]
    OR?: CateringTentWhereInput[]
    NOT?: CateringTentWhereInput | CateringTentWhereInput[]
    id?: IntFilter<"CateringTent"> | number
    catering_name?: StringFilter<"CateringTent"> | string
    price?: IntFilter<"CateringTent"> | number
    offerPrice?: IntNullableFilter<"CateringTent"> | number | null
    description?: StringNullableFilter<"CateringTent"> | string | null
    createdAt?: DateTimeFilter<"CateringTent"> | Date | string
    updatedAt?: DateTimeFilter<"CateringTent"> | Date | string
    productId?: IntNullableFilter<"CateringTent"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }

  export type CateringTentOrderByWithRelationInput = {
    id?: SortOrder
    catering_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
  }

  export type CateringTentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CateringTentWhereInput | CateringTentWhereInput[]
    OR?: CateringTentWhereInput[]
    NOT?: CateringTentWhereInput | CateringTentWhereInput[]
    catering_name?: StringFilter<"CateringTent"> | string
    price?: IntFilter<"CateringTent"> | number
    offerPrice?: IntNullableFilter<"CateringTent"> | number | null
    description?: StringNullableFilter<"CateringTent"> | string | null
    createdAt?: DateTimeFilter<"CateringTent"> | Date | string
    updatedAt?: DateTimeFilter<"CateringTent"> | Date | string
    productId?: IntNullableFilter<"CateringTent"> | number | null
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    events?: EventListRelationFilter
  }, "id">

  export type CateringTentOrderByWithAggregationInput = {
    id?: SortOrder
    catering_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: CateringTentCountOrderByAggregateInput
    _avg?: CateringTentAvgOrderByAggregateInput
    _max?: CateringTentMaxOrderByAggregateInput
    _min?: CateringTentMinOrderByAggregateInput
    _sum?: CateringTentSumOrderByAggregateInput
  }

  export type CateringTentScalarWhereWithAggregatesInput = {
    AND?: CateringTentScalarWhereWithAggregatesInput | CateringTentScalarWhereWithAggregatesInput[]
    OR?: CateringTentScalarWhereWithAggregatesInput[]
    NOT?: CateringTentScalarWhereWithAggregatesInput | CateringTentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CateringTent"> | number
    catering_name?: StringWithAggregatesFilter<"CateringTent"> | string
    price?: IntWithAggregatesFilter<"CateringTent"> | number
    offerPrice?: IntNullableWithAggregatesFilter<"CateringTent"> | number | null
    description?: StringNullableWithAggregatesFilter<"CateringTent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CateringTent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CateringTent"> | Date | string
    productId?: IntNullableWithAggregatesFilter<"CateringTent"> | number | null
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    url?: StringFilter<"ProductImage"> | string
    productId?: IntNullableFilter<"ProductImage"> | number | null
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Product?: ProductOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    url?: StringFilter<"ProductImage"> | string
    productId?: IntNullableFilter<"ProductImage"> | number | null
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string
    Product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    productId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductImage"> | number
    url?: StringWithAggregatesFilter<"ProductImage"> | string
    productId?: IntNullableWithAggregatesFilter<"ProductImage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
  }

  export type ContactUsWhereInput = {
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    id?: IntFilter<"ContactUs"> | number
    business_name?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    address?: StringFilter<"ContactUs"> | string
    phone_number?: StringNullableFilter<"ContactUs"> | string | null
    another_phone_number?: StringNullableFilter<"ContactUs"> | string | null
    contact_person?: StringFilter<"ContactUs"> | string
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
  }

  export type ContactUsOrderByWithRelationInput = {
    id?: SortOrder
    business_name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    another_phone_number?: SortOrderInput | SortOrder
    contact_person?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactUsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone_number?: string
    another_phone_number?: string
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    business_name?: StringFilter<"ContactUs"> | string
    address?: StringFilter<"ContactUs"> | string
    contact_person?: StringFilter<"ContactUs"> | string
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
  }, "id" | "email" | "phone_number" | "another_phone_number">

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    business_name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    another_phone_number?: SortOrderInput | SortOrder
    contact_person?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _avg?: ContactUsAvgOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
    _sum?: ContactUsSumOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    OR?: ContactUsScalarWhereWithAggregatesInput[]
    NOT?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactUs"> | number
    business_name?: StringWithAggregatesFilter<"ContactUs"> | string
    email?: StringWithAggregatesFilter<"ContactUs"> | string
    address?: StringWithAggregatesFilter<"ContactUs"> | string
    phone_number?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    another_phone_number?: StringNullableWithAggregatesFilter<"ContactUs"> | string | null
    contact_person?: StringWithAggregatesFilter<"ContactUs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: IntFilter<"Blog"> | number
    title?: StringFilter<"Blog"> | string
    short_description?: StringNullableFilter<"Blog"> | string | null
    image?: StringFilter<"Blog"> | string
    description?: StringFilter<"Blog"> | string
    is_approved?: BoolNullableFilter<"Blog"> | boolean | null
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    authorId?: IntNullableFilter<"Blog"> | number | null
    approved_by_id?: IntNullableFilter<"Blog"> | number | null
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approved_by?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    short_description?: SortOrderInput | SortOrder
    image?: SortOrder
    description?: SortOrder
    is_approved?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrderInput | SortOrder
    approved_by_id?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    approved_by?: UserOrderByWithRelationInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    short_description?: StringNullableFilter<"Blog"> | string | null
    image?: StringFilter<"Blog"> | string
    description?: StringFilter<"Blog"> | string
    is_approved?: BoolNullableFilter<"Blog"> | boolean | null
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    authorId?: IntNullableFilter<"Blog"> | number | null
    approved_by_id?: IntNullableFilter<"Blog"> | number | null
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approved_by?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "title">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    short_description?: SortOrderInput | SortOrder
    image?: SortOrder
    description?: SortOrder
    is_approved?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrderInput | SortOrder
    approved_by_id?: SortOrderInput | SortOrder
    _count?: BlogCountOrderByAggregateInput
    _avg?: BlogAvgOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
    _sum?: BlogSumOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Blog"> | number
    title?: StringWithAggregatesFilter<"Blog"> | string
    short_description?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    image?: StringWithAggregatesFilter<"Blog"> | string
    description?: StringWithAggregatesFilter<"Blog"> | string
    is_approved?: BoolNullableWithAggregatesFilter<"Blog"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    authorId?: IntNullableWithAggregatesFilter<"Blog"> | number | null
    approved_by_id?: IntNullableWithAggregatesFilter<"Blog"> | number | null
  }

  export type ProductRatingWhereInput = {
    AND?: ProductRatingWhereInput | ProductRatingWhereInput[]
    OR?: ProductRatingWhereInput[]
    NOT?: ProductRatingWhereInput | ProductRatingWhereInput[]
    id?: IntFilter<"ProductRating"> | number
    rating?: IntFilter<"ProductRating"> | number
    review?: StringNullableFilter<"ProductRating"> | string | null
    userId?: IntFilter<"ProductRating"> | number
    productId?: IntFilter<"ProductRating"> | number
    createdAt?: DateTimeFilter<"ProductRating"> | Date | string
    updatedAt?: DateTimeFilter<"ProductRating"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductRatingOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
  }

  export type ProductRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_productId?: ProductRatingUserIdProductIdCompoundUniqueInput
    AND?: ProductRatingWhereInput | ProductRatingWhereInput[]
    OR?: ProductRatingWhereInput[]
    NOT?: ProductRatingWhereInput | ProductRatingWhereInput[]
    rating?: IntFilter<"ProductRating"> | number
    review?: StringNullableFilter<"ProductRating"> | string | null
    userId?: IntFilter<"ProductRating"> | number
    productId?: IntFilter<"ProductRating"> | number
    createdAt?: DateTimeFilter<"ProductRating"> | Date | string
    updatedAt?: DateTimeFilter<"ProductRating"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "userId_productId">

  export type ProductRatingOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductRatingCountOrderByAggregateInput
    _avg?: ProductRatingAvgOrderByAggregateInput
    _max?: ProductRatingMaxOrderByAggregateInput
    _min?: ProductRatingMinOrderByAggregateInput
    _sum?: ProductRatingSumOrderByAggregateInput
  }

  export type ProductRatingScalarWhereWithAggregatesInput = {
    AND?: ProductRatingScalarWhereWithAggregatesInput | ProductRatingScalarWhereWithAggregatesInput[]
    OR?: ProductRatingScalarWhereWithAggregatesInput[]
    NOT?: ProductRatingScalarWhereWithAggregatesInput | ProductRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductRating"> | number
    rating?: IntWithAggregatesFilter<"ProductRating"> | number
    review?: StringNullableWithAggregatesFilter<"ProductRating"> | string | null
    userId?: IntWithAggregatesFilter<"ProductRating"> | number
    productId?: IntWithAggregatesFilter<"ProductRating"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductRating"> | Date | string
  }

  export type UserCreateInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventCreateNestedManyWithoutUserInput
    blogs_approved?: BlogCreateNestedManyWithoutApproved_byInput
    blogs_author?: BlogCreateNestedManyWithoutAuthorInput
    ratings?: ProductRatingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventUncheckedCreateNestedManyWithoutUserInput
    blogs_approved?: BlogUncheckedCreateNestedManyWithoutApproved_byInput
    blogs_author?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUpdateManyWithoutUserNestedInput
    blogs_approved?: BlogUpdateManyWithoutApproved_byNestedInput
    blogs_author?: BlogUpdateManyWithoutAuthorNestedInput
    ratings?: ProductRatingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUncheckedUpdateManyWithoutUserNestedInput
    blogs_approved?: BlogUncheckedUpdateManyWithoutApproved_byNestedInput
    blogs_author?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    category_name: string
    category_icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    category_name: string
    category_icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    category_icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    category_icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    category_name: string
    category_icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    category_icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    category_icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictCreateInput = {
    district_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUncheckedCreateInput = {
    id?: number
    district_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutDistrictInput
  }

  export type DistrictUpdateInput = {
    district_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutDistrictNestedInput
  }

  export type DistrictCreateManyInput = {
    id?: number
    district_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistrictUpdateManyMutationInput = {
    district_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueCreateInput = {
    venue_name: string
    venue_address: string
    contact_person: string
    phone_number: string
    email: string
    pan_vat_number?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: number
    venue_name: string
    venue_address: string
    contact_person: string
    phone_number: string
    email: string
    pan_vat_number?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pan_vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pan_vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: number
    venue_name: string
    venue_address: string
    contact_person: string
    phone_number: string
    email: string
    pan_vat_number?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUpdateManyMutationInput = {
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pan_vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pan_vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
  }

  export type ProductUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
  }

  export type EventCreateInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeCreateInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Events?: EventEventTypeCreateNestedManyWithoutEventTypeInput
  }

  export type EventTypeUncheckedCreateInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Events?: EventEventTypeUncheckedCreateNestedManyWithoutEventTypeInput
  }

  export type EventTypeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventEventTypeUpdateManyWithoutEventTypeNestedInput
  }

  export type EventTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Events?: EventEventTypeUncheckedUpdateManyWithoutEventTypeNestedInput
  }

  export type EventTypeCreateManyInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTypeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventEventTypeCreateInput = {
    Event: EventCreateNestedOneWithoutEventTypesInput
    EventType: EventTypeCreateNestedOneWithoutEventsInput
  }

  export type EventEventTypeUncheckedCreateInput = {
    eventId: number
    eventTypeId: number
  }

  export type EventEventTypeUpdateInput = {
    Event?: EventUpdateOneRequiredWithoutEventTypesNestedInput
    EventType?: EventTypeUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventEventTypeUncheckedUpdateInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    eventTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type EventEventTypeCreateManyInput = {
    eventId: number
    eventTypeId: number
  }

  export type EventEventTypeUpdateManyMutationInput = {

  }

  export type EventEventTypeUncheckedUpdateManyInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    eventTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type MultimediaCreateInput = {
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutMultimediaInput
    events?: EventCreateNestedManyWithoutMultimediaInput
  }

  export type MultimediaUncheckedCreateInput = {
    id?: number
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutMultimediaInput
  }

  export type MultimediaUpdateInput = {
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutMultimediaNestedInput
    events?: EventUpdateManyWithoutMultimediaNestedInput
  }

  export type MultimediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutMultimediaNestedInput
  }

  export type MultimediaCreateManyInput = {
    id?: number
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type MultimediaUpdateManyMutationInput = {
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultimediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MusicalCreateInput = {
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutMusicalInput
    events?: EventCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateInput = {
    id?: number
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUpdateInput = {
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutMusicalNestedInput
    events?: EventUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalCreateManyInput = {
    id?: number
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type MusicalUpdateManyMutationInput = {
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MusicalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuxuryCreateInput = {
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutLuxuryInput
    events?: EventCreateNestedManyWithoutLuxuryInput
  }

  export type LuxuryUncheckedCreateInput = {
    id?: number
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutLuxuryInput
  }

  export type LuxuryUpdateInput = {
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutLuxuryNestedInput
    events?: EventUpdateManyWithoutLuxuryNestedInput
  }

  export type LuxuryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutLuxuryNestedInput
  }

  export type LuxuryCreateManyInput = {
    id?: number
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type LuxuryUpdateManyMutationInput = {
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LuxuryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EntertainmentCreateInput = {
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutEntertainmentInput
    events?: EventCreateNestedManyWithoutEntertainmentInput
  }

  export type EntertainmentUncheckedCreateInput = {
    id?: number
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutEntertainmentInput
  }

  export type EntertainmentUpdateInput = {
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutEntertainmentNestedInput
    events?: EventUpdateManyWithoutEntertainmentNestedInput
  }

  export type EntertainmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutEntertainmentNestedInput
  }

  export type EntertainmentCreateManyInput = {
    id?: number
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type EntertainmentUpdateManyMutationInput = {
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntertainmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeetingCreateInput = {
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutMeetingInput
    events: EventCreateNestedOneWithoutMeetingInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: number
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    eventId: number
  }

  export type MeetingUpdateInput = {
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutMeetingNestedInput
    events?: EventUpdateOneRequiredWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type MeetingCreateManyInput = {
    id?: number
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    eventId: number
  }

  export type MeetingUpdateManyMutationInput = {
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type BeautyDecorCreateInput = {
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutBeautydecorInput
    events?: EventCreateNestedManyWithoutBeautyDecorInput
  }

  export type BeautyDecorUncheckedCreateInput = {
    id?: number
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutBeautyDecorInput
  }

  export type BeautyDecorUpdateInput = {
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutBeautydecorNestedInput
    events?: EventUpdateManyWithoutBeautyDecorNestedInput
  }

  export type BeautyDecorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutBeautyDecorNestedInput
  }

  export type BeautyDecorCreateManyInput = {
    id?: number
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type BeautyDecorUpdateManyMutationInput = {
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BeautyDecorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdventureCreateInput = {
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutAdventureInput
    events?: EventCreateNestedManyWithoutAdventureInput
  }

  export type AdventureUncheckedCreateInput = {
    id?: number
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutAdventureInput
  }

  export type AdventureUpdateInput = {
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutAdventureNestedInput
    events?: EventUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureCreateManyInput = {
    id?: number
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type AdventureUpdateManyMutationInput = {
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdventureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartyPalaceCreateInput = {
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutPartypalaceInput
    events?: EventCreateNestedManyWithoutPartyPalaceInput
  }

  export type PartyPalaceUncheckedCreateInput = {
    id?: number
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutPartyPalaceInput
  }

  export type PartyPalaceUpdateInput = {
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutPartypalaceNestedInput
    events?: EventUpdateManyWithoutPartyPalaceNestedInput
  }

  export type PartyPalaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutPartyPalaceNestedInput
  }

  export type PartyPalaceCreateManyInput = {
    id?: number
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type PartyPalaceUpdateManyMutationInput = {
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyPalaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CateringTentCreateInput = {
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutCateringtentInput
    events?: EventCreateNestedManyWithoutCateringTentInput
  }

  export type CateringTentUncheckedCreateInput = {
    id?: number
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
    events?: EventUncheckedCreateNestedManyWithoutCateringTentInput
  }

  export type CateringTentUpdateInput = {
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutCateringtentNestedInput
    events?: EventUpdateManyWithoutCateringTentNestedInput
  }

  export type CateringTentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    events?: EventUncheckedUpdateManyWithoutCateringTentNestedInput
  }

  export type CateringTentCreateManyInput = {
    id?: number
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type CateringTentUpdateManyMutationInput = {
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringTentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductImageCreateInput = {
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutProduct_imageInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    url: string
    productId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutProduct_imageNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateManyInput = {
    id?: number
    url: string
    productId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsCreateInput = {
    business_name: string
    email: string
    address: string
    phone_number?: string | null
    another_phone_number?: string | null
    contact_person: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUsUncheckedCreateInput = {
    id?: number
    business_name: string
    email: string
    address: string
    phone_number?: string | null
    another_phone_number?: string | null
    contact_person: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUsUpdateInput = {
    business_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    another_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    business_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    another_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsCreateManyInput = {
    id?: number
    business_name: string
    email: string
    address: string
    phone_number?: string | null
    another_phone_number?: string | null
    contact_person: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUsUpdateManyMutationInput = {
    business_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    another_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    business_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    another_phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutBlogs_authorInput
    approved_by?: UserCreateNestedOneWithoutBlogs_approvedInput
  }

  export type BlogUncheckedCreateInput = {
    id?: number
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: number | null
    approved_by_id?: number | null
  }

  export type BlogUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutBlogs_authorNestedInput
    approved_by?: UserUpdateOneWithoutBlogs_approvedNestedInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogCreateManyInput = {
    id?: number
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: number | null
    approved_by_id?: number | null
  }

  export type BlogUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductRatingCreateInput = {
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutRatingsInput
    Product: ProductCreateNestedOneWithoutRatingsInput
  }

  export type ProductRatingUncheckedCreateInput = {
    id?: number
    rating: number
    review?: string | null
    userId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRatingUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutRatingsNestedInput
    Product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ProductRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRatingCreateManyInput = {
    id?: number
    rating: number
    review?: string | null
    userId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRatingUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type BlogListRelationFilter = {
    every?: BlogWhereInput
    some?: BlogWhereInput
    none?: BlogWhereInput
  }

  export type ProductRatingListRelationFilter = {
    every?: ProductRatingWhereInput
    some?: ProductRatingWhereInput
    none?: ProductRatingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordTokenExpiry?: SortOrder
    refreshToken?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordTokenExpiry?: SortOrder
    refreshToken?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordTokenExpiry?: SortOrder
    refreshToken?: SortOrder
    otp?: SortOrder
    otpExpiresAt?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    category_icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    category_icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
    category_icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DistrictCountOrderByAggregateInput = {
    id?: SortOrder
    district_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    district_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictMinOrderByAggregateInput = {
    id?: SortOrder
    district_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DistrictSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    contact_person?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    pan_vat_number?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    contact_person?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    pan_vat_number?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    contact_person?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    pan_vat_number?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type MultimediaListRelationFilter = {
    every?: MultimediaWhereInput
    some?: MultimediaWhereInput
    none?: MultimediaWhereInput
  }

  export type EntertainmentListRelationFilter = {
    every?: EntertainmentWhereInput
    some?: EntertainmentWhereInput
    none?: EntertainmentWhereInput
  }

  export type MusicalListRelationFilter = {
    every?: MusicalWhereInput
    some?: MusicalWhereInput
    none?: MusicalWhereInput
  }

  export type LuxuryListRelationFilter = {
    every?: LuxuryWhereInput
    some?: LuxuryWhereInput
    none?: LuxuryWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type BeautyDecorListRelationFilter = {
    every?: BeautyDecorWhereInput
    some?: BeautyDecorWhereInput
    none?: BeautyDecorWhereInput
  }

  export type AdventureListRelationFilter = {
    every?: AdventureWhereInput
    some?: AdventureWhereInput
    none?: AdventureWhereInput
  }

  export type PartyPalaceListRelationFilter = {
    every?: PartyPalaceWhereInput
    some?: PartyPalaceWhereInput
    none?: PartyPalaceWhereInput
  }

  export type CateringTentListRelationFilter = {
    every?: CateringTentWhereInput
    some?: CateringTentWhereInput
    none?: CateringTentWhereInput
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type DistrictRelationFilter = {
    is?: DistrictWhereInput
    isNot?: DistrictWhereInput
  }

  export type VenueRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type MultimediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntertainmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MusicalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LuxuryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BeautyDecorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdventureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartyPalaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CateringTentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    short_description?: SortOrder
    is_active?: SortOrder
    overall_rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    overall_rating?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    short_description?: SortOrder
    is_active?: SortOrder
    overall_rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    short_description?: SortOrder
    is_active?: SortOrder
    overall_rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    overall_rating?: SortOrder
    category_id?: SortOrder
    districtId?: SortOrder
    businessId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type EventEventTypeListRelationFilter = {
    every?: EventEventTypeWhereInput
    some?: EventEventTypeWhereInput
    none?: EventEventTypeWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EventEventTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_approved?: SortOrder
    is_rejected?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_approved?: SortOrder
    is_rejected?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    is_approved?: SortOrder
    is_rejected?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EventTypeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventTypeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventTypeRelationFilter = {
    is?: EventTypeWhereInput
    isNot?: EventTypeWhereInput
  }

  export type EventEventTypeEventIdEventTypeIdCompoundUniqueInput = {
    eventId: number
    eventTypeId: number
  }

  export type EventEventTypeCountOrderByAggregateInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
  }

  export type EventEventTypeAvgOrderByAggregateInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
  }

  export type EventEventTypeMaxOrderByAggregateInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
  }

  export type EventEventTypeMinOrderByAggregateInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
  }

  export type EventEventTypeSumOrderByAggregateInput = {
    eventId?: SortOrder
    eventTypeId?: SortOrder
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type MultimediaCountOrderByAggregateInput = {
    id?: SortOrder
    multimedia_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type MultimediaAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type MultimediaMaxOrderByAggregateInput = {
    id?: SortOrder
    multimedia_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type MultimediaMinOrderByAggregateInput = {
    id?: SortOrder
    multimedia_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type MultimediaSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type MusicalCountOrderByAggregateInput = {
    id?: SortOrder
    instrument_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type MusicalAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type MusicalMaxOrderByAggregateInput = {
    id?: SortOrder
    instrument_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type MusicalMinOrderByAggregateInput = {
    id?: SortOrder
    instrument_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type MusicalSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type LuxuryCountOrderByAggregateInput = {
    id?: SortOrder
    luxury_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type LuxuryAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type LuxuryMaxOrderByAggregateInput = {
    id?: SortOrder
    luxury_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type LuxuryMinOrderByAggregateInput = {
    id?: SortOrder
    luxury_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type LuxurySumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type EntertainmentCountOrderByAggregateInput = {
    id?: SortOrder
    entertainment_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type EntertainmentAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type EntertainmentMaxOrderByAggregateInput = {
    id?: SortOrder
    entertainment_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type EntertainmentMinOrderByAggregateInput = {
    id?: SortOrder
    entertainment_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type EntertainmentSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    meeting_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    eventId?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
    eventId?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    meeting_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    eventId?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    meeting_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    eventId?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
    eventId?: SortOrder
  }

  export type BeautyDecorCountOrderByAggregateInput = {
    id?: SortOrder
    beauty_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type BeautyDecorAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type BeautyDecorMaxOrderByAggregateInput = {
    id?: SortOrder
    beauty_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type BeautyDecorMinOrderByAggregateInput = {
    id?: SortOrder
    beauty_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type BeautyDecorSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type AdventureCountOrderByAggregateInput = {
    id?: SortOrder
    adventure_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type AdventureAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type AdventureMaxOrderByAggregateInput = {
    id?: SortOrder
    adventure_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type AdventureMinOrderByAggregateInput = {
    id?: SortOrder
    adventure_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type AdventureSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type PartyPalaceCountOrderByAggregateInput = {
    id?: SortOrder
    partypalace_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PartyPalaceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type PartyPalaceMaxOrderByAggregateInput = {
    id?: SortOrder
    partypalace_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PartyPalaceMinOrderByAggregateInput = {
    id?: SortOrder
    partypalace_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PartyPalaceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type CateringTentCountOrderByAggregateInput = {
    id?: SortOrder
    catering_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type CateringTentAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type CateringTentMaxOrderByAggregateInput = {
    id?: SortOrder
    catering_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type CateringTentMinOrderByAggregateInput = {
    id?: SortOrder
    catering_name?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type CateringTentSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    business_name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    another_phone_number?: SortOrder
    contact_person?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactUsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    business_name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    another_phone_number?: SortOrder
    contact_person?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    business_name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    another_phone_number?: SortOrder
    contact_person?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactUsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    image?: SortOrder
    description?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type BlogAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    image?: SortOrder
    description?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    short_description?: SortOrder
    image?: SortOrder
    description?: SortOrder
    is_approved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type BlogSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    approved_by_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ProductRatingUserIdProductIdCompoundUniqueInput = {
    userId: number
    productId: number
  }

  export type ProductRatingCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type ProductRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRatingMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRatingSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type EventCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BlogCreateNestedManyWithoutApproved_byInput = {
    create?: XOR<BlogCreateWithoutApproved_byInput, BlogUncheckedCreateWithoutApproved_byInput> | BlogCreateWithoutApproved_byInput[] | BlogUncheckedCreateWithoutApproved_byInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutApproved_byInput | BlogCreateOrConnectWithoutApproved_byInput[]
    createMany?: BlogCreateManyApproved_byInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type BlogCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type ProductRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductRatingCreateWithoutUserInput, ProductRatingUncheckedCreateWithoutUserInput> | ProductRatingCreateWithoutUserInput[] | ProductRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutUserInput | ProductRatingCreateOrConnectWithoutUserInput[]
    createMany?: ProductRatingCreateManyUserInputEnvelope
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutApproved_byInput = {
    create?: XOR<BlogCreateWithoutApproved_byInput, BlogUncheckedCreateWithoutApproved_byInput> | BlogCreateWithoutApproved_byInput[] | BlogUncheckedCreateWithoutApproved_byInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutApproved_byInput | BlogCreateOrConnectWithoutApproved_byInput[]
    createMany?: BlogCreateManyApproved_byInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type ProductRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductRatingCreateWithoutUserInput, ProductRatingUncheckedCreateWithoutUserInput> | ProductRatingCreateWithoutUserInput[] | ProductRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutUserInput | ProductRatingCreateOrConnectWithoutUserInput[]
    createMany?: ProductRatingCreateManyUserInputEnvelope
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BlogUpdateManyWithoutApproved_byNestedInput = {
    create?: XOR<BlogCreateWithoutApproved_byInput, BlogUncheckedCreateWithoutApproved_byInput> | BlogCreateWithoutApproved_byInput[] | BlogUncheckedCreateWithoutApproved_byInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutApproved_byInput | BlogCreateOrConnectWithoutApproved_byInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutApproved_byInput | BlogUpsertWithWhereUniqueWithoutApproved_byInput[]
    createMany?: BlogCreateManyApproved_byInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutApproved_byInput | BlogUpdateWithWhereUniqueWithoutApproved_byInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutApproved_byInput | BlogUpdateManyWithWhereWithoutApproved_byInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type BlogUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutAuthorInput | BlogUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutAuthorInput | BlogUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutAuthorInput | BlogUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type ProductRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductRatingCreateWithoutUserInput, ProductRatingUncheckedCreateWithoutUserInput> | ProductRatingCreateWithoutUserInput[] | ProductRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutUserInput | ProductRatingCreateOrConnectWithoutUserInput[]
    upsert?: ProductRatingUpsertWithWhereUniqueWithoutUserInput | ProductRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductRatingCreateManyUserInputEnvelope
    set?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    disconnect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    delete?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    update?: ProductRatingUpdateWithWhereUniqueWithoutUserInput | ProductRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductRatingUpdateManyWithWhereWithoutUserInput | ProductRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductRatingScalarWhereInput | ProductRatingScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutApproved_byNestedInput = {
    create?: XOR<BlogCreateWithoutApproved_byInput, BlogUncheckedCreateWithoutApproved_byInput> | BlogCreateWithoutApproved_byInput[] | BlogUncheckedCreateWithoutApproved_byInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutApproved_byInput | BlogCreateOrConnectWithoutApproved_byInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutApproved_byInput | BlogUpsertWithWhereUniqueWithoutApproved_byInput[]
    createMany?: BlogCreateManyApproved_byInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutApproved_byInput | BlogUpdateWithWhereUniqueWithoutApproved_byInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutApproved_byInput | BlogUpdateManyWithWhereWithoutApproved_byInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutAuthorInput | BlogUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutAuthorInput | BlogUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutAuthorInput | BlogUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type ProductRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductRatingCreateWithoutUserInput, ProductRatingUncheckedCreateWithoutUserInput> | ProductRatingCreateWithoutUserInput[] | ProductRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutUserInput | ProductRatingCreateOrConnectWithoutUserInput[]
    upsert?: ProductRatingUpsertWithWhereUniqueWithoutUserInput | ProductRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductRatingCreateManyUserInputEnvelope
    set?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    disconnect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    delete?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    update?: ProductRatingUpdateWithWhereUniqueWithoutUserInput | ProductRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductRatingUpdateManyWithWhereWithoutUserInput | ProductRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductRatingScalarWhereInput | ProductRatingScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutDistrictInput = {
    create?: XOR<ProductCreateWithoutDistrictInput, ProductUncheckedCreateWithoutDistrictInput> | ProductCreateWithoutDistrictInput[] | ProductUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDistrictInput | ProductCreateOrConnectWithoutDistrictInput[]
    createMany?: ProductCreateManyDistrictInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutDistrictInput = {
    create?: XOR<ProductCreateWithoutDistrictInput, ProductUncheckedCreateWithoutDistrictInput> | ProductCreateWithoutDistrictInput[] | ProductUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDistrictInput | ProductCreateOrConnectWithoutDistrictInput[]
    createMany?: ProductCreateManyDistrictInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<ProductCreateWithoutDistrictInput, ProductUncheckedCreateWithoutDistrictInput> | ProductCreateWithoutDistrictInput[] | ProductUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDistrictInput | ProductCreateOrConnectWithoutDistrictInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutDistrictInput | ProductUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: ProductCreateManyDistrictInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutDistrictInput | ProductUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutDistrictInput | ProductUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutDistrictNestedInput = {
    create?: XOR<ProductCreateWithoutDistrictInput, ProductUncheckedCreateWithoutDistrictInput> | ProductCreateWithoutDistrictInput[] | ProductUncheckedCreateWithoutDistrictInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutDistrictInput | ProductCreateOrConnectWithoutDistrictInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutDistrictInput | ProductUpsertWithWhereUniqueWithoutDistrictInput[]
    createMany?: ProductCreateManyDistrictInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutDistrictInput | ProductUpdateWithWhereUniqueWithoutDistrictInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutDistrictInput | ProductUpdateManyWithWhereWithoutDistrictInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutVenueInput = {
    create?: XOR<ProductCreateWithoutVenueInput, ProductUncheckedCreateWithoutVenueInput> | ProductCreateWithoutVenueInput[] | ProductUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVenueInput | ProductCreateOrConnectWithoutVenueInput[]
    createMany?: ProductCreateManyVenueInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ProductCreateWithoutVenueInput, ProductUncheckedCreateWithoutVenueInput> | ProductCreateWithoutVenueInput[] | ProductUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVenueInput | ProductCreateOrConnectWithoutVenueInput[]
    createMany?: ProductCreateManyVenueInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ProductCreateWithoutVenueInput, ProductUncheckedCreateWithoutVenueInput> | ProductCreateWithoutVenueInput[] | ProductUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVenueInput | ProductCreateOrConnectWithoutVenueInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVenueInput | ProductUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ProductCreateManyVenueInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVenueInput | ProductUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVenueInput | ProductUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ProductCreateWithoutVenueInput, ProductUncheckedCreateWithoutVenueInput> | ProductCreateWithoutVenueInput[] | ProductUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutVenueInput | ProductCreateOrConnectWithoutVenueInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutVenueInput | ProductUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ProductCreateManyVenueInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutVenueInput | ProductUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutVenueInput | ProductUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type MultimediaCreateNestedManyWithoutProductInput = {
    create?: XOR<MultimediaCreateWithoutProductInput, MultimediaUncheckedCreateWithoutProductInput> | MultimediaCreateWithoutProductInput[] | MultimediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutProductInput | MultimediaCreateOrConnectWithoutProductInput[]
    createMany?: MultimediaCreateManyProductInputEnvelope
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
  }

  export type EntertainmentCreateNestedManyWithoutProductInput = {
    create?: XOR<EntertainmentCreateWithoutProductInput, EntertainmentUncheckedCreateWithoutProductInput> | EntertainmentCreateWithoutProductInput[] | EntertainmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutProductInput | EntertainmentCreateOrConnectWithoutProductInput[]
    createMany?: EntertainmentCreateManyProductInputEnvelope
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
  }

  export type MusicalCreateNestedManyWithoutProductInput = {
    create?: XOR<MusicalCreateWithoutProductInput, MusicalUncheckedCreateWithoutProductInput> | MusicalCreateWithoutProductInput[] | MusicalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutProductInput | MusicalCreateOrConnectWithoutProductInput[]
    createMany?: MusicalCreateManyProductInputEnvelope
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
  }

  export type LuxuryCreateNestedManyWithoutProductInput = {
    create?: XOR<LuxuryCreateWithoutProductInput, LuxuryUncheckedCreateWithoutProductInput> | LuxuryCreateWithoutProductInput[] | LuxuryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutProductInput | LuxuryCreateOrConnectWithoutProductInput[]
    createMany?: LuxuryCreateManyProductInputEnvelope
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutProductInput = {
    create?: XOR<MeetingCreateWithoutProductInput, MeetingUncheckedCreateWithoutProductInput> | MeetingCreateWithoutProductInput[] | MeetingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutProductInput | MeetingCreateOrConnectWithoutProductInput[]
    createMany?: MeetingCreateManyProductInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type BeautyDecorCreateNestedManyWithoutProductInput = {
    create?: XOR<BeautyDecorCreateWithoutProductInput, BeautyDecorUncheckedCreateWithoutProductInput> | BeautyDecorCreateWithoutProductInput[] | BeautyDecorUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutProductInput | BeautyDecorCreateOrConnectWithoutProductInput[]
    createMany?: BeautyDecorCreateManyProductInputEnvelope
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
  }

  export type AdventureCreateNestedManyWithoutProductInput = {
    create?: XOR<AdventureCreateWithoutProductInput, AdventureUncheckedCreateWithoutProductInput> | AdventureCreateWithoutProductInput[] | AdventureUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutProductInput | AdventureCreateOrConnectWithoutProductInput[]
    createMany?: AdventureCreateManyProductInputEnvelope
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type PartyPalaceCreateNestedManyWithoutProductInput = {
    create?: XOR<PartyPalaceCreateWithoutProductInput, PartyPalaceUncheckedCreateWithoutProductInput> | PartyPalaceCreateWithoutProductInput[] | PartyPalaceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutProductInput | PartyPalaceCreateOrConnectWithoutProductInput[]
    createMany?: PartyPalaceCreateManyProductInputEnvelope
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
  }

  export type CateringTentCreateNestedManyWithoutProductInput = {
    create?: XOR<CateringTentCreateWithoutProductInput, CateringTentUncheckedCreateWithoutProductInput> | CateringTentCreateWithoutProductInput[] | CateringTentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutProductInput | CateringTentCreateOrConnectWithoutProductInput[]
    createMany?: CateringTentCreateManyProductInputEnvelope
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutProductInput = {
    create?: XOR<EventCreateWithoutProductInput, EventUncheckedCreateWithoutProductInput> | EventCreateWithoutProductInput[] | EventUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProductInput | EventCreateOrConnectWithoutProductInput[]
    createMany?: EventCreateManyProductInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductRatingCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductRatingCreateWithoutProductInput, ProductRatingUncheckedCreateWithoutProductInput> | ProductRatingCreateWithoutProductInput[] | ProductRatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutProductInput | ProductRatingCreateOrConnectWithoutProductInput[]
    createMany?: ProductRatingCreateManyProductInputEnvelope
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
  }

  export type DistrictCreateNestedOneWithoutProductsInput = {
    create?: XOR<DistrictCreateWithoutProductsInput, DistrictUncheckedCreateWithoutProductsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutProductsInput
    connect?: DistrictWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutProductsInput = {
    create?: XOR<VenueCreateWithoutProductsInput, VenueUncheckedCreateWithoutProductsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutProductsInput
    connect?: VenueWhereUniqueInput
  }

  export type MultimediaUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<MultimediaCreateWithoutProductInput, MultimediaUncheckedCreateWithoutProductInput> | MultimediaCreateWithoutProductInput[] | MultimediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutProductInput | MultimediaCreateOrConnectWithoutProductInput[]
    createMany?: MultimediaCreateManyProductInputEnvelope
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
  }

  export type EntertainmentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<EntertainmentCreateWithoutProductInput, EntertainmentUncheckedCreateWithoutProductInput> | EntertainmentCreateWithoutProductInput[] | EntertainmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutProductInput | EntertainmentCreateOrConnectWithoutProductInput[]
    createMany?: EntertainmentCreateManyProductInputEnvelope
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
  }

  export type MusicalUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<MusicalCreateWithoutProductInput, MusicalUncheckedCreateWithoutProductInput> | MusicalCreateWithoutProductInput[] | MusicalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutProductInput | MusicalCreateOrConnectWithoutProductInput[]
    createMany?: MusicalCreateManyProductInputEnvelope
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
  }

  export type LuxuryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<LuxuryCreateWithoutProductInput, LuxuryUncheckedCreateWithoutProductInput> | LuxuryCreateWithoutProductInput[] | LuxuryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutProductInput | LuxuryCreateOrConnectWithoutProductInput[]
    createMany?: LuxuryCreateManyProductInputEnvelope
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<MeetingCreateWithoutProductInput, MeetingUncheckedCreateWithoutProductInput> | MeetingCreateWithoutProductInput[] | MeetingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutProductInput | MeetingCreateOrConnectWithoutProductInput[]
    createMany?: MeetingCreateManyProductInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type BeautyDecorUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<BeautyDecorCreateWithoutProductInput, BeautyDecorUncheckedCreateWithoutProductInput> | BeautyDecorCreateWithoutProductInput[] | BeautyDecorUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutProductInput | BeautyDecorCreateOrConnectWithoutProductInput[]
    createMany?: BeautyDecorCreateManyProductInputEnvelope
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
  }

  export type AdventureUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AdventureCreateWithoutProductInput, AdventureUncheckedCreateWithoutProductInput> | AdventureCreateWithoutProductInput[] | AdventureUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutProductInput | AdventureCreateOrConnectWithoutProductInput[]
    createMany?: AdventureCreateManyProductInputEnvelope
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type PartyPalaceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PartyPalaceCreateWithoutProductInput, PartyPalaceUncheckedCreateWithoutProductInput> | PartyPalaceCreateWithoutProductInput[] | PartyPalaceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutProductInput | PartyPalaceCreateOrConnectWithoutProductInput[]
    createMany?: PartyPalaceCreateManyProductInputEnvelope
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
  }

  export type CateringTentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CateringTentCreateWithoutProductInput, CateringTentUncheckedCreateWithoutProductInput> | CateringTentCreateWithoutProductInput[] | CateringTentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutProductInput | CateringTentCreateOrConnectWithoutProductInput[]
    createMany?: CateringTentCreateManyProductInputEnvelope
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<EventCreateWithoutProductInput, EventUncheckedCreateWithoutProductInput> | EventCreateWithoutProductInput[] | EventUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProductInput | EventCreateOrConnectWithoutProductInput[]
    createMany?: EventCreateManyProductInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductRatingUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductRatingCreateWithoutProductInput, ProductRatingUncheckedCreateWithoutProductInput> | ProductRatingCreateWithoutProductInput[] | ProductRatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutProductInput | ProductRatingCreateOrConnectWithoutProductInput[]
    createMany?: ProductRatingCreateManyProductInputEnvelope
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type MultimediaUpdateManyWithoutProductNestedInput = {
    create?: XOR<MultimediaCreateWithoutProductInput, MultimediaUncheckedCreateWithoutProductInput> | MultimediaCreateWithoutProductInput[] | MultimediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutProductInput | MultimediaCreateOrConnectWithoutProductInput[]
    upsert?: MultimediaUpsertWithWhereUniqueWithoutProductInput | MultimediaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MultimediaCreateManyProductInputEnvelope
    set?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    disconnect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    delete?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    update?: MultimediaUpdateWithWhereUniqueWithoutProductInput | MultimediaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MultimediaUpdateManyWithWhereWithoutProductInput | MultimediaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MultimediaScalarWhereInput | MultimediaScalarWhereInput[]
  }

  export type EntertainmentUpdateManyWithoutProductNestedInput = {
    create?: XOR<EntertainmentCreateWithoutProductInput, EntertainmentUncheckedCreateWithoutProductInput> | EntertainmentCreateWithoutProductInput[] | EntertainmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutProductInput | EntertainmentCreateOrConnectWithoutProductInput[]
    upsert?: EntertainmentUpsertWithWhereUniqueWithoutProductInput | EntertainmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: EntertainmentCreateManyProductInputEnvelope
    set?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    disconnect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    delete?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    update?: EntertainmentUpdateWithWhereUniqueWithoutProductInput | EntertainmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: EntertainmentUpdateManyWithWhereWithoutProductInput | EntertainmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: EntertainmentScalarWhereInput | EntertainmentScalarWhereInput[]
  }

  export type MusicalUpdateManyWithoutProductNestedInput = {
    create?: XOR<MusicalCreateWithoutProductInput, MusicalUncheckedCreateWithoutProductInput> | MusicalCreateWithoutProductInput[] | MusicalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutProductInput | MusicalCreateOrConnectWithoutProductInput[]
    upsert?: MusicalUpsertWithWhereUniqueWithoutProductInput | MusicalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MusicalCreateManyProductInputEnvelope
    set?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    disconnect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    delete?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    update?: MusicalUpdateWithWhereUniqueWithoutProductInput | MusicalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MusicalUpdateManyWithWhereWithoutProductInput | MusicalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
  }

  export type LuxuryUpdateManyWithoutProductNestedInput = {
    create?: XOR<LuxuryCreateWithoutProductInput, LuxuryUncheckedCreateWithoutProductInput> | LuxuryCreateWithoutProductInput[] | LuxuryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutProductInput | LuxuryCreateOrConnectWithoutProductInput[]
    upsert?: LuxuryUpsertWithWhereUniqueWithoutProductInput | LuxuryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: LuxuryCreateManyProductInputEnvelope
    set?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    disconnect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    delete?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    update?: LuxuryUpdateWithWhereUniqueWithoutProductInput | LuxuryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: LuxuryUpdateManyWithWhereWithoutProductInput | LuxuryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: LuxuryScalarWhereInput | LuxuryScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutProductNestedInput = {
    create?: XOR<MeetingCreateWithoutProductInput, MeetingUncheckedCreateWithoutProductInput> | MeetingCreateWithoutProductInput[] | MeetingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutProductInput | MeetingCreateOrConnectWithoutProductInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutProductInput | MeetingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MeetingCreateManyProductInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutProductInput | MeetingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutProductInput | MeetingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type BeautyDecorUpdateManyWithoutProductNestedInput = {
    create?: XOR<BeautyDecorCreateWithoutProductInput, BeautyDecorUncheckedCreateWithoutProductInput> | BeautyDecorCreateWithoutProductInput[] | BeautyDecorUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutProductInput | BeautyDecorCreateOrConnectWithoutProductInput[]
    upsert?: BeautyDecorUpsertWithWhereUniqueWithoutProductInput | BeautyDecorUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BeautyDecorCreateManyProductInputEnvelope
    set?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    disconnect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    delete?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    update?: BeautyDecorUpdateWithWhereUniqueWithoutProductInput | BeautyDecorUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BeautyDecorUpdateManyWithWhereWithoutProductInput | BeautyDecorUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BeautyDecorScalarWhereInput | BeautyDecorScalarWhereInput[]
  }

  export type AdventureUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdventureCreateWithoutProductInput, AdventureUncheckedCreateWithoutProductInput> | AdventureCreateWithoutProductInput[] | AdventureUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutProductInput | AdventureCreateOrConnectWithoutProductInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutProductInput | AdventureUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdventureCreateManyProductInputEnvelope
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutProductInput | AdventureUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutProductInput | AdventureUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type PartyPalaceUpdateManyWithoutProductNestedInput = {
    create?: XOR<PartyPalaceCreateWithoutProductInput, PartyPalaceUncheckedCreateWithoutProductInput> | PartyPalaceCreateWithoutProductInput[] | PartyPalaceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutProductInput | PartyPalaceCreateOrConnectWithoutProductInput[]
    upsert?: PartyPalaceUpsertWithWhereUniqueWithoutProductInput | PartyPalaceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PartyPalaceCreateManyProductInputEnvelope
    set?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    disconnect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    delete?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    update?: PartyPalaceUpdateWithWhereUniqueWithoutProductInput | PartyPalaceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PartyPalaceUpdateManyWithWhereWithoutProductInput | PartyPalaceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PartyPalaceScalarWhereInput | PartyPalaceScalarWhereInput[]
  }

  export type CateringTentUpdateManyWithoutProductNestedInput = {
    create?: XOR<CateringTentCreateWithoutProductInput, CateringTentUncheckedCreateWithoutProductInput> | CateringTentCreateWithoutProductInput[] | CateringTentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutProductInput | CateringTentCreateOrConnectWithoutProductInput[]
    upsert?: CateringTentUpsertWithWhereUniqueWithoutProductInput | CateringTentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CateringTentCreateManyProductInputEnvelope
    set?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    disconnect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    delete?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    update?: CateringTentUpdateWithWhereUniqueWithoutProductInput | CateringTentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CateringTentUpdateManyWithWhereWithoutProductInput | CateringTentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CateringTentScalarWhereInput | CateringTentScalarWhereInput[]
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type EventUpdateManyWithoutProductNestedInput = {
    create?: XOR<EventCreateWithoutProductInput, EventUncheckedCreateWithoutProductInput> | EventCreateWithoutProductInput[] | EventUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProductInput | EventCreateOrConnectWithoutProductInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutProductInput | EventUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: EventCreateManyProductInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutProductInput | EventUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: EventUpdateManyWithWhereWithoutProductInput | EventUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductRatingUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductRatingCreateWithoutProductInput, ProductRatingUncheckedCreateWithoutProductInput> | ProductRatingCreateWithoutProductInput[] | ProductRatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutProductInput | ProductRatingCreateOrConnectWithoutProductInput[]
    upsert?: ProductRatingUpsertWithWhereUniqueWithoutProductInput | ProductRatingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductRatingCreateManyProductInputEnvelope
    set?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    disconnect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    delete?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    update?: ProductRatingUpdateWithWhereUniqueWithoutProductInput | ProductRatingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductRatingUpdateManyWithWhereWithoutProductInput | ProductRatingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductRatingScalarWhereInput | ProductRatingScalarWhereInput[]
  }

  export type DistrictUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<DistrictCreateWithoutProductsInput, DistrictUncheckedCreateWithoutProductsInput>
    connectOrCreate?: DistrictCreateOrConnectWithoutProductsInput
    upsert?: DistrictUpsertWithoutProductsInput
    connect?: DistrictWhereUniqueInput
    update?: XOR<XOR<DistrictUpdateToOneWithWhereWithoutProductsInput, DistrictUpdateWithoutProductsInput>, DistrictUncheckedUpdateWithoutProductsInput>
  }

  export type VenueUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<VenueCreateWithoutProductsInput, VenueUncheckedCreateWithoutProductsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutProductsInput
    upsert?: VenueUpsertWithoutProductsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutProductsInput, VenueUpdateWithoutProductsInput>, VenueUncheckedUpdateWithoutProductsInput>
  }

  export type MultimediaUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<MultimediaCreateWithoutProductInput, MultimediaUncheckedCreateWithoutProductInput> | MultimediaCreateWithoutProductInput[] | MultimediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutProductInput | MultimediaCreateOrConnectWithoutProductInput[]
    upsert?: MultimediaUpsertWithWhereUniqueWithoutProductInput | MultimediaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MultimediaCreateManyProductInputEnvelope
    set?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    disconnect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    delete?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    update?: MultimediaUpdateWithWhereUniqueWithoutProductInput | MultimediaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MultimediaUpdateManyWithWhereWithoutProductInput | MultimediaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MultimediaScalarWhereInput | MultimediaScalarWhereInput[]
  }

  export type EntertainmentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<EntertainmentCreateWithoutProductInput, EntertainmentUncheckedCreateWithoutProductInput> | EntertainmentCreateWithoutProductInput[] | EntertainmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutProductInput | EntertainmentCreateOrConnectWithoutProductInput[]
    upsert?: EntertainmentUpsertWithWhereUniqueWithoutProductInput | EntertainmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: EntertainmentCreateManyProductInputEnvelope
    set?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    disconnect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    delete?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    update?: EntertainmentUpdateWithWhereUniqueWithoutProductInput | EntertainmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: EntertainmentUpdateManyWithWhereWithoutProductInput | EntertainmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: EntertainmentScalarWhereInput | EntertainmentScalarWhereInput[]
  }

  export type MusicalUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<MusicalCreateWithoutProductInput, MusicalUncheckedCreateWithoutProductInput> | MusicalCreateWithoutProductInput[] | MusicalUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutProductInput | MusicalCreateOrConnectWithoutProductInput[]
    upsert?: MusicalUpsertWithWhereUniqueWithoutProductInput | MusicalUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MusicalCreateManyProductInputEnvelope
    set?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    disconnect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    delete?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    update?: MusicalUpdateWithWhereUniqueWithoutProductInput | MusicalUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MusicalUpdateManyWithWhereWithoutProductInput | MusicalUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
  }

  export type LuxuryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<LuxuryCreateWithoutProductInput, LuxuryUncheckedCreateWithoutProductInput> | LuxuryCreateWithoutProductInput[] | LuxuryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutProductInput | LuxuryCreateOrConnectWithoutProductInput[]
    upsert?: LuxuryUpsertWithWhereUniqueWithoutProductInput | LuxuryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: LuxuryCreateManyProductInputEnvelope
    set?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    disconnect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    delete?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    update?: LuxuryUpdateWithWhereUniqueWithoutProductInput | LuxuryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: LuxuryUpdateManyWithWhereWithoutProductInput | LuxuryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: LuxuryScalarWhereInput | LuxuryScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<MeetingCreateWithoutProductInput, MeetingUncheckedCreateWithoutProductInput> | MeetingCreateWithoutProductInput[] | MeetingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutProductInput | MeetingCreateOrConnectWithoutProductInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutProductInput | MeetingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MeetingCreateManyProductInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutProductInput | MeetingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutProductInput | MeetingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type BeautyDecorUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<BeautyDecorCreateWithoutProductInput, BeautyDecorUncheckedCreateWithoutProductInput> | BeautyDecorCreateWithoutProductInput[] | BeautyDecorUncheckedCreateWithoutProductInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutProductInput | BeautyDecorCreateOrConnectWithoutProductInput[]
    upsert?: BeautyDecorUpsertWithWhereUniqueWithoutProductInput | BeautyDecorUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: BeautyDecorCreateManyProductInputEnvelope
    set?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    disconnect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    delete?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    update?: BeautyDecorUpdateWithWhereUniqueWithoutProductInput | BeautyDecorUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: BeautyDecorUpdateManyWithWhereWithoutProductInput | BeautyDecorUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: BeautyDecorScalarWhereInput | BeautyDecorScalarWhereInput[]
  }

  export type AdventureUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdventureCreateWithoutProductInput, AdventureUncheckedCreateWithoutProductInput> | AdventureCreateWithoutProductInput[] | AdventureUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutProductInput | AdventureCreateOrConnectWithoutProductInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutProductInput | AdventureUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdventureCreateManyProductInputEnvelope
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutProductInput | AdventureUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutProductInput | AdventureUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type PartyPalaceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PartyPalaceCreateWithoutProductInput, PartyPalaceUncheckedCreateWithoutProductInput> | PartyPalaceCreateWithoutProductInput[] | PartyPalaceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutProductInput | PartyPalaceCreateOrConnectWithoutProductInput[]
    upsert?: PartyPalaceUpsertWithWhereUniqueWithoutProductInput | PartyPalaceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PartyPalaceCreateManyProductInputEnvelope
    set?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    disconnect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    delete?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    update?: PartyPalaceUpdateWithWhereUniqueWithoutProductInput | PartyPalaceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PartyPalaceUpdateManyWithWhereWithoutProductInput | PartyPalaceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PartyPalaceScalarWhereInput | PartyPalaceScalarWhereInput[]
  }

  export type CateringTentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CateringTentCreateWithoutProductInput, CateringTentUncheckedCreateWithoutProductInput> | CateringTentCreateWithoutProductInput[] | CateringTentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutProductInput | CateringTentCreateOrConnectWithoutProductInput[]
    upsert?: CateringTentUpsertWithWhereUniqueWithoutProductInput | CateringTentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CateringTentCreateManyProductInputEnvelope
    set?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    disconnect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    delete?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    update?: CateringTentUpdateWithWhereUniqueWithoutProductInput | CateringTentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CateringTentUpdateManyWithWhereWithoutProductInput | CateringTentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CateringTentScalarWhereInput | CateringTentScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<EventCreateWithoutProductInput, EventUncheckedCreateWithoutProductInput> | EventCreateWithoutProductInput[] | EventUncheckedCreateWithoutProductInput[]
    connectOrCreate?: EventCreateOrConnectWithoutProductInput | EventCreateOrConnectWithoutProductInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutProductInput | EventUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: EventCreateManyProductInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutProductInput | EventUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: EventUpdateManyWithWhereWithoutProductInput | EventUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductRatingUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductRatingCreateWithoutProductInput, ProductRatingUncheckedCreateWithoutProductInput> | ProductRatingCreateWithoutProductInput[] | ProductRatingUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRatingCreateOrConnectWithoutProductInput | ProductRatingCreateOrConnectWithoutProductInput[]
    upsert?: ProductRatingUpsertWithWhereUniqueWithoutProductInput | ProductRatingUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductRatingCreateManyProductInputEnvelope
    set?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    disconnect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    delete?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    connect?: ProductRatingWhereUniqueInput | ProductRatingWhereUniqueInput[]
    update?: ProductRatingUpdateWithWhereUniqueWithoutProductInput | ProductRatingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductRatingUpdateManyWithWhereWithoutProductInput | ProductRatingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductRatingScalarWhereInput | ProductRatingScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutEventInput = {
    create?: XOR<ProductCreateWithoutEventInput, ProductUncheckedCreateWithoutEventInput>
    connectOrCreate?: ProductCreateOrConnectWithoutEventInput
    connect?: ProductWhereUniqueInput
  }

  export type PartyPalaceCreateNestedManyWithoutEventsInput = {
    create?: XOR<PartyPalaceCreateWithoutEventsInput, PartyPalaceUncheckedCreateWithoutEventsInput> | PartyPalaceCreateWithoutEventsInput[] | PartyPalaceUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutEventsInput | PartyPalaceCreateOrConnectWithoutEventsInput[]
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
  }

  export type CateringTentCreateNestedManyWithoutEventsInput = {
    create?: XOR<CateringTentCreateWithoutEventsInput, CateringTentUncheckedCreateWithoutEventsInput> | CateringTentCreateWithoutEventsInput[] | CateringTentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutEventsInput | CateringTentCreateOrConnectWithoutEventsInput[]
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
  }

  export type AdventureCreateNestedManyWithoutEventsInput = {
    create?: XOR<AdventureCreateWithoutEventsInput, AdventureUncheckedCreateWithoutEventsInput> | AdventureCreateWithoutEventsInput[] | AdventureUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutEventsInput | AdventureCreateOrConnectWithoutEventsInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type BeautyDecorCreateNestedManyWithoutEventsInput = {
    create?: XOR<BeautyDecorCreateWithoutEventsInput, BeautyDecorUncheckedCreateWithoutEventsInput> | BeautyDecorCreateWithoutEventsInput[] | BeautyDecorUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutEventsInput | BeautyDecorCreateOrConnectWithoutEventsInput[]
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutEventsInput = {
    create?: XOR<MeetingCreateWithoutEventsInput, MeetingUncheckedCreateWithoutEventsInput> | MeetingCreateWithoutEventsInput[] | MeetingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutEventsInput | MeetingCreateOrConnectWithoutEventsInput[]
    createMany?: MeetingCreateManyEventsInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EntertainmentCreateNestedManyWithoutEventsInput = {
    create?: XOR<EntertainmentCreateWithoutEventsInput, EntertainmentUncheckedCreateWithoutEventsInput> | EntertainmentCreateWithoutEventsInput[] | EntertainmentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutEventsInput | EntertainmentCreateOrConnectWithoutEventsInput[]
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
  }

  export type LuxuryCreateNestedManyWithoutEventsInput = {
    create?: XOR<LuxuryCreateWithoutEventsInput, LuxuryUncheckedCreateWithoutEventsInput> | LuxuryCreateWithoutEventsInput[] | LuxuryUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutEventsInput | LuxuryCreateOrConnectWithoutEventsInput[]
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
  }

  export type MusicalCreateNestedManyWithoutEventsInput = {
    create?: XOR<MusicalCreateWithoutEventsInput, MusicalUncheckedCreateWithoutEventsInput> | MusicalCreateWithoutEventsInput[] | MusicalUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutEventsInput | MusicalCreateOrConnectWithoutEventsInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
  }

  export type MultimediaCreateNestedManyWithoutEventsInput = {
    create?: XOR<MultimediaCreateWithoutEventsInput, MultimediaUncheckedCreateWithoutEventsInput> | MultimediaCreateWithoutEventsInput[] | MultimediaUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutEventsInput | MultimediaCreateOrConnectWithoutEventsInput[]
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
  }

  export type EventEventTypeCreateNestedManyWithoutEventInput = {
    create?: XOR<EventEventTypeCreateWithoutEventInput, EventEventTypeUncheckedCreateWithoutEventInput> | EventEventTypeCreateWithoutEventInput[] | EventEventTypeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventInput | EventEventTypeCreateOrConnectWithoutEventInput[]
    createMany?: EventEventTypeCreateManyEventInputEnvelope
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEvents_bookedInput = {
    create?: XOR<UserCreateWithoutEvents_bookedInput, UserUncheckedCreateWithoutEvents_bookedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvents_bookedInput
    connect?: UserWhereUniqueInput
  }

  export type PartyPalaceUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<PartyPalaceCreateWithoutEventsInput, PartyPalaceUncheckedCreateWithoutEventsInput> | PartyPalaceCreateWithoutEventsInput[] | PartyPalaceUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutEventsInput | PartyPalaceCreateOrConnectWithoutEventsInput[]
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
  }

  export type CateringTentUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<CateringTentCreateWithoutEventsInput, CateringTentUncheckedCreateWithoutEventsInput> | CateringTentCreateWithoutEventsInput[] | CateringTentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutEventsInput | CateringTentCreateOrConnectWithoutEventsInput[]
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
  }

  export type AdventureUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<AdventureCreateWithoutEventsInput, AdventureUncheckedCreateWithoutEventsInput> | AdventureCreateWithoutEventsInput[] | AdventureUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutEventsInput | AdventureCreateOrConnectWithoutEventsInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type BeautyDecorUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<BeautyDecorCreateWithoutEventsInput, BeautyDecorUncheckedCreateWithoutEventsInput> | BeautyDecorCreateWithoutEventsInput[] | BeautyDecorUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutEventsInput | BeautyDecorCreateOrConnectWithoutEventsInput[]
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<MeetingCreateWithoutEventsInput, MeetingUncheckedCreateWithoutEventsInput> | MeetingCreateWithoutEventsInput[] | MeetingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutEventsInput | MeetingCreateOrConnectWithoutEventsInput[]
    createMany?: MeetingCreateManyEventsInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EntertainmentUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<EntertainmentCreateWithoutEventsInput, EntertainmentUncheckedCreateWithoutEventsInput> | EntertainmentCreateWithoutEventsInput[] | EntertainmentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutEventsInput | EntertainmentCreateOrConnectWithoutEventsInput[]
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
  }

  export type LuxuryUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<LuxuryCreateWithoutEventsInput, LuxuryUncheckedCreateWithoutEventsInput> | LuxuryCreateWithoutEventsInput[] | LuxuryUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutEventsInput | LuxuryCreateOrConnectWithoutEventsInput[]
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
  }

  export type MusicalUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<MusicalCreateWithoutEventsInput, MusicalUncheckedCreateWithoutEventsInput> | MusicalCreateWithoutEventsInput[] | MusicalUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutEventsInput | MusicalCreateOrConnectWithoutEventsInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
  }

  export type MultimediaUncheckedCreateNestedManyWithoutEventsInput = {
    create?: XOR<MultimediaCreateWithoutEventsInput, MultimediaUncheckedCreateWithoutEventsInput> | MultimediaCreateWithoutEventsInput[] | MultimediaUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutEventsInput | MultimediaCreateOrConnectWithoutEventsInput[]
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
  }

  export type EventEventTypeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventEventTypeCreateWithoutEventInput, EventEventTypeUncheckedCreateWithoutEventInput> | EventEventTypeCreateWithoutEventInput[] | EventEventTypeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventInput | EventEventTypeCreateOrConnectWithoutEventInput[]
    createMany?: EventEventTypeCreateManyEventInputEnvelope
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutEventNestedInput = {
    create?: XOR<ProductCreateWithoutEventInput, ProductUncheckedCreateWithoutEventInput>
    connectOrCreate?: ProductCreateOrConnectWithoutEventInput
    upsert?: ProductUpsertWithoutEventInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutEventInput, ProductUpdateWithoutEventInput>, ProductUncheckedUpdateWithoutEventInput>
  }

  export type PartyPalaceUpdateManyWithoutEventsNestedInput = {
    create?: XOR<PartyPalaceCreateWithoutEventsInput, PartyPalaceUncheckedCreateWithoutEventsInput> | PartyPalaceCreateWithoutEventsInput[] | PartyPalaceUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutEventsInput | PartyPalaceCreateOrConnectWithoutEventsInput[]
    upsert?: PartyPalaceUpsertWithWhereUniqueWithoutEventsInput | PartyPalaceUpsertWithWhereUniqueWithoutEventsInput[]
    set?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    disconnect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    delete?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    update?: PartyPalaceUpdateWithWhereUniqueWithoutEventsInput | PartyPalaceUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: PartyPalaceUpdateManyWithWhereWithoutEventsInput | PartyPalaceUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: PartyPalaceScalarWhereInput | PartyPalaceScalarWhereInput[]
  }

  export type CateringTentUpdateManyWithoutEventsNestedInput = {
    create?: XOR<CateringTentCreateWithoutEventsInput, CateringTentUncheckedCreateWithoutEventsInput> | CateringTentCreateWithoutEventsInput[] | CateringTentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutEventsInput | CateringTentCreateOrConnectWithoutEventsInput[]
    upsert?: CateringTentUpsertWithWhereUniqueWithoutEventsInput | CateringTentUpsertWithWhereUniqueWithoutEventsInput[]
    set?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    disconnect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    delete?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    update?: CateringTentUpdateWithWhereUniqueWithoutEventsInput | CateringTentUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: CateringTentUpdateManyWithWhereWithoutEventsInput | CateringTentUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: CateringTentScalarWhereInput | CateringTentScalarWhereInput[]
  }

  export type AdventureUpdateManyWithoutEventsNestedInput = {
    create?: XOR<AdventureCreateWithoutEventsInput, AdventureUncheckedCreateWithoutEventsInput> | AdventureCreateWithoutEventsInput[] | AdventureUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutEventsInput | AdventureCreateOrConnectWithoutEventsInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutEventsInput | AdventureUpsertWithWhereUniqueWithoutEventsInput[]
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutEventsInput | AdventureUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutEventsInput | AdventureUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type BeautyDecorUpdateManyWithoutEventsNestedInput = {
    create?: XOR<BeautyDecorCreateWithoutEventsInput, BeautyDecorUncheckedCreateWithoutEventsInput> | BeautyDecorCreateWithoutEventsInput[] | BeautyDecorUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutEventsInput | BeautyDecorCreateOrConnectWithoutEventsInput[]
    upsert?: BeautyDecorUpsertWithWhereUniqueWithoutEventsInput | BeautyDecorUpsertWithWhereUniqueWithoutEventsInput[]
    set?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    disconnect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    delete?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    update?: BeautyDecorUpdateWithWhereUniqueWithoutEventsInput | BeautyDecorUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: BeautyDecorUpdateManyWithWhereWithoutEventsInput | BeautyDecorUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: BeautyDecorScalarWhereInput | BeautyDecorScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutEventsNestedInput = {
    create?: XOR<MeetingCreateWithoutEventsInput, MeetingUncheckedCreateWithoutEventsInput> | MeetingCreateWithoutEventsInput[] | MeetingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutEventsInput | MeetingCreateOrConnectWithoutEventsInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutEventsInput | MeetingUpsertWithWhereUniqueWithoutEventsInput[]
    createMany?: MeetingCreateManyEventsInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutEventsInput | MeetingUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutEventsInput | MeetingUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EntertainmentUpdateManyWithoutEventsNestedInput = {
    create?: XOR<EntertainmentCreateWithoutEventsInput, EntertainmentUncheckedCreateWithoutEventsInput> | EntertainmentCreateWithoutEventsInput[] | EntertainmentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutEventsInput | EntertainmentCreateOrConnectWithoutEventsInput[]
    upsert?: EntertainmentUpsertWithWhereUniqueWithoutEventsInput | EntertainmentUpsertWithWhereUniqueWithoutEventsInput[]
    set?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    disconnect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    delete?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    update?: EntertainmentUpdateWithWhereUniqueWithoutEventsInput | EntertainmentUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: EntertainmentUpdateManyWithWhereWithoutEventsInput | EntertainmentUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: EntertainmentScalarWhereInput | EntertainmentScalarWhereInput[]
  }

  export type LuxuryUpdateManyWithoutEventsNestedInput = {
    create?: XOR<LuxuryCreateWithoutEventsInput, LuxuryUncheckedCreateWithoutEventsInput> | LuxuryCreateWithoutEventsInput[] | LuxuryUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutEventsInput | LuxuryCreateOrConnectWithoutEventsInput[]
    upsert?: LuxuryUpsertWithWhereUniqueWithoutEventsInput | LuxuryUpsertWithWhereUniqueWithoutEventsInput[]
    set?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    disconnect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    delete?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    update?: LuxuryUpdateWithWhereUniqueWithoutEventsInput | LuxuryUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: LuxuryUpdateManyWithWhereWithoutEventsInput | LuxuryUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: LuxuryScalarWhereInput | LuxuryScalarWhereInput[]
  }

  export type MusicalUpdateManyWithoutEventsNestedInput = {
    create?: XOR<MusicalCreateWithoutEventsInput, MusicalUncheckedCreateWithoutEventsInput> | MusicalCreateWithoutEventsInput[] | MusicalUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutEventsInput | MusicalCreateOrConnectWithoutEventsInput[]
    upsert?: MusicalUpsertWithWhereUniqueWithoutEventsInput | MusicalUpsertWithWhereUniqueWithoutEventsInput[]
    set?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    disconnect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    delete?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    update?: MusicalUpdateWithWhereUniqueWithoutEventsInput | MusicalUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: MusicalUpdateManyWithWhereWithoutEventsInput | MusicalUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
  }

  export type MultimediaUpdateManyWithoutEventsNestedInput = {
    create?: XOR<MultimediaCreateWithoutEventsInput, MultimediaUncheckedCreateWithoutEventsInput> | MultimediaCreateWithoutEventsInput[] | MultimediaUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutEventsInput | MultimediaCreateOrConnectWithoutEventsInput[]
    upsert?: MultimediaUpsertWithWhereUniqueWithoutEventsInput | MultimediaUpsertWithWhereUniqueWithoutEventsInput[]
    set?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    disconnect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    delete?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    update?: MultimediaUpdateWithWhereUniqueWithoutEventsInput | MultimediaUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: MultimediaUpdateManyWithWhereWithoutEventsInput | MultimediaUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: MultimediaScalarWhereInput | MultimediaScalarWhereInput[]
  }

  export type EventEventTypeUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventEventTypeCreateWithoutEventInput, EventEventTypeUncheckedCreateWithoutEventInput> | EventEventTypeCreateWithoutEventInput[] | EventEventTypeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventInput | EventEventTypeCreateOrConnectWithoutEventInput[]
    upsert?: EventEventTypeUpsertWithWhereUniqueWithoutEventInput | EventEventTypeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventEventTypeCreateManyEventInputEnvelope
    set?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    disconnect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    delete?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    update?: EventEventTypeUpdateWithWhereUniqueWithoutEventInput | EventEventTypeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventEventTypeUpdateManyWithWhereWithoutEventInput | EventEventTypeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventEventTypeScalarWhereInput | EventEventTypeScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEvents_bookedNestedInput = {
    create?: XOR<UserCreateWithoutEvents_bookedInput, UserUncheckedCreateWithoutEvents_bookedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvents_bookedInput
    upsert?: UserUpsertWithoutEvents_bookedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvents_bookedInput, UserUpdateWithoutEvents_bookedInput>, UserUncheckedUpdateWithoutEvents_bookedInput>
  }

  export type PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<PartyPalaceCreateWithoutEventsInput, PartyPalaceUncheckedCreateWithoutEventsInput> | PartyPalaceCreateWithoutEventsInput[] | PartyPalaceUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: PartyPalaceCreateOrConnectWithoutEventsInput | PartyPalaceCreateOrConnectWithoutEventsInput[]
    upsert?: PartyPalaceUpsertWithWhereUniqueWithoutEventsInput | PartyPalaceUpsertWithWhereUniqueWithoutEventsInput[]
    set?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    disconnect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    delete?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    connect?: PartyPalaceWhereUniqueInput | PartyPalaceWhereUniqueInput[]
    update?: PartyPalaceUpdateWithWhereUniqueWithoutEventsInput | PartyPalaceUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: PartyPalaceUpdateManyWithWhereWithoutEventsInput | PartyPalaceUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: PartyPalaceScalarWhereInput | PartyPalaceScalarWhereInput[]
  }

  export type CateringTentUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<CateringTentCreateWithoutEventsInput, CateringTentUncheckedCreateWithoutEventsInput> | CateringTentCreateWithoutEventsInput[] | CateringTentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: CateringTentCreateOrConnectWithoutEventsInput | CateringTentCreateOrConnectWithoutEventsInput[]
    upsert?: CateringTentUpsertWithWhereUniqueWithoutEventsInput | CateringTentUpsertWithWhereUniqueWithoutEventsInput[]
    set?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    disconnect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    delete?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    connect?: CateringTentWhereUniqueInput | CateringTentWhereUniqueInput[]
    update?: CateringTentUpdateWithWhereUniqueWithoutEventsInput | CateringTentUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: CateringTentUpdateManyWithWhereWithoutEventsInput | CateringTentUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: CateringTentScalarWhereInput | CateringTentScalarWhereInput[]
  }

  export type AdventureUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<AdventureCreateWithoutEventsInput, AdventureUncheckedCreateWithoutEventsInput> | AdventureCreateWithoutEventsInput[] | AdventureUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutEventsInput | AdventureCreateOrConnectWithoutEventsInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutEventsInput | AdventureUpsertWithWhereUniqueWithoutEventsInput[]
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutEventsInput | AdventureUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutEventsInput | AdventureUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<BeautyDecorCreateWithoutEventsInput, BeautyDecorUncheckedCreateWithoutEventsInput> | BeautyDecorCreateWithoutEventsInput[] | BeautyDecorUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: BeautyDecorCreateOrConnectWithoutEventsInput | BeautyDecorCreateOrConnectWithoutEventsInput[]
    upsert?: BeautyDecorUpsertWithWhereUniqueWithoutEventsInput | BeautyDecorUpsertWithWhereUniqueWithoutEventsInput[]
    set?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    disconnect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    delete?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    connect?: BeautyDecorWhereUniqueInput | BeautyDecorWhereUniqueInput[]
    update?: BeautyDecorUpdateWithWhereUniqueWithoutEventsInput | BeautyDecorUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: BeautyDecorUpdateManyWithWhereWithoutEventsInput | BeautyDecorUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: BeautyDecorScalarWhereInput | BeautyDecorScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<MeetingCreateWithoutEventsInput, MeetingUncheckedCreateWithoutEventsInput> | MeetingCreateWithoutEventsInput[] | MeetingUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutEventsInput | MeetingCreateOrConnectWithoutEventsInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutEventsInput | MeetingUpsertWithWhereUniqueWithoutEventsInput[]
    createMany?: MeetingCreateManyEventsInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutEventsInput | MeetingUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutEventsInput | MeetingUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EntertainmentUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<EntertainmentCreateWithoutEventsInput, EntertainmentUncheckedCreateWithoutEventsInput> | EntertainmentCreateWithoutEventsInput[] | EntertainmentUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: EntertainmentCreateOrConnectWithoutEventsInput | EntertainmentCreateOrConnectWithoutEventsInput[]
    upsert?: EntertainmentUpsertWithWhereUniqueWithoutEventsInput | EntertainmentUpsertWithWhereUniqueWithoutEventsInput[]
    set?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    disconnect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    delete?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    connect?: EntertainmentWhereUniqueInput | EntertainmentWhereUniqueInput[]
    update?: EntertainmentUpdateWithWhereUniqueWithoutEventsInput | EntertainmentUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: EntertainmentUpdateManyWithWhereWithoutEventsInput | EntertainmentUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: EntertainmentScalarWhereInput | EntertainmentScalarWhereInput[]
  }

  export type LuxuryUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<LuxuryCreateWithoutEventsInput, LuxuryUncheckedCreateWithoutEventsInput> | LuxuryCreateWithoutEventsInput[] | LuxuryUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: LuxuryCreateOrConnectWithoutEventsInput | LuxuryCreateOrConnectWithoutEventsInput[]
    upsert?: LuxuryUpsertWithWhereUniqueWithoutEventsInput | LuxuryUpsertWithWhereUniqueWithoutEventsInput[]
    set?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    disconnect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    delete?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    connect?: LuxuryWhereUniqueInput | LuxuryWhereUniqueInput[]
    update?: LuxuryUpdateWithWhereUniqueWithoutEventsInput | LuxuryUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: LuxuryUpdateManyWithWhereWithoutEventsInput | LuxuryUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: LuxuryScalarWhereInput | LuxuryScalarWhereInput[]
  }

  export type MusicalUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<MusicalCreateWithoutEventsInput, MusicalUncheckedCreateWithoutEventsInput> | MusicalCreateWithoutEventsInput[] | MusicalUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MusicalCreateOrConnectWithoutEventsInput | MusicalCreateOrConnectWithoutEventsInput[]
    upsert?: MusicalUpsertWithWhereUniqueWithoutEventsInput | MusicalUpsertWithWhereUniqueWithoutEventsInput[]
    set?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    disconnect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    delete?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    connect?: MusicalWhereUniqueInput | MusicalWhereUniqueInput[]
    update?: MusicalUpdateWithWhereUniqueWithoutEventsInput | MusicalUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: MusicalUpdateManyWithWhereWithoutEventsInput | MusicalUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
  }

  export type MultimediaUncheckedUpdateManyWithoutEventsNestedInput = {
    create?: XOR<MultimediaCreateWithoutEventsInput, MultimediaUncheckedCreateWithoutEventsInput> | MultimediaCreateWithoutEventsInput[] | MultimediaUncheckedCreateWithoutEventsInput[]
    connectOrCreate?: MultimediaCreateOrConnectWithoutEventsInput | MultimediaCreateOrConnectWithoutEventsInput[]
    upsert?: MultimediaUpsertWithWhereUniqueWithoutEventsInput | MultimediaUpsertWithWhereUniqueWithoutEventsInput[]
    set?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    disconnect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    delete?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    connect?: MultimediaWhereUniqueInput | MultimediaWhereUniqueInput[]
    update?: MultimediaUpdateWithWhereUniqueWithoutEventsInput | MultimediaUpdateWithWhereUniqueWithoutEventsInput[]
    updateMany?: MultimediaUpdateManyWithWhereWithoutEventsInput | MultimediaUpdateManyWithWhereWithoutEventsInput[]
    deleteMany?: MultimediaScalarWhereInput | MultimediaScalarWhereInput[]
  }

  export type EventEventTypeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventEventTypeCreateWithoutEventInput, EventEventTypeUncheckedCreateWithoutEventInput> | EventEventTypeCreateWithoutEventInput[] | EventEventTypeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventInput | EventEventTypeCreateOrConnectWithoutEventInput[]
    upsert?: EventEventTypeUpsertWithWhereUniqueWithoutEventInput | EventEventTypeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventEventTypeCreateManyEventInputEnvelope
    set?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    disconnect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    delete?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    update?: EventEventTypeUpdateWithWhereUniqueWithoutEventInput | EventEventTypeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventEventTypeUpdateManyWithWhereWithoutEventInput | EventEventTypeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventEventTypeScalarWhereInput | EventEventTypeScalarWhereInput[]
  }

  export type EventEventTypeCreateNestedManyWithoutEventTypeInput = {
    create?: XOR<EventEventTypeCreateWithoutEventTypeInput, EventEventTypeUncheckedCreateWithoutEventTypeInput> | EventEventTypeCreateWithoutEventTypeInput[] | EventEventTypeUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventTypeInput | EventEventTypeCreateOrConnectWithoutEventTypeInput[]
    createMany?: EventEventTypeCreateManyEventTypeInputEnvelope
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
  }

  export type EventEventTypeUncheckedCreateNestedManyWithoutEventTypeInput = {
    create?: XOR<EventEventTypeCreateWithoutEventTypeInput, EventEventTypeUncheckedCreateWithoutEventTypeInput> | EventEventTypeCreateWithoutEventTypeInput[] | EventEventTypeUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventTypeInput | EventEventTypeCreateOrConnectWithoutEventTypeInput[]
    createMany?: EventEventTypeCreateManyEventTypeInputEnvelope
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
  }

  export type EventEventTypeUpdateManyWithoutEventTypeNestedInput = {
    create?: XOR<EventEventTypeCreateWithoutEventTypeInput, EventEventTypeUncheckedCreateWithoutEventTypeInput> | EventEventTypeCreateWithoutEventTypeInput[] | EventEventTypeUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventTypeInput | EventEventTypeCreateOrConnectWithoutEventTypeInput[]
    upsert?: EventEventTypeUpsertWithWhereUniqueWithoutEventTypeInput | EventEventTypeUpsertWithWhereUniqueWithoutEventTypeInput[]
    createMany?: EventEventTypeCreateManyEventTypeInputEnvelope
    set?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    disconnect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    delete?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    update?: EventEventTypeUpdateWithWhereUniqueWithoutEventTypeInput | EventEventTypeUpdateWithWhereUniqueWithoutEventTypeInput[]
    updateMany?: EventEventTypeUpdateManyWithWhereWithoutEventTypeInput | EventEventTypeUpdateManyWithWhereWithoutEventTypeInput[]
    deleteMany?: EventEventTypeScalarWhereInput | EventEventTypeScalarWhereInput[]
  }

  export type EventEventTypeUncheckedUpdateManyWithoutEventTypeNestedInput = {
    create?: XOR<EventEventTypeCreateWithoutEventTypeInput, EventEventTypeUncheckedCreateWithoutEventTypeInput> | EventEventTypeCreateWithoutEventTypeInput[] | EventEventTypeUncheckedCreateWithoutEventTypeInput[]
    connectOrCreate?: EventEventTypeCreateOrConnectWithoutEventTypeInput | EventEventTypeCreateOrConnectWithoutEventTypeInput[]
    upsert?: EventEventTypeUpsertWithWhereUniqueWithoutEventTypeInput | EventEventTypeUpsertWithWhereUniqueWithoutEventTypeInput[]
    createMany?: EventEventTypeCreateManyEventTypeInputEnvelope
    set?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    disconnect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    delete?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    connect?: EventEventTypeWhereUniqueInput | EventEventTypeWhereUniqueInput[]
    update?: EventEventTypeUpdateWithWhereUniqueWithoutEventTypeInput | EventEventTypeUpdateWithWhereUniqueWithoutEventTypeInput[]
    updateMany?: EventEventTypeUpdateManyWithWhereWithoutEventTypeInput | EventEventTypeUpdateManyWithWhereWithoutEventTypeInput[]
    deleteMany?: EventEventTypeScalarWhereInput | EventEventTypeScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutEventTypesInput = {
    create?: XOR<EventCreateWithoutEventTypesInput, EventUncheckedCreateWithoutEventTypesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventTypesInput
    connect?: EventWhereUniqueInput
  }

  export type EventTypeCreateNestedOneWithoutEventsInput = {
    create?: XOR<EventTypeCreateWithoutEventsInput, EventTypeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutEventsInput
    connect?: EventTypeWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEventTypesNestedInput = {
    create?: XOR<EventCreateWithoutEventTypesInput, EventUncheckedCreateWithoutEventTypesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventTypesInput
    upsert?: EventUpsertWithoutEventTypesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventTypesInput, EventUpdateWithoutEventTypesInput>, EventUncheckedUpdateWithoutEventTypesInput>
  }

  export type EventTypeUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<EventTypeCreateWithoutEventsInput, EventTypeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutEventsInput
    upsert?: EventTypeUpsertWithoutEventsInput
    connect?: EventTypeWhereUniqueInput
    update?: XOR<XOR<EventTypeUpdateToOneWithWhereWithoutEventsInput, EventTypeUpdateWithoutEventsInput>, EventTypeUncheckedUpdateWithoutEventsInput>
  }

  export type ProductCreateNestedOneWithoutMultimediaInput = {
    create?: XOR<ProductCreateWithoutMultimediaInput, ProductUncheckedCreateWithoutMultimediaInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMultimediaInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutMultimediaInput = {
    create?: XOR<EventCreateWithoutMultimediaInput, EventUncheckedCreateWithoutMultimediaInput> | EventCreateWithoutMultimediaInput[] | EventUncheckedCreateWithoutMultimediaInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMultimediaInput | EventCreateOrConnectWithoutMultimediaInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutMultimediaInput = {
    create?: XOR<EventCreateWithoutMultimediaInput, EventUncheckedCreateWithoutMultimediaInput> | EventCreateWithoutMultimediaInput[] | EventUncheckedCreateWithoutMultimediaInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMultimediaInput | EventCreateOrConnectWithoutMultimediaInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutMultimediaNestedInput = {
    create?: XOR<ProductCreateWithoutMultimediaInput, ProductUncheckedCreateWithoutMultimediaInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMultimediaInput
    upsert?: ProductUpsertWithoutMultimediaInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMultimediaInput, ProductUpdateWithoutMultimediaInput>, ProductUncheckedUpdateWithoutMultimediaInput>
  }

  export type EventUpdateManyWithoutMultimediaNestedInput = {
    create?: XOR<EventCreateWithoutMultimediaInput, EventUncheckedCreateWithoutMultimediaInput> | EventCreateWithoutMultimediaInput[] | EventUncheckedCreateWithoutMultimediaInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMultimediaInput | EventCreateOrConnectWithoutMultimediaInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutMultimediaInput | EventUpsertWithWhereUniqueWithoutMultimediaInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutMultimediaInput | EventUpdateWithWhereUniqueWithoutMultimediaInput[]
    updateMany?: EventUpdateManyWithWhereWithoutMultimediaInput | EventUpdateManyWithWhereWithoutMultimediaInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutMultimediaNestedInput = {
    create?: XOR<EventCreateWithoutMultimediaInput, EventUncheckedCreateWithoutMultimediaInput> | EventCreateWithoutMultimediaInput[] | EventUncheckedCreateWithoutMultimediaInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMultimediaInput | EventCreateOrConnectWithoutMultimediaInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutMultimediaInput | EventUpsertWithWhereUniqueWithoutMultimediaInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutMultimediaInput | EventUpdateWithWhereUniqueWithoutMultimediaInput[]
    updateMany?: EventUpdateManyWithWhereWithoutMultimediaInput | EventUpdateManyWithWhereWithoutMultimediaInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutMusicalInput = {
    create?: XOR<ProductCreateWithoutMusicalInput, ProductUncheckedCreateWithoutMusicalInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMusicalInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutMusicalInput = {
    create?: XOR<EventCreateWithoutMusicalInput, EventUncheckedCreateWithoutMusicalInput> | EventCreateWithoutMusicalInput[] | EventUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMusicalInput | EventCreateOrConnectWithoutMusicalInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutMusicalInput = {
    create?: XOR<EventCreateWithoutMusicalInput, EventUncheckedCreateWithoutMusicalInput> | EventCreateWithoutMusicalInput[] | EventUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMusicalInput | EventCreateOrConnectWithoutMusicalInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutMusicalNestedInput = {
    create?: XOR<ProductCreateWithoutMusicalInput, ProductUncheckedCreateWithoutMusicalInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMusicalInput
    upsert?: ProductUpsertWithoutMusicalInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMusicalInput, ProductUpdateWithoutMusicalInput>, ProductUncheckedUpdateWithoutMusicalInput>
  }

  export type EventUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<EventCreateWithoutMusicalInput, EventUncheckedCreateWithoutMusicalInput> | EventCreateWithoutMusicalInput[] | EventUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMusicalInput | EventCreateOrConnectWithoutMusicalInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutMusicalInput | EventUpsertWithWhereUniqueWithoutMusicalInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutMusicalInput | EventUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: EventUpdateManyWithWhereWithoutMusicalInput | EventUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutMusicalNestedInput = {
    create?: XOR<EventCreateWithoutMusicalInput, EventUncheckedCreateWithoutMusicalInput> | EventCreateWithoutMusicalInput[] | EventUncheckedCreateWithoutMusicalInput[]
    connectOrCreate?: EventCreateOrConnectWithoutMusicalInput | EventCreateOrConnectWithoutMusicalInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutMusicalInput | EventUpsertWithWhereUniqueWithoutMusicalInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutMusicalInput | EventUpdateWithWhereUniqueWithoutMusicalInput[]
    updateMany?: EventUpdateManyWithWhereWithoutMusicalInput | EventUpdateManyWithWhereWithoutMusicalInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutLuxuryInput = {
    create?: XOR<ProductCreateWithoutLuxuryInput, ProductUncheckedCreateWithoutLuxuryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutLuxuryInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutLuxuryInput = {
    create?: XOR<EventCreateWithoutLuxuryInput, EventUncheckedCreateWithoutLuxuryInput> | EventCreateWithoutLuxuryInput[] | EventUncheckedCreateWithoutLuxuryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLuxuryInput | EventCreateOrConnectWithoutLuxuryInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutLuxuryInput = {
    create?: XOR<EventCreateWithoutLuxuryInput, EventUncheckedCreateWithoutLuxuryInput> | EventCreateWithoutLuxuryInput[] | EventUncheckedCreateWithoutLuxuryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLuxuryInput | EventCreateOrConnectWithoutLuxuryInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutLuxuryNestedInput = {
    create?: XOR<ProductCreateWithoutLuxuryInput, ProductUncheckedCreateWithoutLuxuryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutLuxuryInput
    upsert?: ProductUpsertWithoutLuxuryInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutLuxuryInput, ProductUpdateWithoutLuxuryInput>, ProductUncheckedUpdateWithoutLuxuryInput>
  }

  export type EventUpdateManyWithoutLuxuryNestedInput = {
    create?: XOR<EventCreateWithoutLuxuryInput, EventUncheckedCreateWithoutLuxuryInput> | EventCreateWithoutLuxuryInput[] | EventUncheckedCreateWithoutLuxuryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLuxuryInput | EventCreateOrConnectWithoutLuxuryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLuxuryInput | EventUpsertWithWhereUniqueWithoutLuxuryInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLuxuryInput | EventUpdateWithWhereUniqueWithoutLuxuryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLuxuryInput | EventUpdateManyWithWhereWithoutLuxuryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutLuxuryNestedInput = {
    create?: XOR<EventCreateWithoutLuxuryInput, EventUncheckedCreateWithoutLuxuryInput> | EventCreateWithoutLuxuryInput[] | EventUncheckedCreateWithoutLuxuryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLuxuryInput | EventCreateOrConnectWithoutLuxuryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLuxuryInput | EventUpsertWithWhereUniqueWithoutLuxuryInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLuxuryInput | EventUpdateWithWhereUniqueWithoutLuxuryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLuxuryInput | EventUpdateManyWithWhereWithoutLuxuryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutEntertainmentInput = {
    create?: XOR<ProductCreateWithoutEntertainmentInput, ProductUncheckedCreateWithoutEntertainmentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutEntertainmentInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutEntertainmentInput = {
    create?: XOR<EventCreateWithoutEntertainmentInput, EventUncheckedCreateWithoutEntertainmentInput> | EventCreateWithoutEntertainmentInput[] | EventUncheckedCreateWithoutEntertainmentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutEntertainmentInput | EventCreateOrConnectWithoutEntertainmentInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutEntertainmentInput = {
    create?: XOR<EventCreateWithoutEntertainmentInput, EventUncheckedCreateWithoutEntertainmentInput> | EventCreateWithoutEntertainmentInput[] | EventUncheckedCreateWithoutEntertainmentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutEntertainmentInput | EventCreateOrConnectWithoutEntertainmentInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutEntertainmentNestedInput = {
    create?: XOR<ProductCreateWithoutEntertainmentInput, ProductUncheckedCreateWithoutEntertainmentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutEntertainmentInput
    upsert?: ProductUpsertWithoutEntertainmentInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutEntertainmentInput, ProductUpdateWithoutEntertainmentInput>, ProductUncheckedUpdateWithoutEntertainmentInput>
  }

  export type EventUpdateManyWithoutEntertainmentNestedInput = {
    create?: XOR<EventCreateWithoutEntertainmentInput, EventUncheckedCreateWithoutEntertainmentInput> | EventCreateWithoutEntertainmentInput[] | EventUncheckedCreateWithoutEntertainmentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutEntertainmentInput | EventCreateOrConnectWithoutEntertainmentInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutEntertainmentInput | EventUpsertWithWhereUniqueWithoutEntertainmentInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutEntertainmentInput | EventUpdateWithWhereUniqueWithoutEntertainmentInput[]
    updateMany?: EventUpdateManyWithWhereWithoutEntertainmentInput | EventUpdateManyWithWhereWithoutEntertainmentInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutEntertainmentNestedInput = {
    create?: XOR<EventCreateWithoutEntertainmentInput, EventUncheckedCreateWithoutEntertainmentInput> | EventCreateWithoutEntertainmentInput[] | EventUncheckedCreateWithoutEntertainmentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutEntertainmentInput | EventCreateOrConnectWithoutEntertainmentInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutEntertainmentInput | EventUpsertWithWhereUniqueWithoutEntertainmentInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutEntertainmentInput | EventUpdateWithWhereUniqueWithoutEntertainmentInput[]
    updateMany?: EventUpdateManyWithWhereWithoutEntertainmentInput | EventUpdateManyWithWhereWithoutEntertainmentInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutMeetingInput = {
    create?: XOR<ProductCreateWithoutMeetingInput, ProductUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMeetingInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutMeetingInput = {
    create?: XOR<EventCreateWithoutMeetingInput, EventUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: EventCreateOrConnectWithoutMeetingInput
    connect?: EventWhereUniqueInput
  }

  export type ProductUpdateOneWithoutMeetingNestedInput = {
    create?: XOR<ProductCreateWithoutMeetingInput, ProductUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMeetingInput
    upsert?: ProductUpsertWithoutMeetingInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMeetingInput, ProductUpdateWithoutMeetingInput>, ProductUncheckedUpdateWithoutMeetingInput>
  }

  export type EventUpdateOneRequiredWithoutMeetingNestedInput = {
    create?: XOR<EventCreateWithoutMeetingInput, EventUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: EventCreateOrConnectWithoutMeetingInput
    upsert?: EventUpsertWithoutMeetingInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutMeetingInput, EventUpdateWithoutMeetingInput>, EventUncheckedUpdateWithoutMeetingInput>
  }

  export type ProductCreateNestedOneWithoutBeautydecorInput = {
    create?: XOR<ProductCreateWithoutBeautydecorInput, ProductUncheckedCreateWithoutBeautydecorInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBeautydecorInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutBeautyDecorInput = {
    create?: XOR<EventCreateWithoutBeautyDecorInput, EventUncheckedCreateWithoutBeautyDecorInput> | EventCreateWithoutBeautyDecorInput[] | EventUncheckedCreateWithoutBeautyDecorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBeautyDecorInput | EventCreateOrConnectWithoutBeautyDecorInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutBeautyDecorInput = {
    create?: XOR<EventCreateWithoutBeautyDecorInput, EventUncheckedCreateWithoutBeautyDecorInput> | EventCreateWithoutBeautyDecorInput[] | EventUncheckedCreateWithoutBeautyDecorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBeautyDecorInput | EventCreateOrConnectWithoutBeautyDecorInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutBeautydecorNestedInput = {
    create?: XOR<ProductCreateWithoutBeautydecorInput, ProductUncheckedCreateWithoutBeautydecorInput>
    connectOrCreate?: ProductCreateOrConnectWithoutBeautydecorInput
    upsert?: ProductUpsertWithoutBeautydecorInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutBeautydecorInput, ProductUpdateWithoutBeautydecorInput>, ProductUncheckedUpdateWithoutBeautydecorInput>
  }

  export type EventUpdateManyWithoutBeautyDecorNestedInput = {
    create?: XOR<EventCreateWithoutBeautyDecorInput, EventUncheckedCreateWithoutBeautyDecorInput> | EventCreateWithoutBeautyDecorInput[] | EventUncheckedCreateWithoutBeautyDecorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBeautyDecorInput | EventCreateOrConnectWithoutBeautyDecorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutBeautyDecorInput | EventUpsertWithWhereUniqueWithoutBeautyDecorInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutBeautyDecorInput | EventUpdateWithWhereUniqueWithoutBeautyDecorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutBeautyDecorInput | EventUpdateManyWithWhereWithoutBeautyDecorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutBeautyDecorNestedInput = {
    create?: XOR<EventCreateWithoutBeautyDecorInput, EventUncheckedCreateWithoutBeautyDecorInput> | EventCreateWithoutBeautyDecorInput[] | EventUncheckedCreateWithoutBeautyDecorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBeautyDecorInput | EventCreateOrConnectWithoutBeautyDecorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutBeautyDecorInput | EventUpsertWithWhereUniqueWithoutBeautyDecorInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutBeautyDecorInput | EventUpdateWithWhereUniqueWithoutBeautyDecorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutBeautyDecorInput | EventUpdateManyWithWhereWithoutBeautyDecorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutAdventureInput = {
    create?: XOR<ProductCreateWithoutAdventureInput, ProductUncheckedCreateWithoutAdventureInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdventureInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutAdventureInput = {
    create?: XOR<EventCreateWithoutAdventureInput, EventUncheckedCreateWithoutAdventureInput> | EventCreateWithoutAdventureInput[] | EventUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdventureInput | EventCreateOrConnectWithoutAdventureInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutAdventureInput = {
    create?: XOR<EventCreateWithoutAdventureInput, EventUncheckedCreateWithoutAdventureInput> | EventCreateWithoutAdventureInput[] | EventUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdventureInput | EventCreateOrConnectWithoutAdventureInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutAdventureNestedInput = {
    create?: XOR<ProductCreateWithoutAdventureInput, ProductUncheckedCreateWithoutAdventureInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdventureInput
    upsert?: ProductUpsertWithoutAdventureInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdventureInput, ProductUpdateWithoutAdventureInput>, ProductUncheckedUpdateWithoutAdventureInput>
  }

  export type EventUpdateManyWithoutAdventureNestedInput = {
    create?: XOR<EventCreateWithoutAdventureInput, EventUncheckedCreateWithoutAdventureInput> | EventCreateWithoutAdventureInput[] | EventUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdventureInput | EventCreateOrConnectWithoutAdventureInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAdventureInput | EventUpsertWithWhereUniqueWithoutAdventureInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAdventureInput | EventUpdateWithWhereUniqueWithoutAdventureInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAdventureInput | EventUpdateManyWithWhereWithoutAdventureInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutAdventureNestedInput = {
    create?: XOR<EventCreateWithoutAdventureInput, EventUncheckedCreateWithoutAdventureInput> | EventCreateWithoutAdventureInput[] | EventUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdventureInput | EventCreateOrConnectWithoutAdventureInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAdventureInput | EventUpsertWithWhereUniqueWithoutAdventureInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAdventureInput | EventUpdateWithWhereUniqueWithoutAdventureInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAdventureInput | EventUpdateManyWithWhereWithoutAdventureInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutPartypalaceInput = {
    create?: XOR<ProductCreateWithoutPartypalaceInput, ProductUncheckedCreateWithoutPartypalaceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPartypalaceInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutPartyPalaceInput = {
    create?: XOR<EventCreateWithoutPartyPalaceInput, EventUncheckedCreateWithoutPartyPalaceInput> | EventCreateWithoutPartyPalaceInput[] | EventUncheckedCreateWithoutPartyPalaceInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPartyPalaceInput | EventCreateOrConnectWithoutPartyPalaceInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutPartyPalaceInput = {
    create?: XOR<EventCreateWithoutPartyPalaceInput, EventUncheckedCreateWithoutPartyPalaceInput> | EventCreateWithoutPartyPalaceInput[] | EventUncheckedCreateWithoutPartyPalaceInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPartyPalaceInput | EventCreateOrConnectWithoutPartyPalaceInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutPartypalaceNestedInput = {
    create?: XOR<ProductCreateWithoutPartypalaceInput, ProductUncheckedCreateWithoutPartypalaceInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPartypalaceInput
    upsert?: ProductUpsertWithoutPartypalaceInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPartypalaceInput, ProductUpdateWithoutPartypalaceInput>, ProductUncheckedUpdateWithoutPartypalaceInput>
  }

  export type EventUpdateManyWithoutPartyPalaceNestedInput = {
    create?: XOR<EventCreateWithoutPartyPalaceInput, EventUncheckedCreateWithoutPartyPalaceInput> | EventCreateWithoutPartyPalaceInput[] | EventUncheckedCreateWithoutPartyPalaceInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPartyPalaceInput | EventCreateOrConnectWithoutPartyPalaceInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutPartyPalaceInput | EventUpsertWithWhereUniqueWithoutPartyPalaceInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutPartyPalaceInput | EventUpdateWithWhereUniqueWithoutPartyPalaceInput[]
    updateMany?: EventUpdateManyWithWhereWithoutPartyPalaceInput | EventUpdateManyWithWhereWithoutPartyPalaceInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutPartyPalaceNestedInput = {
    create?: XOR<EventCreateWithoutPartyPalaceInput, EventUncheckedCreateWithoutPartyPalaceInput> | EventCreateWithoutPartyPalaceInput[] | EventUncheckedCreateWithoutPartyPalaceInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPartyPalaceInput | EventCreateOrConnectWithoutPartyPalaceInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutPartyPalaceInput | EventUpsertWithWhereUniqueWithoutPartyPalaceInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutPartyPalaceInput | EventUpdateWithWhereUniqueWithoutPartyPalaceInput[]
    updateMany?: EventUpdateManyWithWhereWithoutPartyPalaceInput | EventUpdateManyWithWhereWithoutPartyPalaceInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCateringtentInput = {
    create?: XOR<ProductCreateWithoutCateringtentInput, ProductUncheckedCreateWithoutCateringtentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCateringtentInput
    connect?: ProductWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutCateringTentInput = {
    create?: XOR<EventCreateWithoutCateringTentInput, EventUncheckedCreateWithoutCateringTentInput> | EventCreateWithoutCateringTentInput[] | EventUncheckedCreateWithoutCateringTentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCateringTentInput | EventCreateOrConnectWithoutCateringTentInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCateringTentInput = {
    create?: XOR<EventCreateWithoutCateringTentInput, EventUncheckedCreateWithoutCateringTentInput> | EventCreateWithoutCateringTentInput[] | EventUncheckedCreateWithoutCateringTentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCateringTentInput | EventCreateOrConnectWithoutCateringTentInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ProductUpdateOneWithoutCateringtentNestedInput = {
    create?: XOR<ProductCreateWithoutCateringtentInput, ProductUncheckedCreateWithoutCateringtentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCateringtentInput
    upsert?: ProductUpsertWithoutCateringtentInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCateringtentInput, ProductUpdateWithoutCateringtentInput>, ProductUncheckedUpdateWithoutCateringtentInput>
  }

  export type EventUpdateManyWithoutCateringTentNestedInput = {
    create?: XOR<EventCreateWithoutCateringTentInput, EventUncheckedCreateWithoutCateringTentInput> | EventCreateWithoutCateringTentInput[] | EventUncheckedCreateWithoutCateringTentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCateringTentInput | EventCreateOrConnectWithoutCateringTentInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCateringTentInput | EventUpsertWithWhereUniqueWithoutCateringTentInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCateringTentInput | EventUpdateWithWhereUniqueWithoutCateringTentInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCateringTentInput | EventUpdateManyWithWhereWithoutCateringTentInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCateringTentNestedInput = {
    create?: XOR<EventCreateWithoutCateringTentInput, EventUncheckedCreateWithoutCateringTentInput> | EventCreateWithoutCateringTentInput[] | EventUncheckedCreateWithoutCateringTentInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCateringTentInput | EventCreateOrConnectWithoutCateringTentInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCateringTentInput | EventUpsertWithWhereUniqueWithoutCateringTentInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCateringTentInput | EventUpdateWithWhereUniqueWithoutCateringTentInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCateringTentInput | EventUpdateManyWithWhereWithoutCateringTentInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProduct_imageInput = {
    create?: XOR<ProductCreateWithoutProduct_imageInput, ProductUncheckedCreateWithoutProduct_imageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_imageInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneWithoutProduct_imageNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_imageInput, ProductUncheckedCreateWithoutProduct_imageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_imageInput
    upsert?: ProductUpsertWithoutProduct_imageInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProduct_imageInput, ProductUpdateWithoutProduct_imageInput>, ProductUncheckedUpdateWithoutProduct_imageInput>
  }

  export type UserCreateNestedOneWithoutBlogs_authorInput = {
    create?: XOR<UserCreateWithoutBlogs_authorInput, UserUncheckedCreateWithoutBlogs_authorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogs_authorInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlogs_approvedInput = {
    create?: XOR<UserCreateWithoutBlogs_approvedInput, UserUncheckedCreateWithoutBlogs_approvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogs_approvedInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutBlogs_authorNestedInput = {
    create?: XOR<UserCreateWithoutBlogs_authorInput, UserUncheckedCreateWithoutBlogs_authorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogs_authorInput
    upsert?: UserUpsertWithoutBlogs_authorInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogs_authorInput, UserUpdateWithoutBlogs_authorInput>, UserUncheckedUpdateWithoutBlogs_authorInput>
  }

  export type UserUpdateOneWithoutBlogs_approvedNestedInput = {
    create?: XOR<UserCreateWithoutBlogs_approvedInput, UserUncheckedCreateWithoutBlogs_approvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogs_approvedInput
    upsert?: UserUpsertWithoutBlogs_approvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogs_approvedInput, UserUpdateWithoutBlogs_approvedInput>, UserUncheckedUpdateWithoutBlogs_approvedInput>
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRatingsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type ProductUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRatingsInput
    upsert?: ProductUpsertWithoutRatingsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRatingsInput, ProductUpdateWithoutRatingsInput>, ProductUncheckedUpdateWithoutRatingsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EventCreateWithoutUserInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutUserInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutUserInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventCreateManyUserInputEnvelope = {
    data: EventCreateManyUserInput | EventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutApproved_byInput = {
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutBlogs_authorInput
  }

  export type BlogUncheckedCreateWithoutApproved_byInput = {
    id?: number
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: number | null
  }

  export type BlogCreateOrConnectWithoutApproved_byInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutApproved_byInput, BlogUncheckedCreateWithoutApproved_byInput>
  }

  export type BlogCreateManyApproved_byInputEnvelope = {
    data: BlogCreateManyApproved_byInput | BlogCreateManyApproved_byInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutAuthorInput = {
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approved_by?: UserCreateNestedOneWithoutBlogs_approvedInput
  }

  export type BlogUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approved_by_id?: number | null
  }

  export type BlogCreateOrConnectWithoutAuthorInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput>
  }

  export type BlogCreateManyAuthorInputEnvelope = {
    data: BlogCreateManyAuthorInput | BlogCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProductRatingCreateWithoutUserInput = {
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutRatingsInput
  }

  export type ProductRatingUncheckedCreateWithoutUserInput = {
    id?: number
    rating: number
    review?: string | null
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRatingCreateOrConnectWithoutUserInput = {
    where: ProductRatingWhereUniqueInput
    create: XOR<ProductRatingCreateWithoutUserInput, ProductRatingUncheckedCreateWithoutUserInput>
  }

  export type ProductRatingCreateManyUserInputEnvelope = {
    data: ProductRatingCreateManyUserInput | ProductRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithWhereWithoutUserInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUserInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: IntFilter<"Event"> | number
    start_date?: DateTimeFilter<"Event"> | Date | string
    end_date?: DateTimeFilter<"Event"> | Date | string
    start_time?: DateTimeNullableFilter<"Event"> | Date | string | null
    end_time?: DateTimeNullableFilter<"Event"> | Date | string | null
    is_approved?: BoolFilter<"Event"> | boolean
    is_rejected?: BoolFilter<"Event"> | boolean
    userId?: IntFilter<"Event"> | number
    productId?: IntFilter<"Event"> | number
    approved_by_id?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type BlogUpsertWithWhereUniqueWithoutApproved_byInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutApproved_byInput, BlogUncheckedUpdateWithoutApproved_byInput>
    create: XOR<BlogCreateWithoutApproved_byInput, BlogUncheckedCreateWithoutApproved_byInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutApproved_byInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutApproved_byInput, BlogUncheckedUpdateWithoutApproved_byInput>
  }

  export type BlogUpdateManyWithWhereWithoutApproved_byInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutApproved_byInput>
  }

  export type BlogScalarWhereInput = {
    AND?: BlogScalarWhereInput | BlogScalarWhereInput[]
    OR?: BlogScalarWhereInput[]
    NOT?: BlogScalarWhereInput | BlogScalarWhereInput[]
    id?: IntFilter<"Blog"> | number
    title?: StringFilter<"Blog"> | string
    short_description?: StringNullableFilter<"Blog"> | string | null
    image?: StringFilter<"Blog"> | string
    description?: StringFilter<"Blog"> | string
    is_approved?: BoolNullableFilter<"Blog"> | boolean | null
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    authorId?: IntNullableFilter<"Blog"> | number | null
    approved_by_id?: IntNullableFilter<"Blog"> | number | null
  }

  export type BlogUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutAuthorInput, BlogUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutAuthorInput, BlogUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ProductRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductRatingWhereUniqueInput
    update: XOR<ProductRatingUpdateWithoutUserInput, ProductRatingUncheckedUpdateWithoutUserInput>
    create: XOR<ProductRatingCreateWithoutUserInput, ProductRatingUncheckedCreateWithoutUserInput>
  }

  export type ProductRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductRatingWhereUniqueInput
    data: XOR<ProductRatingUpdateWithoutUserInput, ProductRatingUncheckedUpdateWithoutUserInput>
  }

  export type ProductRatingUpdateManyWithWhereWithoutUserInput = {
    where: ProductRatingScalarWhereInput
    data: XOR<ProductRatingUpdateManyMutationInput, ProductRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductRatingScalarWhereInput = {
    AND?: ProductRatingScalarWhereInput | ProductRatingScalarWhereInput[]
    OR?: ProductRatingScalarWhereInput[]
    NOT?: ProductRatingScalarWhereInput | ProductRatingScalarWhereInput[]
    id?: IntFilter<"ProductRating"> | number
    rating?: IntFilter<"ProductRating"> | number
    review?: StringNullableFilter<"ProductRating"> | string | null
    userId?: IntFilter<"ProductRating"> | number
    productId?: IntFilter<"ProductRating"> | number
    createdAt?: DateTimeFilter<"ProductRating"> | Date | string
    updatedAt?: DateTimeFilter<"ProductRating"> | Date | string
  }

  export type ProductCreateWithoutCategoryInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    address?: StringFilter<"Product"> | string
    short_description?: StringNullableFilter<"Product"> | string | null
    is_active?: BoolFilter<"Product"> | boolean
    overall_rating?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category_id?: IntFilter<"Product"> | number
    districtId?: IntFilter<"Product"> | number
    businessId?: IntFilter<"Product"> | number
  }

  export type ProductCreateWithoutDistrictInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutDistrictInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDistrictInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDistrictInput, ProductUncheckedCreateWithoutDistrictInput>
  }

  export type ProductCreateManyDistrictInputEnvelope = {
    data: ProductCreateManyDistrictInput | ProductCreateManyDistrictInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutDistrictInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutDistrictInput, ProductUncheckedUpdateWithoutDistrictInput>
    create: XOR<ProductCreateWithoutDistrictInput, ProductUncheckedCreateWithoutDistrictInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutDistrictInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutDistrictInput, ProductUncheckedUpdateWithoutDistrictInput>
  }

  export type ProductUpdateManyWithWhereWithoutDistrictInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutDistrictInput>
  }

  export type ProductCreateWithoutVenueInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutVenueInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVenueInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVenueInput, ProductUncheckedCreateWithoutVenueInput>
  }

  export type ProductCreateManyVenueInputEnvelope = {
    data: ProductCreateManyVenueInput | ProductCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutVenueInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutVenueInput, ProductUncheckedUpdateWithoutVenueInput>
    create: XOR<ProductCreateWithoutVenueInput, ProductUncheckedCreateWithoutVenueInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutVenueInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutVenueInput, ProductUncheckedUpdateWithoutVenueInput>
  }

  export type ProductUpdateManyWithWhereWithoutVenueInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutVenueInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    category_name: string
    category_icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    category_name: string
    category_icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type MultimediaCreateWithoutProductInput = {
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutMultimediaInput
  }

  export type MultimediaUncheckedCreateWithoutProductInput = {
    id?: number
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutMultimediaInput
  }

  export type MultimediaCreateOrConnectWithoutProductInput = {
    where: MultimediaWhereUniqueInput
    create: XOR<MultimediaCreateWithoutProductInput, MultimediaUncheckedCreateWithoutProductInput>
  }

  export type MultimediaCreateManyProductInputEnvelope = {
    data: MultimediaCreateManyProductInput | MultimediaCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type EntertainmentCreateWithoutProductInput = {
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutEntertainmentInput
  }

  export type EntertainmentUncheckedCreateWithoutProductInput = {
    id?: number
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutEntertainmentInput
  }

  export type EntertainmentCreateOrConnectWithoutProductInput = {
    where: EntertainmentWhereUniqueInput
    create: XOR<EntertainmentCreateWithoutProductInput, EntertainmentUncheckedCreateWithoutProductInput>
  }

  export type EntertainmentCreateManyProductInputEnvelope = {
    data: EntertainmentCreateManyProductInput | EntertainmentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type MusicalCreateWithoutProductInput = {
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutMusicalInput
  }

  export type MusicalUncheckedCreateWithoutProductInput = {
    id?: number
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutMusicalInput
  }

  export type MusicalCreateOrConnectWithoutProductInput = {
    where: MusicalWhereUniqueInput
    create: XOR<MusicalCreateWithoutProductInput, MusicalUncheckedCreateWithoutProductInput>
  }

  export type MusicalCreateManyProductInputEnvelope = {
    data: MusicalCreateManyProductInput | MusicalCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type LuxuryCreateWithoutProductInput = {
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutLuxuryInput
  }

  export type LuxuryUncheckedCreateWithoutProductInput = {
    id?: number
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutLuxuryInput
  }

  export type LuxuryCreateOrConnectWithoutProductInput = {
    where: LuxuryWhereUniqueInput
    create: XOR<LuxuryCreateWithoutProductInput, LuxuryUncheckedCreateWithoutProductInput>
  }

  export type LuxuryCreateManyProductInputEnvelope = {
    data: LuxuryCreateManyProductInput | LuxuryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutProductInput = {
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events: EventCreateNestedOneWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutProductInput = {
    id?: number
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventId: number
  }

  export type MeetingCreateOrConnectWithoutProductInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutProductInput, MeetingUncheckedCreateWithoutProductInput>
  }

  export type MeetingCreateManyProductInputEnvelope = {
    data: MeetingCreateManyProductInput | MeetingCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BeautyDecorCreateWithoutProductInput = {
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutBeautyDecorInput
  }

  export type BeautyDecorUncheckedCreateWithoutProductInput = {
    id?: number
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutBeautyDecorInput
  }

  export type BeautyDecorCreateOrConnectWithoutProductInput = {
    where: BeautyDecorWhereUniqueInput
    create: XOR<BeautyDecorCreateWithoutProductInput, BeautyDecorUncheckedCreateWithoutProductInput>
  }

  export type BeautyDecorCreateManyProductInputEnvelope = {
    data: BeautyDecorCreateManyProductInput | BeautyDecorCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AdventureCreateWithoutProductInput = {
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutAdventureInput
  }

  export type AdventureUncheckedCreateWithoutProductInput = {
    id?: number
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutAdventureInput
  }

  export type AdventureCreateOrConnectWithoutProductInput = {
    where: AdventureWhereUniqueInput
    create: XOR<AdventureCreateWithoutProductInput, AdventureUncheckedCreateWithoutProductInput>
  }

  export type AdventureCreateManyProductInputEnvelope = {
    data: AdventureCreateManyProductInput | AdventureCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PartyPalaceCreateWithoutProductInput = {
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutPartyPalaceInput
  }

  export type PartyPalaceUncheckedCreateWithoutProductInput = {
    id?: number
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutPartyPalaceInput
  }

  export type PartyPalaceCreateOrConnectWithoutProductInput = {
    where: PartyPalaceWhereUniqueInput
    create: XOR<PartyPalaceCreateWithoutProductInput, PartyPalaceUncheckedCreateWithoutProductInput>
  }

  export type PartyPalaceCreateManyProductInputEnvelope = {
    data: PartyPalaceCreateManyProductInput | PartyPalaceCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CateringTentCreateWithoutProductInput = {
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutCateringTentInput
  }

  export type CateringTentUncheckedCreateWithoutProductInput = {
    id?: number
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutCateringTentInput
  }

  export type CateringTentCreateOrConnectWithoutProductInput = {
    where: CateringTentWhereUniqueInput
    create: XOR<CateringTentCreateWithoutProductInput, CateringTentUncheckedCreateWithoutProductInput>
  }

  export type CateringTentCreateManyProductInputEnvelope = {
    data: CateringTentCreateManyProductInput | CateringTentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutProductInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutProductInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutProductInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutProductInput, EventUncheckedCreateWithoutProductInput>
  }

  export type EventCreateManyProductInputEnvelope = {
    data: EventCreateManyProductInput | EventCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductRatingCreateWithoutProductInput = {
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutRatingsInput
  }

  export type ProductRatingUncheckedCreateWithoutProductInput = {
    id?: number
    rating: number
    review?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRatingCreateOrConnectWithoutProductInput = {
    where: ProductRatingWhereUniqueInput
    create: XOR<ProductRatingCreateWithoutProductInput, ProductRatingUncheckedCreateWithoutProductInput>
  }

  export type ProductRatingCreateManyProductInputEnvelope = {
    data: ProductRatingCreateManyProductInput | ProductRatingCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type DistrictCreateWithoutProductsInput = {
    district_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistrictUncheckedCreateWithoutProductsInput = {
    id?: number
    district_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DistrictCreateOrConnectWithoutProductsInput = {
    where: DistrictWhereUniqueInput
    create: XOR<DistrictCreateWithoutProductsInput, DistrictUncheckedCreateWithoutProductsInput>
  }

  export type VenueCreateWithoutProductsInput = {
    venue_name: string
    venue_address: string
    contact_person: string
    phone_number: string
    email: string
    pan_vat_number?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUncheckedCreateWithoutProductsInput = {
    id?: number
    venue_name: string
    venue_address: string
    contact_person: string
    phone_number: string
    email: string
    pan_vat_number?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueCreateOrConnectWithoutProductsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutProductsInput, VenueUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    category_icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    category_icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultimediaUpsertWithWhereUniqueWithoutProductInput = {
    where: MultimediaWhereUniqueInput
    update: XOR<MultimediaUpdateWithoutProductInput, MultimediaUncheckedUpdateWithoutProductInput>
    create: XOR<MultimediaCreateWithoutProductInput, MultimediaUncheckedCreateWithoutProductInput>
  }

  export type MultimediaUpdateWithWhereUniqueWithoutProductInput = {
    where: MultimediaWhereUniqueInput
    data: XOR<MultimediaUpdateWithoutProductInput, MultimediaUncheckedUpdateWithoutProductInput>
  }

  export type MultimediaUpdateManyWithWhereWithoutProductInput = {
    where: MultimediaScalarWhereInput
    data: XOR<MultimediaUpdateManyMutationInput, MultimediaUncheckedUpdateManyWithoutProductInput>
  }

  export type MultimediaScalarWhereInput = {
    AND?: MultimediaScalarWhereInput | MultimediaScalarWhereInput[]
    OR?: MultimediaScalarWhereInput[]
    NOT?: MultimediaScalarWhereInput | MultimediaScalarWhereInput[]
    id?: IntFilter<"Multimedia"> | number
    multimedia_name?: StringFilter<"Multimedia"> | string
    price?: IntFilter<"Multimedia"> | number
    offerPrice?: IntNullableFilter<"Multimedia"> | number | null
    description?: StringNullableFilter<"Multimedia"> | string | null
    createdAt?: DateTimeFilter<"Multimedia"> | Date | string
    updatedAt?: DateTimeFilter<"Multimedia"> | Date | string
    productId?: IntNullableFilter<"Multimedia"> | number | null
  }

  export type EntertainmentUpsertWithWhereUniqueWithoutProductInput = {
    where: EntertainmentWhereUniqueInput
    update: XOR<EntertainmentUpdateWithoutProductInput, EntertainmentUncheckedUpdateWithoutProductInput>
    create: XOR<EntertainmentCreateWithoutProductInput, EntertainmentUncheckedCreateWithoutProductInput>
  }

  export type EntertainmentUpdateWithWhereUniqueWithoutProductInput = {
    where: EntertainmentWhereUniqueInput
    data: XOR<EntertainmentUpdateWithoutProductInput, EntertainmentUncheckedUpdateWithoutProductInput>
  }

  export type EntertainmentUpdateManyWithWhereWithoutProductInput = {
    where: EntertainmentScalarWhereInput
    data: XOR<EntertainmentUpdateManyMutationInput, EntertainmentUncheckedUpdateManyWithoutProductInput>
  }

  export type EntertainmentScalarWhereInput = {
    AND?: EntertainmentScalarWhereInput | EntertainmentScalarWhereInput[]
    OR?: EntertainmentScalarWhereInput[]
    NOT?: EntertainmentScalarWhereInput | EntertainmentScalarWhereInput[]
    id?: IntFilter<"Entertainment"> | number
    entertainment_name?: StringFilter<"Entertainment"> | string
    price?: IntFilter<"Entertainment"> | number
    offerPrice?: IntNullableFilter<"Entertainment"> | number | null
    description?: StringNullableFilter<"Entertainment"> | string | null
    createdAt?: DateTimeFilter<"Entertainment"> | Date | string
    updatedAt?: DateTimeFilter<"Entertainment"> | Date | string
    productId?: IntNullableFilter<"Entertainment"> | number | null
  }

  export type MusicalUpsertWithWhereUniqueWithoutProductInput = {
    where: MusicalWhereUniqueInput
    update: XOR<MusicalUpdateWithoutProductInput, MusicalUncheckedUpdateWithoutProductInput>
    create: XOR<MusicalCreateWithoutProductInput, MusicalUncheckedCreateWithoutProductInput>
  }

  export type MusicalUpdateWithWhereUniqueWithoutProductInput = {
    where: MusicalWhereUniqueInput
    data: XOR<MusicalUpdateWithoutProductInput, MusicalUncheckedUpdateWithoutProductInput>
  }

  export type MusicalUpdateManyWithWhereWithoutProductInput = {
    where: MusicalScalarWhereInput
    data: XOR<MusicalUpdateManyMutationInput, MusicalUncheckedUpdateManyWithoutProductInput>
  }

  export type MusicalScalarWhereInput = {
    AND?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
    OR?: MusicalScalarWhereInput[]
    NOT?: MusicalScalarWhereInput | MusicalScalarWhereInput[]
    id?: IntFilter<"Musical"> | number
    instrument_name?: StringFilter<"Musical"> | string
    price?: IntFilter<"Musical"> | number
    offerPrice?: IntNullableFilter<"Musical"> | number | null
    description?: StringNullableFilter<"Musical"> | string | null
    createdAt?: DateTimeFilter<"Musical"> | Date | string
    updatedAt?: DateTimeFilter<"Musical"> | Date | string
    productId?: IntNullableFilter<"Musical"> | number | null
  }

  export type LuxuryUpsertWithWhereUniqueWithoutProductInput = {
    where: LuxuryWhereUniqueInput
    update: XOR<LuxuryUpdateWithoutProductInput, LuxuryUncheckedUpdateWithoutProductInput>
    create: XOR<LuxuryCreateWithoutProductInput, LuxuryUncheckedCreateWithoutProductInput>
  }

  export type LuxuryUpdateWithWhereUniqueWithoutProductInput = {
    where: LuxuryWhereUniqueInput
    data: XOR<LuxuryUpdateWithoutProductInput, LuxuryUncheckedUpdateWithoutProductInput>
  }

  export type LuxuryUpdateManyWithWhereWithoutProductInput = {
    where: LuxuryScalarWhereInput
    data: XOR<LuxuryUpdateManyMutationInput, LuxuryUncheckedUpdateManyWithoutProductInput>
  }

  export type LuxuryScalarWhereInput = {
    AND?: LuxuryScalarWhereInput | LuxuryScalarWhereInput[]
    OR?: LuxuryScalarWhereInput[]
    NOT?: LuxuryScalarWhereInput | LuxuryScalarWhereInput[]
    id?: IntFilter<"Luxury"> | number
    luxury_name?: StringFilter<"Luxury"> | string
    price?: IntFilter<"Luxury"> | number
    offerPrice?: IntNullableFilter<"Luxury"> | number | null
    description?: StringNullableFilter<"Luxury"> | string | null
    createdAt?: DateTimeFilter<"Luxury"> | Date | string
    updatedAt?: DateTimeFilter<"Luxury"> | Date | string
    productId?: IntNullableFilter<"Luxury"> | number | null
  }

  export type MeetingUpsertWithWhereUniqueWithoutProductInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutProductInput, MeetingUncheckedUpdateWithoutProductInput>
    create: XOR<MeetingCreateWithoutProductInput, MeetingUncheckedCreateWithoutProductInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutProductInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutProductInput, MeetingUncheckedUpdateWithoutProductInput>
  }

  export type MeetingUpdateManyWithWhereWithoutProductInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutProductInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: IntFilter<"Meeting"> | number
    meeting_name?: StringFilter<"Meeting"> | string
    price?: IntFilter<"Meeting"> | number
    offerPrice?: IntNullableFilter<"Meeting"> | number | null
    description?: StringNullableFilter<"Meeting"> | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    productId?: IntNullableFilter<"Meeting"> | number | null
    eventId?: IntFilter<"Meeting"> | number
  }

  export type BeautyDecorUpsertWithWhereUniqueWithoutProductInput = {
    where: BeautyDecorWhereUniqueInput
    update: XOR<BeautyDecorUpdateWithoutProductInput, BeautyDecorUncheckedUpdateWithoutProductInput>
    create: XOR<BeautyDecorCreateWithoutProductInput, BeautyDecorUncheckedCreateWithoutProductInput>
  }

  export type BeautyDecorUpdateWithWhereUniqueWithoutProductInput = {
    where: BeautyDecorWhereUniqueInput
    data: XOR<BeautyDecorUpdateWithoutProductInput, BeautyDecorUncheckedUpdateWithoutProductInput>
  }

  export type BeautyDecorUpdateManyWithWhereWithoutProductInput = {
    where: BeautyDecorScalarWhereInput
    data: XOR<BeautyDecorUpdateManyMutationInput, BeautyDecorUncheckedUpdateManyWithoutProductInput>
  }

  export type BeautyDecorScalarWhereInput = {
    AND?: BeautyDecorScalarWhereInput | BeautyDecorScalarWhereInput[]
    OR?: BeautyDecorScalarWhereInput[]
    NOT?: BeautyDecorScalarWhereInput | BeautyDecorScalarWhereInput[]
    id?: IntFilter<"BeautyDecor"> | number
    beauty_name?: StringFilter<"BeautyDecor"> | string
    price?: IntFilter<"BeautyDecor"> | number
    offerPrice?: IntNullableFilter<"BeautyDecor"> | number | null
    description?: StringNullableFilter<"BeautyDecor"> | string | null
    createdAt?: DateTimeFilter<"BeautyDecor"> | Date | string
    updatedAt?: DateTimeFilter<"BeautyDecor"> | Date | string
    productId?: IntNullableFilter<"BeautyDecor"> | number | null
  }

  export type AdventureUpsertWithWhereUniqueWithoutProductInput = {
    where: AdventureWhereUniqueInput
    update: XOR<AdventureUpdateWithoutProductInput, AdventureUncheckedUpdateWithoutProductInput>
    create: XOR<AdventureCreateWithoutProductInput, AdventureUncheckedCreateWithoutProductInput>
  }

  export type AdventureUpdateWithWhereUniqueWithoutProductInput = {
    where: AdventureWhereUniqueInput
    data: XOR<AdventureUpdateWithoutProductInput, AdventureUncheckedUpdateWithoutProductInput>
  }

  export type AdventureUpdateManyWithWhereWithoutProductInput = {
    where: AdventureScalarWhereInput
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyWithoutProductInput>
  }

  export type AdventureScalarWhereInput = {
    AND?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
    OR?: AdventureScalarWhereInput[]
    NOT?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
    id?: IntFilter<"Adventure"> | number
    adventure_name?: StringFilter<"Adventure"> | string
    price?: IntFilter<"Adventure"> | number
    offerPrice?: IntNullableFilter<"Adventure"> | number | null
    description?: StringNullableFilter<"Adventure"> | string | null
    createdAt?: DateTimeFilter<"Adventure"> | Date | string
    updatedAt?: DateTimeFilter<"Adventure"> | Date | string
    productId?: IntNullableFilter<"Adventure"> | number | null
  }

  export type PartyPalaceUpsertWithWhereUniqueWithoutProductInput = {
    where: PartyPalaceWhereUniqueInput
    update: XOR<PartyPalaceUpdateWithoutProductInput, PartyPalaceUncheckedUpdateWithoutProductInput>
    create: XOR<PartyPalaceCreateWithoutProductInput, PartyPalaceUncheckedCreateWithoutProductInput>
  }

  export type PartyPalaceUpdateWithWhereUniqueWithoutProductInput = {
    where: PartyPalaceWhereUniqueInput
    data: XOR<PartyPalaceUpdateWithoutProductInput, PartyPalaceUncheckedUpdateWithoutProductInput>
  }

  export type PartyPalaceUpdateManyWithWhereWithoutProductInput = {
    where: PartyPalaceScalarWhereInput
    data: XOR<PartyPalaceUpdateManyMutationInput, PartyPalaceUncheckedUpdateManyWithoutProductInput>
  }

  export type PartyPalaceScalarWhereInput = {
    AND?: PartyPalaceScalarWhereInput | PartyPalaceScalarWhereInput[]
    OR?: PartyPalaceScalarWhereInput[]
    NOT?: PartyPalaceScalarWhereInput | PartyPalaceScalarWhereInput[]
    id?: IntFilter<"PartyPalace"> | number
    partypalace_name?: StringFilter<"PartyPalace"> | string
    price?: IntFilter<"PartyPalace"> | number
    offerPrice?: IntNullableFilter<"PartyPalace"> | number | null
    description?: StringNullableFilter<"PartyPalace"> | string | null
    createdAt?: DateTimeFilter<"PartyPalace"> | Date | string
    updatedAt?: DateTimeFilter<"PartyPalace"> | Date | string
    productId?: IntNullableFilter<"PartyPalace"> | number | null
  }

  export type CateringTentUpsertWithWhereUniqueWithoutProductInput = {
    where: CateringTentWhereUniqueInput
    update: XOR<CateringTentUpdateWithoutProductInput, CateringTentUncheckedUpdateWithoutProductInput>
    create: XOR<CateringTentCreateWithoutProductInput, CateringTentUncheckedCreateWithoutProductInput>
  }

  export type CateringTentUpdateWithWhereUniqueWithoutProductInput = {
    where: CateringTentWhereUniqueInput
    data: XOR<CateringTentUpdateWithoutProductInput, CateringTentUncheckedUpdateWithoutProductInput>
  }

  export type CateringTentUpdateManyWithWhereWithoutProductInput = {
    where: CateringTentScalarWhereInput
    data: XOR<CateringTentUpdateManyMutationInput, CateringTentUncheckedUpdateManyWithoutProductInput>
  }

  export type CateringTentScalarWhereInput = {
    AND?: CateringTentScalarWhereInput | CateringTentScalarWhereInput[]
    OR?: CateringTentScalarWhereInput[]
    NOT?: CateringTentScalarWhereInput | CateringTentScalarWhereInput[]
    id?: IntFilter<"CateringTent"> | number
    catering_name?: StringFilter<"CateringTent"> | string
    price?: IntFilter<"CateringTent"> | number
    offerPrice?: IntNullableFilter<"CateringTent"> | number | null
    description?: StringNullableFilter<"CateringTent"> | string | null
    createdAt?: DateTimeFilter<"CateringTent"> | Date | string
    updatedAt?: DateTimeFilter<"CateringTent"> | Date | string
    productId?: IntNullableFilter<"CateringTent"> | number | null
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    url?: StringFilter<"ProductImage"> | string
    productId?: IntNullableFilter<"ProductImage"> | number | null
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    updatedAt?: DateTimeFilter<"ProductImage"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutProductInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutProductInput, EventUncheckedUpdateWithoutProductInput>
    create: XOR<EventCreateWithoutProductInput, EventUncheckedCreateWithoutProductInput>
  }

  export type EventUpdateWithWhereUniqueWithoutProductInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutProductInput, EventUncheckedUpdateWithoutProductInput>
  }

  export type EventUpdateManyWithWhereWithoutProductInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductRatingUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductRatingWhereUniqueInput
    update: XOR<ProductRatingUpdateWithoutProductInput, ProductRatingUncheckedUpdateWithoutProductInput>
    create: XOR<ProductRatingCreateWithoutProductInput, ProductRatingUncheckedCreateWithoutProductInput>
  }

  export type ProductRatingUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductRatingWhereUniqueInput
    data: XOR<ProductRatingUpdateWithoutProductInput, ProductRatingUncheckedUpdateWithoutProductInput>
  }

  export type ProductRatingUpdateManyWithWhereWithoutProductInput = {
    where: ProductRatingScalarWhereInput
    data: XOR<ProductRatingUpdateManyMutationInput, ProductRatingUncheckedUpdateManyWithoutProductInput>
  }

  export type DistrictUpsertWithoutProductsInput = {
    update: XOR<DistrictUpdateWithoutProductsInput, DistrictUncheckedUpdateWithoutProductsInput>
    create: XOR<DistrictCreateWithoutProductsInput, DistrictUncheckedCreateWithoutProductsInput>
    where?: DistrictWhereInput
  }

  export type DistrictUpdateToOneWithWhereWithoutProductsInput = {
    where?: DistrictWhereInput
    data: XOR<DistrictUpdateWithoutProductsInput, DistrictUncheckedUpdateWithoutProductsInput>
  }

  export type DistrictUpdateWithoutProductsInput = {
    district_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DistrictUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    district_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUpsertWithoutProductsInput = {
    update: XOR<VenueUpdateWithoutProductsInput, VenueUncheckedUpdateWithoutProductsInput>
    create: XOR<VenueCreateWithoutProductsInput, VenueUncheckedCreateWithoutProductsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutProductsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutProductsInput, VenueUncheckedUpdateWithoutProductsInput>
  }

  export type VenueUpdateWithoutProductsInput = {
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pan_vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    pan_vat_number?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutEventInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutEventInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutEventInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutEventInput, ProductUncheckedCreateWithoutEventInput>
  }

  export type PartyPalaceCreateWithoutEventsInput = {
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutPartypalaceInput
  }

  export type PartyPalaceUncheckedCreateWithoutEventsInput = {
    id?: number
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type PartyPalaceCreateOrConnectWithoutEventsInput = {
    where: PartyPalaceWhereUniqueInput
    create: XOR<PartyPalaceCreateWithoutEventsInput, PartyPalaceUncheckedCreateWithoutEventsInput>
  }

  export type CateringTentCreateWithoutEventsInput = {
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutCateringtentInput
  }

  export type CateringTentUncheckedCreateWithoutEventsInput = {
    id?: number
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type CateringTentCreateOrConnectWithoutEventsInput = {
    where: CateringTentWhereUniqueInput
    create: XOR<CateringTentCreateWithoutEventsInput, CateringTentUncheckedCreateWithoutEventsInput>
  }

  export type AdventureCreateWithoutEventsInput = {
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutAdventureInput
  }

  export type AdventureUncheckedCreateWithoutEventsInput = {
    id?: number
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type AdventureCreateOrConnectWithoutEventsInput = {
    where: AdventureWhereUniqueInput
    create: XOR<AdventureCreateWithoutEventsInput, AdventureUncheckedCreateWithoutEventsInput>
  }

  export type BeautyDecorCreateWithoutEventsInput = {
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutBeautydecorInput
  }

  export type BeautyDecorUncheckedCreateWithoutEventsInput = {
    id?: number
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type BeautyDecorCreateOrConnectWithoutEventsInput = {
    where: BeautyDecorWhereUniqueInput
    create: XOR<BeautyDecorCreateWithoutEventsInput, BeautyDecorUncheckedCreateWithoutEventsInput>
  }

  export type MeetingCreateWithoutEventsInput = {
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutEventsInput = {
    id?: number
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type MeetingCreateOrConnectWithoutEventsInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutEventsInput, MeetingUncheckedCreateWithoutEventsInput>
  }

  export type MeetingCreateManyEventsInputEnvelope = {
    data: MeetingCreateManyEventsInput | MeetingCreateManyEventsInput[]
    skipDuplicates?: boolean
  }

  export type EntertainmentCreateWithoutEventsInput = {
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutEntertainmentInput
  }

  export type EntertainmentUncheckedCreateWithoutEventsInput = {
    id?: number
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type EntertainmentCreateOrConnectWithoutEventsInput = {
    where: EntertainmentWhereUniqueInput
    create: XOR<EntertainmentCreateWithoutEventsInput, EntertainmentUncheckedCreateWithoutEventsInput>
  }

  export type LuxuryCreateWithoutEventsInput = {
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutLuxuryInput
  }

  export type LuxuryUncheckedCreateWithoutEventsInput = {
    id?: number
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type LuxuryCreateOrConnectWithoutEventsInput = {
    where: LuxuryWhereUniqueInput
    create: XOR<LuxuryCreateWithoutEventsInput, LuxuryUncheckedCreateWithoutEventsInput>
  }

  export type MusicalCreateWithoutEventsInput = {
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutMusicalInput
  }

  export type MusicalUncheckedCreateWithoutEventsInput = {
    id?: number
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type MusicalCreateOrConnectWithoutEventsInput = {
    where: MusicalWhereUniqueInput
    create: XOR<MusicalCreateWithoutEventsInput, MusicalUncheckedCreateWithoutEventsInput>
  }

  export type MultimediaCreateWithoutEventsInput = {
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product?: ProductCreateNestedOneWithoutMultimediaInput
  }

  export type MultimediaUncheckedCreateWithoutEventsInput = {
    id?: number
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type MultimediaCreateOrConnectWithoutEventsInput = {
    where: MultimediaWhereUniqueInput
    create: XOR<MultimediaCreateWithoutEventsInput, MultimediaUncheckedCreateWithoutEventsInput>
  }

  export type EventEventTypeCreateWithoutEventInput = {
    EventType: EventTypeCreateNestedOneWithoutEventsInput
  }

  export type EventEventTypeUncheckedCreateWithoutEventInput = {
    eventTypeId: number
  }

  export type EventEventTypeCreateOrConnectWithoutEventInput = {
    where: EventEventTypeWhereUniqueInput
    create: XOR<EventEventTypeCreateWithoutEventInput, EventEventTypeUncheckedCreateWithoutEventInput>
  }

  export type EventEventTypeCreateManyEventInputEnvelope = {
    data: EventEventTypeCreateManyEventInput | EventEventTypeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEvents_bookedInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blogs_approved?: BlogCreateNestedManyWithoutApproved_byInput
    blogs_author?: BlogCreateNestedManyWithoutAuthorInput
    ratings?: ProductRatingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEvents_bookedInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blogs_approved?: BlogUncheckedCreateNestedManyWithoutApproved_byInput
    blogs_author?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEvents_bookedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvents_bookedInput, UserUncheckedCreateWithoutEvents_bookedInput>
  }

  export type ProductUpsertWithoutEventInput = {
    update: XOR<ProductUpdateWithoutEventInput, ProductUncheckedUpdateWithoutEventInput>
    create: XOR<ProductCreateWithoutEventInput, ProductUncheckedCreateWithoutEventInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutEventInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutEventInput, ProductUncheckedUpdateWithoutEventInput>
  }

  export type ProductUpdateWithoutEventInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PartyPalaceUpsertWithWhereUniqueWithoutEventsInput = {
    where: PartyPalaceWhereUniqueInput
    update: XOR<PartyPalaceUpdateWithoutEventsInput, PartyPalaceUncheckedUpdateWithoutEventsInput>
    create: XOR<PartyPalaceCreateWithoutEventsInput, PartyPalaceUncheckedCreateWithoutEventsInput>
  }

  export type PartyPalaceUpdateWithWhereUniqueWithoutEventsInput = {
    where: PartyPalaceWhereUniqueInput
    data: XOR<PartyPalaceUpdateWithoutEventsInput, PartyPalaceUncheckedUpdateWithoutEventsInput>
  }

  export type PartyPalaceUpdateManyWithWhereWithoutEventsInput = {
    where: PartyPalaceScalarWhereInput
    data: XOR<PartyPalaceUpdateManyMutationInput, PartyPalaceUncheckedUpdateManyWithoutEventsInput>
  }

  export type CateringTentUpsertWithWhereUniqueWithoutEventsInput = {
    where: CateringTentWhereUniqueInput
    update: XOR<CateringTentUpdateWithoutEventsInput, CateringTentUncheckedUpdateWithoutEventsInput>
    create: XOR<CateringTentCreateWithoutEventsInput, CateringTentUncheckedCreateWithoutEventsInput>
  }

  export type CateringTentUpdateWithWhereUniqueWithoutEventsInput = {
    where: CateringTentWhereUniqueInput
    data: XOR<CateringTentUpdateWithoutEventsInput, CateringTentUncheckedUpdateWithoutEventsInput>
  }

  export type CateringTentUpdateManyWithWhereWithoutEventsInput = {
    where: CateringTentScalarWhereInput
    data: XOR<CateringTentUpdateManyMutationInput, CateringTentUncheckedUpdateManyWithoutEventsInput>
  }

  export type AdventureUpsertWithWhereUniqueWithoutEventsInput = {
    where: AdventureWhereUniqueInput
    update: XOR<AdventureUpdateWithoutEventsInput, AdventureUncheckedUpdateWithoutEventsInput>
    create: XOR<AdventureCreateWithoutEventsInput, AdventureUncheckedCreateWithoutEventsInput>
  }

  export type AdventureUpdateWithWhereUniqueWithoutEventsInput = {
    where: AdventureWhereUniqueInput
    data: XOR<AdventureUpdateWithoutEventsInput, AdventureUncheckedUpdateWithoutEventsInput>
  }

  export type AdventureUpdateManyWithWhereWithoutEventsInput = {
    where: AdventureScalarWhereInput
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyWithoutEventsInput>
  }

  export type BeautyDecorUpsertWithWhereUniqueWithoutEventsInput = {
    where: BeautyDecorWhereUniqueInput
    update: XOR<BeautyDecorUpdateWithoutEventsInput, BeautyDecorUncheckedUpdateWithoutEventsInput>
    create: XOR<BeautyDecorCreateWithoutEventsInput, BeautyDecorUncheckedCreateWithoutEventsInput>
  }

  export type BeautyDecorUpdateWithWhereUniqueWithoutEventsInput = {
    where: BeautyDecorWhereUniqueInput
    data: XOR<BeautyDecorUpdateWithoutEventsInput, BeautyDecorUncheckedUpdateWithoutEventsInput>
  }

  export type BeautyDecorUpdateManyWithWhereWithoutEventsInput = {
    where: BeautyDecorScalarWhereInput
    data: XOR<BeautyDecorUpdateManyMutationInput, BeautyDecorUncheckedUpdateManyWithoutEventsInput>
  }

  export type MeetingUpsertWithWhereUniqueWithoutEventsInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutEventsInput, MeetingUncheckedUpdateWithoutEventsInput>
    create: XOR<MeetingCreateWithoutEventsInput, MeetingUncheckedCreateWithoutEventsInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutEventsInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutEventsInput, MeetingUncheckedUpdateWithoutEventsInput>
  }

  export type MeetingUpdateManyWithWhereWithoutEventsInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutEventsInput>
  }

  export type EntertainmentUpsertWithWhereUniqueWithoutEventsInput = {
    where: EntertainmentWhereUniqueInput
    update: XOR<EntertainmentUpdateWithoutEventsInput, EntertainmentUncheckedUpdateWithoutEventsInput>
    create: XOR<EntertainmentCreateWithoutEventsInput, EntertainmentUncheckedCreateWithoutEventsInput>
  }

  export type EntertainmentUpdateWithWhereUniqueWithoutEventsInput = {
    where: EntertainmentWhereUniqueInput
    data: XOR<EntertainmentUpdateWithoutEventsInput, EntertainmentUncheckedUpdateWithoutEventsInput>
  }

  export type EntertainmentUpdateManyWithWhereWithoutEventsInput = {
    where: EntertainmentScalarWhereInput
    data: XOR<EntertainmentUpdateManyMutationInput, EntertainmentUncheckedUpdateManyWithoutEventsInput>
  }

  export type LuxuryUpsertWithWhereUniqueWithoutEventsInput = {
    where: LuxuryWhereUniqueInput
    update: XOR<LuxuryUpdateWithoutEventsInput, LuxuryUncheckedUpdateWithoutEventsInput>
    create: XOR<LuxuryCreateWithoutEventsInput, LuxuryUncheckedCreateWithoutEventsInput>
  }

  export type LuxuryUpdateWithWhereUniqueWithoutEventsInput = {
    where: LuxuryWhereUniqueInput
    data: XOR<LuxuryUpdateWithoutEventsInput, LuxuryUncheckedUpdateWithoutEventsInput>
  }

  export type LuxuryUpdateManyWithWhereWithoutEventsInput = {
    where: LuxuryScalarWhereInput
    data: XOR<LuxuryUpdateManyMutationInput, LuxuryUncheckedUpdateManyWithoutEventsInput>
  }

  export type MusicalUpsertWithWhereUniqueWithoutEventsInput = {
    where: MusicalWhereUniqueInput
    update: XOR<MusicalUpdateWithoutEventsInput, MusicalUncheckedUpdateWithoutEventsInput>
    create: XOR<MusicalCreateWithoutEventsInput, MusicalUncheckedCreateWithoutEventsInput>
  }

  export type MusicalUpdateWithWhereUniqueWithoutEventsInput = {
    where: MusicalWhereUniqueInput
    data: XOR<MusicalUpdateWithoutEventsInput, MusicalUncheckedUpdateWithoutEventsInput>
  }

  export type MusicalUpdateManyWithWhereWithoutEventsInput = {
    where: MusicalScalarWhereInput
    data: XOR<MusicalUpdateManyMutationInput, MusicalUncheckedUpdateManyWithoutEventsInput>
  }

  export type MultimediaUpsertWithWhereUniqueWithoutEventsInput = {
    where: MultimediaWhereUniqueInput
    update: XOR<MultimediaUpdateWithoutEventsInput, MultimediaUncheckedUpdateWithoutEventsInput>
    create: XOR<MultimediaCreateWithoutEventsInput, MultimediaUncheckedCreateWithoutEventsInput>
  }

  export type MultimediaUpdateWithWhereUniqueWithoutEventsInput = {
    where: MultimediaWhereUniqueInput
    data: XOR<MultimediaUpdateWithoutEventsInput, MultimediaUncheckedUpdateWithoutEventsInput>
  }

  export type MultimediaUpdateManyWithWhereWithoutEventsInput = {
    where: MultimediaScalarWhereInput
    data: XOR<MultimediaUpdateManyMutationInput, MultimediaUncheckedUpdateManyWithoutEventsInput>
  }

  export type EventEventTypeUpsertWithWhereUniqueWithoutEventInput = {
    where: EventEventTypeWhereUniqueInput
    update: XOR<EventEventTypeUpdateWithoutEventInput, EventEventTypeUncheckedUpdateWithoutEventInput>
    create: XOR<EventEventTypeCreateWithoutEventInput, EventEventTypeUncheckedCreateWithoutEventInput>
  }

  export type EventEventTypeUpdateWithWhereUniqueWithoutEventInput = {
    where: EventEventTypeWhereUniqueInput
    data: XOR<EventEventTypeUpdateWithoutEventInput, EventEventTypeUncheckedUpdateWithoutEventInput>
  }

  export type EventEventTypeUpdateManyWithWhereWithoutEventInput = {
    where: EventEventTypeScalarWhereInput
    data: XOR<EventEventTypeUpdateManyMutationInput, EventEventTypeUncheckedUpdateManyWithoutEventInput>
  }

  export type EventEventTypeScalarWhereInput = {
    AND?: EventEventTypeScalarWhereInput | EventEventTypeScalarWhereInput[]
    OR?: EventEventTypeScalarWhereInput[]
    NOT?: EventEventTypeScalarWhereInput | EventEventTypeScalarWhereInput[]
    eventId?: IntFilter<"EventEventType"> | number
    eventTypeId?: IntFilter<"EventEventType"> | number
  }

  export type UserUpsertWithoutEvents_bookedInput = {
    update: XOR<UserUpdateWithoutEvents_bookedInput, UserUncheckedUpdateWithoutEvents_bookedInput>
    create: XOR<UserCreateWithoutEvents_bookedInput, UserUncheckedCreateWithoutEvents_bookedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvents_bookedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvents_bookedInput, UserUncheckedUpdateWithoutEvents_bookedInput>
  }

  export type UserUpdateWithoutEvents_bookedInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs_approved?: BlogUpdateManyWithoutApproved_byNestedInput
    blogs_author?: BlogUpdateManyWithoutAuthorNestedInput
    ratings?: ProductRatingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvents_bookedInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs_approved?: BlogUncheckedUpdateManyWithoutApproved_byNestedInput
    blogs_author?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventEventTypeCreateWithoutEventTypeInput = {
    Event: EventCreateNestedOneWithoutEventTypesInput
  }

  export type EventEventTypeUncheckedCreateWithoutEventTypeInput = {
    eventId: number
  }

  export type EventEventTypeCreateOrConnectWithoutEventTypeInput = {
    where: EventEventTypeWhereUniqueInput
    create: XOR<EventEventTypeCreateWithoutEventTypeInput, EventEventTypeUncheckedCreateWithoutEventTypeInput>
  }

  export type EventEventTypeCreateManyEventTypeInputEnvelope = {
    data: EventEventTypeCreateManyEventTypeInput | EventEventTypeCreateManyEventTypeInput[]
    skipDuplicates?: boolean
  }

  export type EventEventTypeUpsertWithWhereUniqueWithoutEventTypeInput = {
    where: EventEventTypeWhereUniqueInput
    update: XOR<EventEventTypeUpdateWithoutEventTypeInput, EventEventTypeUncheckedUpdateWithoutEventTypeInput>
    create: XOR<EventEventTypeCreateWithoutEventTypeInput, EventEventTypeUncheckedCreateWithoutEventTypeInput>
  }

  export type EventEventTypeUpdateWithWhereUniqueWithoutEventTypeInput = {
    where: EventEventTypeWhereUniqueInput
    data: XOR<EventEventTypeUpdateWithoutEventTypeInput, EventEventTypeUncheckedUpdateWithoutEventTypeInput>
  }

  export type EventEventTypeUpdateManyWithWhereWithoutEventTypeInput = {
    where: EventEventTypeScalarWhereInput
    data: XOR<EventEventTypeUpdateManyMutationInput, EventEventTypeUncheckedUpdateManyWithoutEventTypeInput>
  }

  export type EventCreateWithoutEventTypesInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutEventTypesInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
  }

  export type EventCreateOrConnectWithoutEventTypesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventTypesInput, EventUncheckedCreateWithoutEventTypesInput>
  }

  export type EventTypeCreateWithoutEventsInput = {
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTypeUncheckedCreateWithoutEventsInput = {
    id?: number
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTypeCreateOrConnectWithoutEventsInput = {
    where: EventTypeWhereUniqueInput
    create: XOR<EventTypeCreateWithoutEventsInput, EventTypeUncheckedCreateWithoutEventsInput>
  }

  export type EventUpsertWithoutEventTypesInput = {
    update: XOR<EventUpdateWithoutEventTypesInput, EventUncheckedUpdateWithoutEventTypesInput>
    create: XOR<EventCreateWithoutEventTypesInput, EventUncheckedCreateWithoutEventTypesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventTypesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventTypesInput, EventUncheckedUpdateWithoutEventTypesInput>
  }

  export type EventUpdateWithoutEventTypesInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutEventTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
  }

  export type EventTypeUpsertWithoutEventsInput = {
    update: XOR<EventTypeUpdateWithoutEventsInput, EventTypeUncheckedUpdateWithoutEventsInput>
    create: XOR<EventTypeCreateWithoutEventsInput, EventTypeUncheckedCreateWithoutEventsInput>
    where?: EventTypeWhereInput
  }

  export type EventTypeUpdateToOneWithWhereWithoutEventsInput = {
    where?: EventTypeWhereInput
    data: XOR<EventTypeUpdateWithoutEventsInput, EventTypeUncheckedUpdateWithoutEventsInput>
  }

  export type EventTypeUpdateWithoutEventsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutMultimediaInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutMultimediaInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMultimediaInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMultimediaInput, ProductUncheckedCreateWithoutMultimediaInput>
  }

  export type EventCreateWithoutMultimediaInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutMultimediaInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutMultimediaInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutMultimediaInput, EventUncheckedCreateWithoutMultimediaInput>
  }

  export type ProductUpsertWithoutMultimediaInput = {
    update: XOR<ProductUpdateWithoutMultimediaInput, ProductUncheckedUpdateWithoutMultimediaInput>
    create: XOR<ProductCreateWithoutMultimediaInput, ProductUncheckedCreateWithoutMultimediaInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMultimediaInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMultimediaInput, ProductUncheckedUpdateWithoutMultimediaInput>
  }

  export type ProductUpdateWithoutMultimediaInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutMultimediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutMultimediaInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutMultimediaInput, EventUncheckedUpdateWithoutMultimediaInput>
    create: XOR<EventCreateWithoutMultimediaInput, EventUncheckedCreateWithoutMultimediaInput>
  }

  export type EventUpdateWithWhereUniqueWithoutMultimediaInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutMultimediaInput, EventUncheckedUpdateWithoutMultimediaInput>
  }

  export type EventUpdateManyWithWhereWithoutMultimediaInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutMultimediaInput>
  }

  export type ProductCreateWithoutMusicalInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutMusicalInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMusicalInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMusicalInput, ProductUncheckedCreateWithoutMusicalInput>
  }

  export type EventCreateWithoutMusicalInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutMusicalInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutMusicalInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutMusicalInput, EventUncheckedCreateWithoutMusicalInput>
  }

  export type ProductUpsertWithoutMusicalInput = {
    update: XOR<ProductUpdateWithoutMusicalInput, ProductUncheckedUpdateWithoutMusicalInput>
    create: XOR<ProductCreateWithoutMusicalInput, ProductUncheckedCreateWithoutMusicalInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMusicalInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMusicalInput, ProductUncheckedUpdateWithoutMusicalInput>
  }

  export type ProductUpdateWithoutMusicalInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutMusicalInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutMusicalInput, EventUncheckedUpdateWithoutMusicalInput>
    create: XOR<EventCreateWithoutMusicalInput, EventUncheckedCreateWithoutMusicalInput>
  }

  export type EventUpdateWithWhereUniqueWithoutMusicalInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutMusicalInput, EventUncheckedUpdateWithoutMusicalInput>
  }

  export type EventUpdateManyWithWhereWithoutMusicalInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutMusicalInput>
  }

  export type ProductCreateWithoutLuxuryInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutLuxuryInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutLuxuryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLuxuryInput, ProductUncheckedCreateWithoutLuxuryInput>
  }

  export type EventCreateWithoutLuxuryInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutLuxuryInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutLuxuryInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutLuxuryInput, EventUncheckedCreateWithoutLuxuryInput>
  }

  export type ProductUpsertWithoutLuxuryInput = {
    update: XOR<ProductUpdateWithoutLuxuryInput, ProductUncheckedUpdateWithoutLuxuryInput>
    create: XOR<ProductCreateWithoutLuxuryInput, ProductUncheckedCreateWithoutLuxuryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutLuxuryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutLuxuryInput, ProductUncheckedUpdateWithoutLuxuryInput>
  }

  export type ProductUpdateWithoutLuxuryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutLuxuryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutLuxuryInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutLuxuryInput, EventUncheckedUpdateWithoutLuxuryInput>
    create: XOR<EventCreateWithoutLuxuryInput, EventUncheckedCreateWithoutLuxuryInput>
  }

  export type EventUpdateWithWhereUniqueWithoutLuxuryInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutLuxuryInput, EventUncheckedUpdateWithoutLuxuryInput>
  }

  export type EventUpdateManyWithWhereWithoutLuxuryInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutLuxuryInput>
  }

  export type ProductCreateWithoutEntertainmentInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutEntertainmentInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutEntertainmentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutEntertainmentInput, ProductUncheckedCreateWithoutEntertainmentInput>
  }

  export type EventCreateWithoutEntertainmentInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutEntertainmentInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEntertainmentInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEntertainmentInput, EventUncheckedCreateWithoutEntertainmentInput>
  }

  export type ProductUpsertWithoutEntertainmentInput = {
    update: XOR<ProductUpdateWithoutEntertainmentInput, ProductUncheckedUpdateWithoutEntertainmentInput>
    create: XOR<ProductCreateWithoutEntertainmentInput, ProductUncheckedCreateWithoutEntertainmentInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutEntertainmentInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutEntertainmentInput, ProductUncheckedUpdateWithoutEntertainmentInput>
  }

  export type ProductUpdateWithoutEntertainmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutEntertainmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutEntertainmentInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutEntertainmentInput, EventUncheckedUpdateWithoutEntertainmentInput>
    create: XOR<EventCreateWithoutEntertainmentInput, EventUncheckedCreateWithoutEntertainmentInput>
  }

  export type EventUpdateWithWhereUniqueWithoutEntertainmentInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutEntertainmentInput, EventUncheckedUpdateWithoutEntertainmentInput>
  }

  export type EventUpdateManyWithWhereWithoutEntertainmentInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEntertainmentInput>
  }

  export type ProductCreateWithoutMeetingInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutMeetingInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMeetingInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMeetingInput, ProductUncheckedCreateWithoutMeetingInput>
  }

  export type EventCreateWithoutMeetingInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutMeetingInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutMeetingInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutMeetingInput, EventUncheckedCreateWithoutMeetingInput>
  }

  export type ProductUpsertWithoutMeetingInput = {
    update: XOR<ProductUpdateWithoutMeetingInput, ProductUncheckedUpdateWithoutMeetingInput>
    create: XOR<ProductCreateWithoutMeetingInput, ProductUncheckedCreateWithoutMeetingInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMeetingInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMeetingInput, ProductUncheckedUpdateWithoutMeetingInput>
  }

  export type ProductUpdateWithoutMeetingInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutMeetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithoutMeetingInput = {
    update: XOR<EventUpdateWithoutMeetingInput, EventUncheckedUpdateWithoutMeetingInput>
    create: XOR<EventCreateWithoutMeetingInput, EventUncheckedCreateWithoutMeetingInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutMeetingInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutMeetingInput, EventUncheckedUpdateWithoutMeetingInput>
  }

  export type EventUpdateWithoutMeetingInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutMeetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ProductCreateWithoutBeautydecorInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutBeautydecorInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBeautydecorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBeautydecorInput, ProductUncheckedCreateWithoutBeautydecorInput>
  }

  export type EventCreateWithoutBeautyDecorInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutBeautyDecorInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutBeautyDecorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutBeautyDecorInput, EventUncheckedCreateWithoutBeautyDecorInput>
  }

  export type ProductUpsertWithoutBeautydecorInput = {
    update: XOR<ProductUpdateWithoutBeautydecorInput, ProductUncheckedUpdateWithoutBeautydecorInput>
    create: XOR<ProductCreateWithoutBeautydecorInput, ProductUncheckedCreateWithoutBeautydecorInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutBeautydecorInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutBeautydecorInput, ProductUncheckedUpdateWithoutBeautydecorInput>
  }

  export type ProductUpdateWithoutBeautydecorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutBeautydecorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutBeautyDecorInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutBeautyDecorInput, EventUncheckedUpdateWithoutBeautyDecorInput>
    create: XOR<EventCreateWithoutBeautyDecorInput, EventUncheckedCreateWithoutBeautyDecorInput>
  }

  export type EventUpdateWithWhereUniqueWithoutBeautyDecorInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutBeautyDecorInput, EventUncheckedUpdateWithoutBeautyDecorInput>
  }

  export type EventUpdateManyWithWhereWithoutBeautyDecorInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutBeautyDecorInput>
  }

  export type ProductCreateWithoutAdventureInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutAdventureInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdventureInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdventureInput, ProductUncheckedCreateWithoutAdventureInput>
  }

  export type EventCreateWithoutAdventureInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutAdventureInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutAdventureInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAdventureInput, EventUncheckedCreateWithoutAdventureInput>
  }

  export type ProductUpsertWithoutAdventureInput = {
    update: XOR<ProductUpdateWithoutAdventureInput, ProductUncheckedUpdateWithoutAdventureInput>
    create: XOR<ProductCreateWithoutAdventureInput, ProductUncheckedCreateWithoutAdventureInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdventureInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdventureInput, ProductUncheckedUpdateWithoutAdventureInput>
  }

  export type ProductUpdateWithoutAdventureInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdventureInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutAdventureInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutAdventureInput, EventUncheckedUpdateWithoutAdventureInput>
    create: XOR<EventCreateWithoutAdventureInput, EventUncheckedCreateWithoutAdventureInput>
  }

  export type EventUpdateWithWhereUniqueWithoutAdventureInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutAdventureInput, EventUncheckedUpdateWithoutAdventureInput>
  }

  export type EventUpdateManyWithWhereWithoutAdventureInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutAdventureInput>
  }

  export type ProductCreateWithoutPartypalaceInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutPartypalaceInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPartypalaceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPartypalaceInput, ProductUncheckedCreateWithoutPartypalaceInput>
  }

  export type EventCreateWithoutPartyPalaceInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    CateringTent?: CateringTentCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutPartyPalaceInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CateringTent?: CateringTentUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutPartyPalaceInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutPartyPalaceInput, EventUncheckedCreateWithoutPartyPalaceInput>
  }

  export type ProductUpsertWithoutPartypalaceInput = {
    update: XOR<ProductUpdateWithoutPartypalaceInput, ProductUncheckedUpdateWithoutPartypalaceInput>
    create: XOR<ProductCreateWithoutPartypalaceInput, ProductUncheckedCreateWithoutPartypalaceInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPartypalaceInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPartypalaceInput, ProductUncheckedUpdateWithoutPartypalaceInput>
  }

  export type ProductUpdateWithoutPartypalaceInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutPartypalaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutPartyPalaceInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutPartyPalaceInput, EventUncheckedUpdateWithoutPartyPalaceInput>
    create: XOR<EventCreateWithoutPartyPalaceInput, EventUncheckedCreateWithoutPartyPalaceInput>
  }

  export type EventUpdateWithWhereUniqueWithoutPartyPalaceInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutPartyPalaceInput, EventUncheckedUpdateWithoutPartyPalaceInput>
  }

  export type EventUpdateManyWithWhereWithoutPartyPalaceInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutPartyPalaceInput>
  }

  export type ProductCreateWithoutCateringtentInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCateringtentInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCateringtentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCateringtentInput, ProductUncheckedCreateWithoutCateringtentInput>
  }

  export type EventCreateWithoutCateringTentInput = {
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Product: ProductCreateNestedOneWithoutEventInput
    PartyPalace?: PartyPalaceCreateNestedManyWithoutEventsInput
    Adventure?: AdventureCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorCreateNestedManyWithoutEventsInput
    Meeting?: MeetingCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryCreateNestedManyWithoutEventsInput
    Musical?: MusicalCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeCreateNestedManyWithoutEventInput
    User: UserCreateNestedOneWithoutEvents_bookedInput
  }

  export type EventUncheckedCreateWithoutCateringTentInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PartyPalace?: PartyPalaceUncheckedCreateNestedManyWithoutEventsInput
    Adventure?: AdventureUncheckedCreateNestedManyWithoutEventsInput
    BeautyDecor?: BeautyDecorUncheckedCreateNestedManyWithoutEventsInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutEventsInput
    Entertainment?: EntertainmentUncheckedCreateNestedManyWithoutEventsInput
    Luxury?: LuxuryUncheckedCreateNestedManyWithoutEventsInput
    Musical?: MusicalUncheckedCreateNestedManyWithoutEventsInput
    Multimedia?: MultimediaUncheckedCreateNestedManyWithoutEventsInput
    EventTypes?: EventEventTypeUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCateringTentInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCateringTentInput, EventUncheckedCreateWithoutCateringTentInput>
  }

  export type ProductUpsertWithoutCateringtentInput = {
    update: XOR<ProductUpdateWithoutCateringtentInput, ProductUncheckedUpdateWithoutCateringtentInput>
    create: XOR<ProductCreateWithoutCateringtentInput, ProductUncheckedCreateWithoutCateringtentInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCateringtentInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCateringtentInput, ProductUncheckedUpdateWithoutCateringtentInput>
  }

  export type ProductUpdateWithoutCateringtentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCateringtentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutCateringTentInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCateringTentInput, EventUncheckedUpdateWithoutCateringTentInput>
    create: XOR<EventCreateWithoutCateringTentInput, EventUncheckedCreateWithoutCateringTentInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCateringTentInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCateringTentInput, EventUncheckedUpdateWithoutCateringTentInput>
  }

  export type EventUpdateManyWithWhereWithoutCateringTentInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCateringTentInput>
  }

  export type ProductCreateWithoutProduct_imageInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    ratings?: ProductRatingCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutProduct_imageInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_imageInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_imageInput, ProductUncheckedCreateWithoutProduct_imageInput>
  }

  export type ProductUpsertWithoutProduct_imageInput = {
    update: XOR<ProductUpdateWithoutProduct_imageInput, ProductUncheckedUpdateWithoutProduct_imageInput>
    create: XOR<ProductCreateWithoutProduct_imageInput, ProductUncheckedCreateWithoutProduct_imageInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProduct_imageInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProduct_imageInput, ProductUncheckedUpdateWithoutProduct_imageInput>
  }

  export type ProductUpdateWithoutProduct_imageInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_imageInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutBlogs_authorInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventCreateNestedManyWithoutUserInput
    blogs_approved?: BlogCreateNestedManyWithoutApproved_byInput
    ratings?: ProductRatingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogs_authorInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventUncheckedCreateNestedManyWithoutUserInput
    blogs_approved?: BlogUncheckedCreateNestedManyWithoutApproved_byInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogs_authorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogs_authorInput, UserUncheckedCreateWithoutBlogs_authorInput>
  }

  export type UserCreateWithoutBlogs_approvedInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventCreateNestedManyWithoutUserInput
    blogs_author?: BlogCreateNestedManyWithoutAuthorInput
    ratings?: ProductRatingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogs_approvedInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventUncheckedCreateNestedManyWithoutUserInput
    blogs_author?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    ratings?: ProductRatingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogs_approvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogs_approvedInput, UserUncheckedCreateWithoutBlogs_approvedInput>
  }

  export type UserUpsertWithoutBlogs_authorInput = {
    update: XOR<UserUpdateWithoutBlogs_authorInput, UserUncheckedUpdateWithoutBlogs_authorInput>
    create: XOR<UserCreateWithoutBlogs_authorInput, UserUncheckedCreateWithoutBlogs_authorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogs_authorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogs_authorInput, UserUncheckedUpdateWithoutBlogs_authorInput>
  }

  export type UserUpdateWithoutBlogs_authorInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUpdateManyWithoutUserNestedInput
    blogs_approved?: BlogUpdateManyWithoutApproved_byNestedInput
    ratings?: ProductRatingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogs_authorInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUncheckedUpdateManyWithoutUserNestedInput
    blogs_approved?: BlogUncheckedUpdateManyWithoutApproved_byNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBlogs_approvedInput = {
    update: XOR<UserUpdateWithoutBlogs_approvedInput, UserUncheckedUpdateWithoutBlogs_approvedInput>
    create: XOR<UserCreateWithoutBlogs_approvedInput, UserUncheckedCreateWithoutBlogs_approvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogs_approvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogs_approvedInput, UserUncheckedUpdateWithoutBlogs_approvedInput>
  }

  export type UserUpdateWithoutBlogs_approvedInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUpdateManyWithoutUserNestedInput
    blogs_author?: BlogUpdateManyWithoutAuthorNestedInput
    ratings?: ProductRatingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogs_approvedInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUncheckedUpdateManyWithoutUserNestedInput
    blogs_author?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRatingsInput = {
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventCreateNestedManyWithoutUserInput
    blogs_approved?: BlogCreateNestedManyWithoutApproved_byInput
    blogs_author?: BlogCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: number
    firstname: string
    lastname: string
    email: string
    password: string
    phone_number: string
    role?: $Enums.Role
    avatar?: string | null
    resetPasswordToken?: string | null
    resetPasswordTokenExpiry?: Date | string | null
    refreshToken?: string | null
    otp?: string | null
    otpExpiresAt?: Date | string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events_booked?: EventUncheckedCreateNestedManyWithoutUserInput
    blogs_approved?: BlogUncheckedCreateNestedManyWithoutApproved_byInput
    blogs_author?: BlogUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type ProductCreateWithoutRatingsInput = {
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    multimedia?: MultimediaCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentCreateNestedManyWithoutProductInput
    musical?: MusicalCreateNestedManyWithoutProductInput
    luxury?: LuxuryCreateNestedManyWithoutProductInput
    meeting?: MeetingCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorCreateNestedManyWithoutProductInput
    adventure?: AdventureCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentCreateNestedManyWithoutProductInput
    product_image?: ProductImageCreateNestedManyWithoutProductInput
    event?: EventCreateNestedManyWithoutProductInput
    District: DistrictCreateNestedOneWithoutProductsInput
    Venue: VenueCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutRatingsInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
    businessId: number
    multimedia?: MultimediaUncheckedCreateNestedManyWithoutProductInput
    entertainment?: EntertainmentUncheckedCreateNestedManyWithoutProductInput
    musical?: MusicalUncheckedCreateNestedManyWithoutProductInput
    luxury?: LuxuryUncheckedCreateNestedManyWithoutProductInput
    meeting?: MeetingUncheckedCreateNestedManyWithoutProductInput
    beautydecor?: BeautyDecorUncheckedCreateNestedManyWithoutProductInput
    adventure?: AdventureUncheckedCreateNestedManyWithoutProductInput
    partypalace?: PartyPalaceUncheckedCreateNestedManyWithoutProductInput
    cateringtent?: CateringTentUncheckedCreateNestedManyWithoutProductInput
    product_image?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    event?: EventUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRatingsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUpdateManyWithoutUserNestedInput
    blogs_approved?: BlogUpdateManyWithoutApproved_byNestedInput
    blogs_author?: BlogUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events_booked?: EventUncheckedUpdateManyWithoutUserNestedInput
    blogs_approved?: BlogUncheckedUpdateManyWithoutApproved_byNestedInput
    blogs_author?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ProductUpsertWithoutRatingsInput = {
    update: XOR<ProductUpdateWithoutRatingsInput, ProductUncheckedUpdateWithoutRatingsInput>
    create: XOR<ProductCreateWithoutRatingsInput, ProductUncheckedCreateWithoutRatingsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRatingsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRatingsInput, ProductUncheckedUpdateWithoutRatingsInput>
  }

  export type ProductUpdateWithoutRatingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EventCreateManyUserInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    productId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCreateManyApproved_byInput = {
    id?: number
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId?: number | null
  }

  export type BlogCreateManyAuthorInput = {
    id?: number
    title: string
    short_description?: string | null
    image: string
    description: string
    is_approved?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approved_by_id?: number | null
  }

  export type ProductRatingCreateManyUserInput = {
    id?: number
    rating: number
    review?: string | null
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateWithoutUserInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUpdateWithoutApproved_byInput = {
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutBlogs_authorNestedInput
  }

  export type BlogUncheckedUpdateWithoutApproved_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogUncheckedUpdateManyWithoutApproved_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_by?: UserUpdateOneWithoutBlogs_approvedNestedInput
  }

  export type BlogUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_approved?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductRatingUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ProductRatingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRatingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    districtId: number
    businessId: number
  }

  export type ProductUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    districtId?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyDistrictInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    businessId: number
  }

  export type ProductUpdateWithoutDistrictInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    Venue?: VenueUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    businessId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyVenueInput = {
    id?: number
    title: string
    description: string
    address: string
    short_description?: string | null
    is_active?: boolean
    overall_rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category_id: number
    districtId: number
  }

  export type ProductUpdateWithoutVenueInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    multimedia?: MultimediaUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUpdateManyWithoutProductNestedInput
    musical?: MusicalUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUpdateManyWithoutProductNestedInput
    meeting?: MeetingUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUpdateManyWithoutProductNestedInput
    adventure?: AdventureUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUpdateManyWithoutProductNestedInput
    event?: EventUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUpdateManyWithoutProductNestedInput
    District?: DistrictUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
    multimedia?: MultimediaUncheckedUpdateManyWithoutProductNestedInput
    entertainment?: EntertainmentUncheckedUpdateManyWithoutProductNestedInput
    musical?: MusicalUncheckedUpdateManyWithoutProductNestedInput
    luxury?: LuxuryUncheckedUpdateManyWithoutProductNestedInput
    meeting?: MeetingUncheckedUpdateManyWithoutProductNestedInput
    beautydecor?: BeautyDecorUncheckedUpdateManyWithoutProductNestedInput
    adventure?: AdventureUncheckedUpdateManyWithoutProductNestedInput
    partypalace?: PartyPalaceUncheckedUpdateManyWithoutProductNestedInput
    cateringtent?: CateringTentUncheckedUpdateManyWithoutProductNestedInput
    product_image?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    event?: EventUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ProductRatingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    overall_rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: IntFieldUpdateOperationsInput | number
    districtId?: IntFieldUpdateOperationsInput | number
  }

  export type MultimediaCreateManyProductInput = {
    id?: number
    multimedia_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntertainmentCreateManyProductInput = {
    id?: number
    entertainment_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MusicalCreateManyProductInput = {
    id?: number
    instrument_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LuxuryCreateManyProductInput = {
    id?: number
    luxury_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingCreateManyProductInput = {
    id?: number
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventId: number
  }

  export type BeautyDecorCreateManyProductInput = {
    id?: number
    beauty_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdventureCreateManyProductInput = {
    id?: number
    adventure_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartyPalaceCreateManyProductInput = {
    id?: number
    partypalace_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CateringTentCreateManyProductInput = {
    id?: number
    catering_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageCreateManyProductInput = {
    id?: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyProductInput = {
    id?: number
    start_date: Date | string
    end_date: Date | string
    start_time?: Date | string | null
    end_time?: Date | string | null
    is_approved?: boolean
    is_rejected?: boolean
    userId: number
    approved_by_id?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRatingCreateManyProductInput = {
    id?: number
    rating: number
    review?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultimediaUpdateWithoutProductInput = {
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutMultimediaNestedInput
  }

  export type MultimediaUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutMultimediaNestedInput
  }

  export type MultimediaUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntertainmentUpdateWithoutProductInput = {
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutEntertainmentNestedInput
  }

  export type EntertainmentUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutEntertainmentNestedInput
  }

  export type EntertainmentUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MusicalUpdateWithoutProductInput = {
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LuxuryUpdateWithoutProductInput = {
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutLuxuryNestedInput
  }

  export type LuxuryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutLuxuryNestedInput
  }

  export type LuxuryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutProductInput = {
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateOneRequiredWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type MeetingUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type BeautyDecorUpdateWithoutProductInput = {
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutBeautyDecorNestedInput
  }

  export type BeautyDecorUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutBeautyDecorNestedInput
  }

  export type BeautyDecorUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdventureUpdateWithoutProductInput = {
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartyPalaceUpdateWithoutProductInput = {
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutPartyPalaceNestedInput
  }

  export type PartyPalaceUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutPartyPalaceNestedInput
  }

  export type PartyPalaceUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CateringTentUpdateWithoutProductInput = {
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutCateringTentNestedInput
  }

  export type CateringTentUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutCateringTentNestedInput
  }

  export type CateringTentUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUpdateWithoutProductInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutProductInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRatingUpdateWithoutProductInput = {
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ProductRatingUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRatingUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateManyEventsInput = {
    id?: number
    meeting_name: string
    price: number
    offerPrice?: number | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: number | null
  }

  export type EventEventTypeCreateManyEventInput = {
    eventTypeId: number
  }

  export type PartyPalaceUpdateWithoutEventsInput = {
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutPartypalaceNestedInput
  }

  export type PartyPalaceUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PartyPalaceUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    partypalace_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CateringTentUpdateWithoutEventsInput = {
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutCateringtentNestedInput
  }

  export type CateringTentUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CateringTentUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    catering_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdventureUpdateWithoutEventsInput = {
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdventureUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    adventure_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BeautyDecorUpdateWithoutEventsInput = {
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutBeautydecorNestedInput
  }

  export type BeautyDecorUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BeautyDecorUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    beauty_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeetingUpdateWithoutEventsInput = {
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeetingUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    meeting_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EntertainmentUpdateWithoutEventsInput = {
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutEntertainmentNestedInput
  }

  export type EntertainmentUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EntertainmentUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    entertainment_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuxuryUpdateWithoutEventsInput = {
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutLuxuryNestedInput
  }

  export type LuxuryUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuxuryUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    luxury_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MusicalUpdateWithoutEventsInput = {
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutMusicalNestedInput
  }

  export type MusicalUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MusicalUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    instrument_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MultimediaUpdateWithoutEventsInput = {
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneWithoutMultimediaNestedInput
  }

  export type MultimediaUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MultimediaUncheckedUpdateManyWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    multimedia_name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    offerPrice?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventEventTypeUpdateWithoutEventInput = {
    EventType?: EventTypeUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventEventTypeUncheckedUpdateWithoutEventInput = {
    eventTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type EventEventTypeUncheckedUpdateManyWithoutEventInput = {
    eventTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type EventEventTypeCreateManyEventTypeInput = {
    eventId: number
  }

  export type EventEventTypeUpdateWithoutEventTypeInput = {
    Event?: EventUpdateOneRequiredWithoutEventTypesNestedInput
  }

  export type EventEventTypeUncheckedUpdateWithoutEventTypeInput = {
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type EventEventTypeUncheckedUpdateManyWithoutEventTypeInput = {
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type EventUpdateWithoutMultimediaInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutMultimediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutMultimediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutMusicalInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutMusicalInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutLuxuryInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutLuxuryInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutLuxuryInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutEntertainmentInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutEntertainmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutEntertainmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutBeautyDecorInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutBeautyDecorInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutBeautyDecorInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutAdventureInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutAdventureInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutAdventureInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutPartyPalaceInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    CateringTent?: CateringTentUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutPartyPalaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CateringTent?: CateringTentUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutPartyPalaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutCateringTentInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutEventNestedInput
    PartyPalace?: PartyPalaceUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUpdateManyWithoutEventNestedInput
    User?: UserUpdateOneRequiredWithoutEvents_bookedNestedInput
  }

  export type EventUncheckedUpdateWithoutCateringTentInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PartyPalace?: PartyPalaceUncheckedUpdateManyWithoutEventsNestedInput
    Adventure?: AdventureUncheckedUpdateManyWithoutEventsNestedInput
    BeautyDecor?: BeautyDecorUncheckedUpdateManyWithoutEventsNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutEventsNestedInput
    Entertainment?: EntertainmentUncheckedUpdateManyWithoutEventsNestedInput
    Luxury?: LuxuryUncheckedUpdateManyWithoutEventsNestedInput
    Musical?: MusicalUncheckedUpdateManyWithoutEventsNestedInput
    Multimedia?: MultimediaUncheckedUpdateManyWithoutEventsNestedInput
    EventTypes?: EventEventTypeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCateringTentInput = {
    id?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_rejected?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    approved_by_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictCountOutputTypeDefaultArgs instead
     */
    export type DistrictCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueCountOutputTypeDefaultArgs instead
     */
    export type VenueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventTypeCountOutputTypeDefaultArgs instead
     */
    export type EventTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MultimediaCountOutputTypeDefaultArgs instead
     */
    export type MultimediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MultimediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MusicalCountOutputTypeDefaultArgs instead
     */
    export type MusicalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusicalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LuxuryCountOutputTypeDefaultArgs instead
     */
    export type LuxuryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LuxuryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntertainmentCountOutputTypeDefaultArgs instead
     */
    export type EntertainmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntertainmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeautyDecorCountOutputTypeDefaultArgs instead
     */
    export type BeautyDecorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeautyDecorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdventureCountOutputTypeDefaultArgs instead
     */
    export type AdventureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdventureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartyPalaceCountOutputTypeDefaultArgs instead
     */
    export type PartyPalaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartyPalaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CateringTentCountOutputTypeDefaultArgs instead
     */
    export type CateringTentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CateringTentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DistrictDefaultArgs instead
     */
    export type DistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DistrictDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VenueDefaultArgs instead
     */
    export type VenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VenueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventTypeDefaultArgs instead
     */
    export type EventTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventEventTypeDefaultArgs instead
     */
    export type EventEventTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventEventTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MultimediaDefaultArgs instead
     */
    export type MultimediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MultimediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MusicalDefaultArgs instead
     */
    export type MusicalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusicalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LuxuryDefaultArgs instead
     */
    export type LuxuryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LuxuryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntertainmentDefaultArgs instead
     */
    export type EntertainmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntertainmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingDefaultArgs instead
     */
    export type MeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BeautyDecorDefaultArgs instead
     */
    export type BeautyDecorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BeautyDecorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdventureDefaultArgs instead
     */
    export type AdventureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdventureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartyPalaceDefaultArgs instead
     */
    export type PartyPalaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartyPalaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CateringTentDefaultArgs instead
     */
    export type CateringTentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CateringTentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductImageDefaultArgs instead
     */
    export type ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactUsDefaultArgs instead
     */
    export type ContactUsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactUsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogDefaultArgs instead
     */
    export type BlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductRatingDefaultArgs instead
     */
    export type ProductRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductRatingDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}